{"version":3,"file":"main.11d7aab6137bfd4d59ac.hot-update.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACoC,CAAC;AACN,CAAC;;AAEhC;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,uCAAuC,kDAAiB;AACxD;AACA,kDAAkD,kDAAiB;AACnE,kDAAkD,kDAAiB;AACnE,2BAA2B,qDAAoB;AAC/C,uBAAuB,kDAAiB;AACxC,0CAA0C,kDAAiB;AAC3D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iDAAK;AAC9B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+CAAc;AAC3C;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,mCAAmC,kDAAiB;AACpD,kCAAkC,qDAAoB;AACtD;AACA;AACA,gCAAgC,kDAAiB;AACjD,8BAA8B,4CAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAiB;AAC1C;AACA,8BAA8B,4CAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAc;AAC7C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,kCAAkC,qDAAoB;AACtD;AACA;AACA;AACA,8BAA8B,4CAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qDAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAc;AACzC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAe,WAAW,EAAC;;;;;;;;UCvc3B","sources":["webpack://opensail/./src/js/environment.js","webpack://opensail/webpack/runtime/getFullHash"],"sourcesContent":["/**\n * Environment class to handle wind and waves simulation\n */\nimport * as Utils from './utils.js'; // Import all utility functions as Utils namespace\nimport Water from './water.js'; // Import our new WebGL Water implementation\n\nclass Environment {\n    /**\n     * Create a new Environment\n     * @param {Object} options - Environment configuration options\n     * @param {THREE.Scene} options.scene - Three.js scene to add environment elements\n     */\n    constructor(options = {}) {\n        this.scene = options.scene;\n        \n        // Wind properties\n        this.wind = {\n            direction: 0, // degrees (0 = from north, 90 = from east)\n            speed: 5, // m/s\n            x: 0, // x component\n            y: 0, // y component\n            z: 0, // z component\n            gustFactor: 0.2, // How much gusts affect wind speed\n            changeRate: 0.02 // How quickly wind changes direction/speed\n        };\n        \n        // Update wind vector components\n        this.updateWindVector();\n        \n        // Wave properties\n        this.waves = {\n            isActive: true,\n            amplitude: 0.5, // meters\n            frequency: 0.2, // cycles per meter\n            direction: 0, // degrees (same as wind initially)\n            speed: 1, // wave movement speed\n            steepness: 0.5, // wave steepness factor (0-1)\n            components: [] // Will store multiple wave components for more realism\n        };\n        \n        // Initialize random wave components for more realistic ocean\n        this.initWaveComponents();\n        \n        // Create water and sky in the scene\n        if (this.scene) {\n            this.createWater();\n            this.createSky();\n        }\n    }\n    \n    /**\n     * Initialize multiple wave components for more realistic ocean waves\n     */\n    initWaveComponents() {\n        // Create 5 wave components with varying parameters\n        for (let i = 0; i < 5; i++) {\n            const directionVariation = Utils.randomRange(-20, 20);\n            this.waves.components.push({\n                amplitude: this.waves.amplitude * Utils.randomRange(0.2, 1),\n                frequency: this.waves.frequency * Utils.randomRange(0.5, 2),\n                direction: Utils.normalizeAngle(this.waves.direction + directionVariation),\n                phase: Utils.randomRange(0, Math.PI * 2),\n                speed: this.waves.speed * Utils.randomRange(0.8, 1.2)\n            });\n        }\n    }\n    \n    /**\n     * Create water surface in the scene\n     */\n    createWater() {\n        // Create the new WebGL water simulation\n        this.water = new Water({\n            scene: this.scene,\n            width: 5000,\n            height: 5000,\n            resolution: 256\n        });\n        \n        // Store reference to the water mesh\n        this.waterMesh = this.water.waterMesh;\n        \n        // Add a simple reflection on the water\n        const waterLight = new THREE.DirectionalLight(0xffffbb, 0.5);\n        waterLight.position.set(0, 100, 0);\n        this.scene.add(waterLight);\n        \n        // Create some initial water disturbance\n        this.createInitialWaves();\n    }\n    \n    /**\n     * Create initial wave disturbances\n     */\n    createInitialWaves() {\n        // Add some initial drops to create waves\n        for (let i = 0; i < 5; i++) {\n            const x = Math.random();\n            const y = Math.random();\n            const radius = 0.03 + Math.random() * 0.02;\n            const strength = 0.5 + Math.random() * 0.5;\n            \n            this.water.addDrop(x, y, radius, strength);\n        }\n    }\n    \n    /**\n     * Create sky in the scene\n     */\n    createSky() {\n        // Simple sky using a large sphere\n        const skyGeometry = new THREE.SphereGeometry(2000, 32, 32);\n        // Reverse the normals to make them point inward\n        skyGeometry.scale(-1, 1, 1); \n        \n        const skyMaterial = new THREE.MeshBasicMaterial({\n            color: 0x87ceeb, // Sky blue\n            side: THREE.BackSide\n        });\n        \n        this.skyMesh = new THREE.Mesh(skyGeometry, skyMaterial);\n        this.scene.add(this.skyMesh);\n    }\n    \n    /**\n     * Update the wind vector components based on direction and speed\n     */\n    updateWindVector() {\n        const directionRad = Utils.degToRad(this.wind.direction);\n        this.wind.x = -Math.sin(directionRad) * this.wind.speed;\n        this.wind.z = -Math.cos(directionRad) * this.wind.speed;\n        this.wind.y = 0; // No vertical wind component\n    }\n    \n    /**\n     * Update the environment simulation\n     * @param {number} deltaTime - Time step in seconds\n     * @param {Boat} localBoat - Reference to the player's boat for wake effects\n     */\n    update(deltaTime, localBoat) {\n        this.updateWind(deltaTime);\n        this.updateWaves(deltaTime);\n        \n        // Update water mesh vertices to simulate waves\n        this.updateWaterMesh();\n        \n        // Create boat wake effects if a boat is provided\n        if (localBoat && this.water) {\n            this.createBoatWake(localBoat);\n        }\n        \n        // Return environment data for networking/physics\n        return {\n            wind: {\n                direction: this.wind.direction,\n                speed: this.wind.speed,\n                x: this.wind.x,\n                y: this.wind.y,\n                z: this.wind.z\n            },\n            waves: {\n                isActive: this.waves.isActive,\n                amplitude: this.waves.amplitude,\n                frequency: this.waves.frequency,\n                direction: this.waves.direction,\n                speed: this.waves.speed,\n                components: this.waves.components\n            }\n        };\n    }\n    \n    /**\n     * Update wind parameters\n     * @param {number} deltaTime - Time step in seconds\n     */\n    updateWind(deltaTime) {\n        // Occasionally change wind parameters for realism\n        if (Math.random() < this.wind.changeRate * deltaTime) {\n            // Gradually shift wind direction\n            this.wind.direction += Utils.randomRange(-5, 5);\n            this.wind.direction = Utils.normalizeAngle(this.wind.direction);\n            \n            // Gradually change wind speed\n            const speedChange = Utils.randomRange(-0.5, 0.5);\n            this.wind.speed = Utils.clamp(this.wind.speed + speedChange, 1, 15);\n            \n            // Update components\n            this.updateWindVector();\n            \n            // Gradually align wave direction with wind (with some delay)\n            this.waves.direction += (this.wind.direction - this.waves.direction) * 0.01;\n        }\n        \n        // Add gusts to wind speed\n        if (Math.random() < 0.1 * deltaTime) {\n            const gust = Utils.randomRange(-this.wind.gustFactor, this.wind.gustFactor) \n                        * this.wind.speed;\n            this.wind.speed = Utils.clamp(this.wind.speed + gust, 1, 15);\n            this.updateWindVector();\n        }\n    }\n    \n    /**\n     * Update wave parameters\n     * @param {number} deltaTime - Time step in seconds\n     */\n    updateWaves(deltaTime) {\n        // Gradually adjust wave height based on wind speed\n        const targetAmplitude = this.wind.speed * 0.1;\n        this.waves.amplitude += (targetAmplitude - this.waves.amplitude) * 0.01;\n        \n        // Update each wave component\n        this.waves.components.forEach(component => {\n            // Adjust phase based on speed\n            component.phase += component.speed * deltaTime;\n            \n            // Gradually align with main wave direction (with variation)\n            component.direction += (this.waves.direction - component.direction) * 0.01;\n        });\n    }\n    \n    /**\n     * Update water mesh vertices to create wave effect\n     */\n    updateWaterMesh() {\n        // If we're using the new WebGL water, update it\n        if (this.water) {\n            // Update the WebGL water simulation\n            this.water.update(1/60, this.scene.getObjectByProperty('isCamera', true));\n            \n            // Add occasional drops based on wind speed\n            if (Math.random() < 0.05 * (this.wind.speed / 15)) {\n                const x = Math.random();\n                const y = Math.random();\n                const radius = 0.02 + Math.random() * 0.03;\n                const strength = 0.3 + Math.random() * 0.7 * (this.wind.speed / 15);\n                \n                this.water.addDrop(x, y, radius, strength);\n            }\n            \n            return;\n        }\n        \n        // Original water update code (fallback)\n        if (!this.waterMesh) return;\n        \n        const now = Date.now() / 1000;\n        const geometry = this.waterMesh.geometry;\n        const position = geometry.attributes.position;\n        \n        // For each vertex in the water geometry\n        for (let i = 0; i < position.count; i++) {\n            const x = position.getX(i);\n            const z = position.getZ(i);\n            \n            // Calculate height for this vertex\n            let height = 0;\n            \n            // Sum heights from all wave components\n            this.waves.components.forEach(wave => {\n                const dirRad = Utils.degToRad(wave.direction);\n                const dx = x * Math.cos(dirRad) + z * Math.sin(dirRad);\n                \n                // Simple sine wave\n                height += wave.amplitude * \n                          Math.sin(dx * wave.frequency + now * wave.speed + wave.phase);\n            });\n            \n            // Set the vertex height\n            position.setY(i, height);\n        }\n        \n        // Mark attributes as needing update\n        position.needsUpdate = true;\n        \n        // Update normals for proper lighting\n        geometry.computeVertexNormals();\n    }\n    \n    /**\n     * Set wind parameters manually (e.g., from server or scenario)\n     * @param {Object} windParams - Wind parameters\n     */\n    setWind(windParams) {\n        if (windParams.direction !== undefined) {\n            this.wind.direction = Utils.normalizeAngle(windParams.direction);\n        }\n        \n        if (windParams.speed !== undefined) {\n            this.wind.speed = Utils.clamp(windParams.speed, 0, 30);\n        }\n        \n        // Update wind vector\n        this.updateWindVector();\n    }\n    \n    /**\n     * Set wave parameters manually (e.g., from server or scenario)\n     * @param {Object} waveParams - Wave parameters\n     */\n    setWaves(waveParams) {\n        if (waveParams.isActive !== undefined) {\n            this.waves.isActive = waveParams.isActive;\n        }\n        \n        if (waveParams.amplitude !== undefined) {\n            this.waves.amplitude = waveParams.amplitude;\n        }\n        \n        if (waveParams.frequency !== undefined) {\n            this.waves.frequency = waveParams.frequency;\n        }\n        \n        if (waveParams.direction !== undefined) {\n            this.waves.direction = Utils.normalizeAngle(waveParams.direction);\n        }\n        \n        if (waveParams.speed !== undefined) {\n            this.waves.speed = waveParams.speed;\n        }\n        \n        // Update wave components to match new parameters\n        if (waveParams.components) {\n            this.waves.components = waveParams.components;\n        } else {\n            // Reinitialize components with the new parameters\n            this.waves.components = [];\n            this.initWaveComponents();\n        }\n    }\n    \n    /**\n     * Handle server update for environment synchronization\n     * @param {Object} environmentState - Environment state from server\n     */\n    handleServerUpdate(environmentState) {\n        if (environmentState.wind) {\n            this.setWind(environmentState.wind);\n        }\n        \n        if (environmentState.waves) {\n            this.setWaves(environmentState.waves);\n        }\n    }\n    \n    /**\n     * Calculate wave height at a specific position\n     * @param {THREE.Vector3} position - Position to get wave height for\n     * @param {number} time - Current time in seconds\n     * @returns {number} Wave height at the position\n     */\n    getWaveHeight(position, time) {\n        // If we're using the new WebGL water, use its height calculation\n        if (this.water) {\n            return this.water.getHeightAt(position);\n        }\n        \n        // Original wave height calculation\n        let height = 0;\n        \n        // Skip calculation if waves are disabled\n        if (!this.waves.isActive) return height;\n        \n        // Sum heights from all wave components\n        this.waves.components.forEach(wave => {\n            const dirRad = Utils.degToRad(wave.direction);\n            const dx = position.x * Math.cos(dirRad) + position.z * Math.sin(dirRad);\n            \n            // Simple sine wave\n            height += wave.amplitude * \n                     Math.sin(dx * wave.frequency + time * wave.speed + wave.phase);\n        });\n        \n        return height;\n    }\n    \n    /**\n     * Dispose of environment resources\n     */\n    dispose() {\n        // Clean up WebGL water\n        if (this.water) {\n            this.water.dispose();\n            this.water = null;\n        }\n        \n        // Original cleanup\n        if (this.waterMesh) {\n            this.scene.remove(this.waterMesh);\n            this.waterMesh.geometry.dispose();\n            this.waterMesh.material.dispose();\n            this.waterMesh = null;\n        }\n        \n        if (this.skyMesh) {\n            this.scene.remove(this.skyMesh);\n            this.skyMesh.geometry.dispose();\n            this.skyMesh.material.dispose();\n            this.skyMesh = null;\n        }\n    }\n    \n    /**\n     * Create wake effects from boat movement\n     * @param {Boat} boat - The boat to create wake for\n     */\n    createBoatWake(boat) {\n        if (!this.water || !boat) return;\n        \n        // Only create wake if boat is moving fast enough\n        if (boat.speed < 1) return;\n        \n        // Get boat position in water UV space (0-1)\n        const halfWidth = this.water.width / 2;\n        const halfHeight = this.water.height / 2;\n        \n        const x = (boat.position.x + halfWidth) / this.water.width;\n        const y = (boat.position.z + halfHeight) / this.water.height;\n        \n        // Check if position is within water bounds\n        if (x < 0 || x > 1 || y < 0 || y > 1) return;\n        \n        // Create wake strength based on boat speed\n        const strength = Math.min(1.0, boat.speed / 10);\n        const radius = 0.02 + (boat.speed / 20) * 0.03;\n        \n        // Add drop at boat position\n        this.water.addDrop(x, y, radius, strength);\n        \n        // Add smaller drops behind boat for wake effect\n        if (boat.speed > 5) {\n            // Get boat's backward direction\n            const direction = new THREE.Vector3(0, 0, 1);\n            direction.applyQuaternion(boat.orientation);\n            direction.normalize();\n            \n            // Create wake behind boat\n            for (let i = 1; i <= 2; i++) {\n                const wakeX = x - direction.x * i * 0.02;\n                const wakeY = y - direction.z * i * 0.02;\n                \n                if (wakeX >= 0 && wakeX <= 1 && wakeY >= 0 && wakeY <= 1) {\n                    this.water.addDrop(\n                        wakeX, \n                        wakeY, \n                        radius * 0.7, \n                        strength * 0.5\n                    );\n                }\n            }\n        }\n    }\n}\n\n// Export the Environment class\nexport default Environment; ","__webpack_require__.h = () => (\"badff0b62e49d39b17b5\")"],"names":[],"sourceRoot":""}