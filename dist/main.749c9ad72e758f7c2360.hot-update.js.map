{"version":3,"file":"main.749c9ad72e758f7c2360.hot-update.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACoC,CAAC;AACN,CAAC;;AAEhC;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,uCAAuC,kDAAiB;AACxD;AACA,kDAAkD,kDAAiB;AACnE,kDAAkD,kDAAiB;AACnE,2BAA2B,qDAAoB;AAC/C,uBAAuB,kDAAiB;AACxC,0CAA0C,kDAAiB;AAC3D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iDAAK;AAClC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+CAAc;AAC3C;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,mCAAmC,kDAAiB;AACpD,kCAAkC,qDAAoB;AACtD;AACA;AACA,gCAAgC,kDAAiB;AACjD,8BAA8B,4CAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAiB;AAC1C;AACA,8BAA8B,4CAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,kCAAkC,qDAAoB;AACtD;AACA;AACA;AACA,8BAA8B,4CAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qDAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gBAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAe,WAAW,EAAC;;;;;;;;UCvgB3B","sources":["webpack://opensail/./src/js/environment.js","webpack://opensail/webpack/runtime/getFullHash"],"sourcesContent":["/**\n * Environment class to handle wind and waves simulation\n */\nimport * as Utils from './utils.js'; // Import all utility functions as Utils namespace\nimport Water from './water.js'; // Import our new WebGL Water implementation\n\nclass Environment {\n    /**\n     * Create a new Environment\n     * @param {Object} options - Environment configuration options\n     * @param {THREE.Scene} options.scene - Three.js scene to add environment elements\n     */\n    constructor(options = {}) {\n        this.scene = options.scene;\n        \n        // Wind properties\n        this.wind = {\n            direction: 0, // degrees (0 = from north, 90 = from east)\n            speed: 5, // m/s\n            x: 0, // x component\n            y: 0, // y component\n            z: 0, // z component\n            gustFactor: 0.2, // How much gusts affect wind speed\n            changeRate: 0.02 // How quickly wind changes direction/speed\n        };\n        \n        // Update wind vector components\n        this.updateWindVector();\n        \n        // Wave properties\n        this.waves = {\n            isActive: true,\n            amplitude: 0.5, // meters\n            frequency: 0.2, // cycles per meter\n            direction: 0, // degrees (same as wind initially)\n            speed: 1, // wave movement speed\n            steepness: 0.5, // wave steepness factor (0-1)\n            components: [] // Will store multiple wave components for more realism\n        };\n        \n        // Initialize random wave components for more realistic ocean\n        this.initWaveComponents();\n        \n        // Create water and sky in the scene\n        if (this.scene) {\n            this.createWater();\n            this.createSky();\n        }\n    }\n    \n    /**\n     * Initialize multiple wave components for more realistic ocean waves\n     */\n    initWaveComponents() {\n        // Create 5 wave components with varying parameters\n        for (let i = 0; i < 5; i++) {\n            const directionVariation = Utils.randomRange(-20, 20);\n            this.waves.components.push({\n                amplitude: this.waves.amplitude * Utils.randomRange(0.2, 1),\n                frequency: this.waves.frequency * Utils.randomRange(0.5, 2),\n                direction: Utils.normalizeAngle(this.waves.direction + directionVariation),\n                phase: Utils.randomRange(0, Math.PI * 2),\n                speed: this.waves.speed * Utils.randomRange(0.8, 1.2)\n            });\n        }\n    }\n    \n    /**\n     * Create water in the scene\n     */\n    createWater() {\n        try {\n            // Create the WebGL water simulation\n            this.water = new Water({\n                scene: this.scene,\n                width: 5000,\n                height: 5000,\n                resolution: 256\n            });\n            \n            // Store reference to the water mesh\n            this.waterMesh = this.water.waterMesh;\n            \n            // Add a simple reflection on the water\n            const waterLight = new THREE.DirectionalLight(0xffffbb, 0.5);\n            waterLight.position.set(0, 100, 0);\n            this.scene.add(waterLight);\n            \n            // Create some initial water disturbance\n            this.createInitialWaves();\n        } catch (error) {\n            console.error(\"Failed to initialize WebGL water simulation:\", error);\n            console.log(\"Falling back to basic water mesh...\");\n            \n            // Create a basic water plane as fallback\n            this.createBasicWaterMesh();\n        }\n    }\n    \n    /**\n     * Create a basic water mesh as fallback when WebGL water fails\n     */\n    createBasicWaterMesh() {\n        // Create a simple plane for water\n        const waterGeometry = new THREE.PlaneGeometry(5000, 5000, 32, 32);\n        waterGeometry.rotateX(-Math.PI / 2);\n        \n        // Material with simple wave animation\n        const waterMaterial = new THREE.MeshStandardMaterial({\n            color: 0x0099ff,\n            transparent: true,\n            opacity: 0.8,\n            side: THREE.DoubleSide,\n            flatShading: false,\n            metalness: 0.1,\n            roughness: 0.3,\n        });\n        \n        this.waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);\n        this.waterMesh.receiveShadow = true;\n        this.scene.add(this.waterMesh);\n        \n        // Make vertices wavy for basic animation\n        this.initWaveComponents(); // Ensure we have wave components\n    }\n    \n    /**\n     * Create initial wave disturbances\n     */\n    createInitialWaves() {\n        // Add some initial drops to create waves\n        for (let i = 0; i < 5; i++) {\n            const x = Math.random();\n            const y = Math.random();\n            const radius = 0.03 + Math.random() * 0.02;\n            const strength = 0.5 + Math.random() * 0.5;\n            \n            this.water.addDrop(x, y, radius, strength);\n        }\n    }\n    \n    /**\n     * Create sky in the scene\n     */\n    createSky() {\n        // Simple sky using a large sphere\n        const skyGeometry = new THREE.SphereGeometry(2000, 32, 32);\n        // Reverse the normals to make them point inward\n        skyGeometry.scale(-1, 1, 1); \n        \n        const skyMaterial = new THREE.MeshBasicMaterial({\n            color: 0x87ceeb, // Sky blue\n            side: THREE.BackSide\n        });\n        \n        this.skyMesh = new THREE.Mesh(skyGeometry, skyMaterial);\n        this.scene.add(this.skyMesh);\n    }\n    \n    /**\n     * Update the wind vector components based on direction and speed\n     */\n    updateWindVector() {\n        const directionRad = Utils.degToRad(this.wind.direction);\n        this.wind.x = -Math.sin(directionRad) * this.wind.speed;\n        this.wind.z = -Math.cos(directionRad) * this.wind.speed;\n        this.wind.y = 0; // No vertical wind component\n    }\n    \n    /**\n     * Update the environment simulation\n     * @param {number} deltaTime - Time step in seconds\n     * @param {Boat} localBoat - Reference to the player's boat for wake effects\n     */\n    update(deltaTime, localBoat) {\n        this.updateWind(deltaTime);\n        this.updateWaves(deltaTime);\n        \n        // Update water mesh vertices to simulate waves\n        this.updateWaterMesh();\n        \n        // Create boat wake effects if a boat is provided\n        if (localBoat && this.water) {\n            this.createBoatWake(localBoat);\n        }\n        \n        // Return environment data for networking/physics\n        return {\n            wind: {\n                direction: this.wind.direction,\n                speed: this.wind.speed,\n                x: this.wind.x,\n                y: this.wind.y,\n                z: this.wind.z\n            },\n            waves: {\n                isActive: this.waves.isActive,\n                amplitude: this.waves.amplitude,\n                frequency: this.waves.frequency,\n                direction: this.waves.direction,\n                speed: this.waves.speed,\n                components: this.waves.components\n            }\n        };\n    }\n    \n    /**\n     * Update wind parameters\n     * @param {number} deltaTime - Time step in seconds\n     */\n    updateWind(deltaTime) {\n        // Occasionally change wind parameters for realism\n        if (Math.random() < this.wind.changeRate * deltaTime) {\n            // Gradually shift wind direction\n            this.wind.direction += Utils.randomRange(-5, 5);\n            this.wind.direction = Utils.normalizeAngle(this.wind.direction);\n            \n            // Gradually change wind speed\n            const speedChange = Utils.randomRange(-0.5, 0.5);\n            this.wind.speed = Utils.clamp(this.wind.speed + speedChange, 1, 15);\n            \n            // Update components\n            this.updateWindVector();\n            \n            // Gradually align wave direction with wind (with some delay)\n            this.waves.direction += (this.wind.direction - this.waves.direction) * 0.01;\n        }\n        \n        // Add gusts to wind speed\n        if (Math.random() < 0.1 * deltaTime) {\n            const gust = Utils.randomRange(-this.wind.gustFactor, this.wind.gustFactor) \n                        * this.wind.speed;\n            this.wind.speed = Utils.clamp(this.wind.speed + gust, 1, 15);\n            this.updateWindVector();\n        }\n    }\n    \n    /**\n     * Update wave parameters\n     * @param {number} deltaTime - Time step in seconds\n     */\n    updateWaves(deltaTime) {\n        // Gradually adjust wave height based on wind speed\n        const targetAmplitude = this.wind.speed * 0.1;\n        this.waves.amplitude += (targetAmplitude - this.waves.amplitude) * 0.01;\n        \n        // Update each wave component\n        this.waves.components.forEach(component => {\n            // Adjust phase based on speed\n            component.phase += component.speed * deltaTime;\n            \n            // Gradually align with main wave direction (with variation)\n            component.direction += (this.waves.direction - component.direction) * 0.01;\n        });\n    }\n    \n    /**\n     * Update water mesh vertices to create wave effect\n     */\n    updateWaterMesh() {\n        // If we're using the new WebGL water, update it\n        if (this.water && !this.water.useFallbackTextures) {\n            try {\n                // Update the WebGL water simulation\n                this.water.update(1/60, this.scene.getObjectByProperty('isCamera', true));\n                \n                // Add occasional drops based on wind speed\n                if (Math.random() < 0.05 * (this.wind.speed / 15)) {\n                    const x = Math.random();\n                    const y = Math.random();\n                    const radius = 0.02 + Math.random() * 0.03;\n                    const strength = 0.3 + Math.random() * 0.7 * (this.wind.speed / 15);\n                    \n                    this.water.addDrop(x, y, radius, strength);\n                }\n                \n                return;\n            } catch (e) {\n                console.warn(\"Error updating water:\", e);\n                // Continue with fallback if error occurs\n            }\n        }\n        \n        // Original/fallback water update code\n        if (!this.waterMesh) return;\n        \n        const now = Date.now() / 1000;\n        const geometry = this.waterMesh.geometry;\n        const position = geometry.attributes.position;\n        \n        // Loop through vertices\n        for (let i = 0; i < position.count; i++) {\n            const x = position.getX(i);\n            const z = position.getZ(i);\n            \n            // Skip if this is one of the edges (keep edges flat)\n            if (Math.abs(x) > 2400 || Math.abs(z) > 2400) continue;\n            \n            // Calculate height based on wave components\n            let height = 0;\n            \n            // Sum the heights from all wave components\n            for (const wave of this.waves.components) {\n                // Direction in radians\n                const dirRad = Utils.degToRad(wave.direction);\n                \n                // Project the position onto the wave direction vector\n                const projectedPos = x * Math.sin(dirRad) + z * Math.cos(dirRad);\n                \n                // Add this wave's contribution\n                height += wave.amplitude * Math.sin(\n                    wave.frequency * projectedPos + wave.phase\n                );\n            }\n            \n            // Update the vertex Y position\n            position.setY(i, height);\n        }\n        \n        // Flag geometry for update\n        geometry.attributes.position.needsUpdate = true;\n        geometry.computeVertexNormals();\n    }\n    \n    /**\n     * Set wind parameters manually (e.g., from server or scenario)\n     * @param {Object} windParams - Wind parameters\n     */\n    setWind(windParams) {\n        if (windParams.direction !== undefined) {\n            this.wind.direction = Utils.normalizeAngle(windParams.direction);\n        }\n        \n        if (windParams.speed !== undefined) {\n            this.wind.speed = Utils.clamp(windParams.speed, 0, 30);\n        }\n        \n        // Update wind vector\n        this.updateWindVector();\n    }\n    \n    /**\n     * Set wave parameters manually (e.g., from server or scenario)\n     * @param {Object} waveParams - Wave parameters\n     */\n    setWaves(waveParams) {\n        if (waveParams.isActive !== undefined) {\n            this.waves.isActive = waveParams.isActive;\n        }\n        \n        if (waveParams.amplitude !== undefined) {\n            this.waves.amplitude = waveParams.amplitude;\n        }\n        \n        if (waveParams.frequency !== undefined) {\n            this.waves.frequency = waveParams.frequency;\n        }\n        \n        if (waveParams.direction !== undefined) {\n            this.waves.direction = Utils.normalizeAngle(waveParams.direction);\n        }\n        \n        if (waveParams.speed !== undefined) {\n            this.waves.speed = waveParams.speed;\n        }\n        \n        // Update wave components to match new parameters\n        if (waveParams.components) {\n            this.waves.components = waveParams.components;\n        } else {\n            // Reinitialize components with the new parameters\n            this.waves.components = [];\n            this.initWaveComponents();\n        }\n    }\n    \n    /**\n     * Handle server update for environment synchronization\n     * @param {Object} environmentState - Environment state from server\n     */\n    handleServerUpdate(environmentState) {\n        if (environmentState.wind) {\n            this.setWind(environmentState.wind);\n        }\n        \n        if (environmentState.waves) {\n            this.setWaves(environmentState.waves);\n        }\n    }\n    \n    /**\n     * Get the wave height at a specific position at a specific time\n     * @param {THREE.Vector3} position - Position to get height at\n     * @param {number} time - Time to get height at\n     * @returns {number} Wave height at the position\n     */\n    getWaveHeight(position, time) {\n        // If new WebGL water is being used, get height from there\n        if (this.water) {\n            try {\n                return this.water.getHeightAt(position);\n            } catch (e) {\n                console.warn(\"Error getting water height, falling back to wave components\", e);\n                // Continue with fallback if error occurs\n            }\n        }\n        \n        // Fallback to using wave components for height calculation\n        let height = 0;\n        \n        // Sum heights from all wave components\n        for (const wave of this.waves.components) {\n            const dirRad = Utils.degToRad(wave.direction);\n            \n            // Project position onto wave direction\n            const projectedPos = position.x * Math.sin(dirRad) + position.z * Math.cos(dirRad);\n            \n            // Add this wave's contribution at the given time\n            const phaseOffset = time !== undefined ? time * wave.speed : wave.phase;\n            height += wave.amplitude * Math.sin(wave.frequency * projectedPos + phaseOffset);\n        }\n        \n        return height;\n    }\n    \n    /**\n     * Dispose of environment resources\n     */\n    dispose() {\n        // Clean up WebGL water\n        if (this.water) {\n            this.water.dispose();\n            this.water = null;\n        }\n        \n        // Original cleanup\n        if (this.waterMesh) {\n            this.scene.remove(this.waterMesh);\n            this.waterMesh.geometry.dispose();\n            this.waterMesh.material.dispose();\n            this.waterMesh = null;\n        }\n        \n        if (this.skyMesh) {\n            this.scene.remove(this.skyMesh);\n            this.skyMesh.geometry.dispose();\n            this.skyMesh.material.dispose();\n            this.skyMesh = null;\n        }\n    }\n    \n    /**\n     * Create wake effects as the boat moves through water\n     * @param {Boat} boat - The boat to create wake for\n     */\n    createBoatWake(boat) {\n        // Check if water exists and the boat exists\n        if (!this.water || !boat) return;\n        \n        try {\n            // Only create wake if boat is moving fast enough\n            const speed = boat.velocity.length();\n            if (speed > 1) {\n                // Get boat position relative to water\n                const boatPos = boat.object.position.clone();\n                \n                // Convert to water's UV space (0-1)\n                const waterSize = 5000; // Must match water width/height\n                const x = (boatPos.x + waterSize/2) / waterSize;\n                const y = (boatPos.z + waterSize/2) / waterSize;\n                \n                // Check if boat is within water bounds\n                if (x >= 0 && x <= 1 && y >= 0 && y <= 1) {\n                    // Strength based on speed\n                    const strength = Math.min(0.8, speed * 0.05);\n                    const radius = 0.02;\n                    \n                    // Add drop at boat position\n                    this.water.addDrop(x, y, radius, strength);\n                    \n                    // If going fast enough, create wake behind boat\n                    if (speed > 5) {\n                        // Calculate backward direction of boat\n                        const direction = boat.object.getWorldDirection(new THREE.Vector3());\n                        const backward = direction.multiplyScalar(-1);\n                        \n                        // Create several smaller drops behind the boat\n                        const dropCount = 3;\n                        const wakeSpread = 0.5;\n                        \n                        for (let i = 1; i <= dropCount; i++) {\n                            // Position behind boat\n                            const distance = (i * 0.015);\n                            \n                            const wakeX = x + backward.x * distance;\n                            const wakeY = y + backward.z * distance;\n                            \n                            // Only add if within bounds\n                            if (wakeX >= 0 && wakeX <= 1 && wakeY >= 0 && wakeY <= 1) {\n                                this.water.addDrop(\n                                    wakeX, \n                                    wakeY, \n                                    radius * 0.7, \n                                    strength * 0.5\n                                );\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (e) {\n            console.warn(\"Error creating boat wake:\", e);\n            // Disable wake creation if we encounter errors\n            this.wakeCreationDisabled = true;\n        }\n    }\n}\n\n// Export the Environment class\nexport default Environment; ","__webpack_require__.h = () => (\"76c12307cc44798dd587\")"],"names":[],"sourceRoot":""}