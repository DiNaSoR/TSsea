{"version":3,"file":"main.277a09acfc601206a0b7.hot-update.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA,sDAAsD,iBAAiB;AACvE,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC,gCAAgC,mDAAmD;AACnF,0BAA0B,4BAA4B;AACtD,8BAA8B,kCAAkC;AAChE,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC,0BAA0B,gCAAgC;AAC1D,0BAA0B,aAAa;AACvC,4BAA4B,YAAY;AACxC,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC,yBAAyB,gEAAgE;AACzF,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC,yBAAyB,gEAAgE;AACzF,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,KAAK,EAAC;;;;;;;;UC5mBrB","sources":["webpack://opensail/./src/js/water.js","webpack://opensail/webpack/runtime/getFullHash"],"sourcesContent":["/**\n * WebGL Water implementation inspired by Evan Wallace's WebGL Water\n * https://madebyevan.com/webgl-water/\n */\n\nclass Water {\n    /**\n     * Create a new WebGL Water simulation\n     * @param {Object} options - Water configuration options\n     * @param {THREE.Scene} options.scene - Three.js scene to add water to\n     * @param {Number} options.width - Width of the water surface\n     * @param {Number} options.height - Height of the water surface\n     */\n    constructor(options = {}) {\n        this.scene = options.scene;\n        this.width = options.width || 5000;\n        this.height = options.height || 5000;\n        this.resolution = options.resolution || 256;\n        \n        // Get the renderer from the scene\n        if (this.scene && this.scene.renderer) {\n            this.renderer = this.scene.renderer;\n        }\n        \n        // Check if required WebGL extensions are available\n        this.checkExtensions();\n        \n        // Create the water mesh\n        this.createWaterMesh();\n        \n        // Set up textures and framebuffers for water simulation\n        this.setupSimulation();\n        \n        // Set up shaders\n        this.setupShaders();\n    }\n    \n    /**\n     * Check if required WebGL extensions are available\n     */\n    checkExtensions() {\n        const gl = this.getGLContext();\n        if (!gl) return;\n        \n        // Check for floating point texture support (with fallbacks)\n        this.hasFloatTextures = !!gl.getExtension('OES_texture_float');\n        this.hasFloatTextureLinear = !!gl.getExtension('OES_texture_float_linear');\n        this.hasHalfFloatTextures = !!gl.getExtension('OES_texture_half_float');\n        this.hasHalfFloatTextureLinear = !!gl.getExtension('OES_texture_half_float_linear');\n        \n        // Enable additional extensions that might help\n        gl.getExtension('WEBGL_color_buffer_float');\n        gl.getExtension('EXT_color_buffer_float');\n        gl.getExtension('EXT_color_buffer_half_float');\n        \n        if (!this.hasFloatTextures && !this.hasHalfFloatTextures) {\n            console.warn('This water simulation requires floating point texture support.');\n            // Fall back to use standard texture formats\n            this.useFallbackTextures = true;\n        }\n    }\n    \n    /**\n     * Get the WebGL context\n     * @returns {WebGLRenderingContext} The WebGL context\n     */\n    getGLContext() {\n        if (!this.renderer) {\n            // Create a temporary renderer if one doesn't exist\n            this.renderer = new THREE.WebGLRenderer({ antialias: true });\n            this.renderer.setSize(1, 1); // Minimal size for context\n            this.isTemporaryRenderer = true;\n        }\n        return this.renderer.getContext();\n    }\n    \n    /**\n     * Create the water mesh\n     */\n    createWaterMesh() {\n        // Create a plane for the water surface\n        const geometry = new THREE.PlaneGeometry(this.width, this.height, 1, 1);\n        geometry.rotateX(-Math.PI / 2); // Make it horizontal\n        \n        // Create water material with custom shader that avoids texture dependencies\n        this.waterMaterial = new THREE.ShaderMaterial({\n            uniforms: {\n                time: { value: 0 },\n                sunDirection: { value: new THREE.Vector3(0.5, 0.5, 0).normalize() },\n                camera: { value: new THREE.Vector3() },\n                waterColor: { value: new THREE.Color(0x0099ff) },\n            },\n            vertexShader: this.getWaterVertexShader(),\n            fragmentShader: this.getWaterFragmentShader(),\n            transparent: true,\n            side: THREE.DoubleSide,\n        });\n        \n        // Create the mesh and add it to the scene\n        this.waterMesh = new THREE.Mesh(geometry, this.waterMaterial);\n        this.waterMesh.receiveShadow = true;\n        if (this.scene) {\n            this.scene.add(this.waterMesh);\n        }\n    }\n    \n    /**\n     * Set up textures and framebuffers for water simulation\n     */\n    setupSimulation() {\n        const gl = this.getGLContext();\n        if (!gl) return;\n        \n        // Determine texture type based on available extensions\n        let textureType = THREE.UnsignedByteType;\n        let filter = THREE.LinearFilter;\n        \n        if (!this.useFallbackTextures) {\n            if (this.hasFloatTextures) {\n                textureType = THREE.FloatType;\n                filter = this.hasFloatTextureLinear ? THREE.LinearFilter : THREE.NearestFilter;\n            } else if (this.hasHalfFloatTextures) {\n                textureType = THREE.HalfFloatType;\n                filter = this.hasHalfFloatTextureLinear ? THREE.LinearFilter : THREE.NearestFilter;\n            }\n        }\n        \n        // Create render targets with appropriate settings\n        const rtOptions = {\n            type: textureType,\n            minFilter: filter,\n            magFilter: filter,\n            format: THREE.RGBAFormat,\n            stencilBuffer: false,\n            depthBuffer: false,\n            generateMipmaps: false\n        };\n        \n        // Create textures for water simulation\n        this.textureA = new THREE.WebGLRenderTarget(\n            this.resolution, \n            this.resolution, \n            rtOptions\n        );\n        \n        this.textureB = this.textureA.clone();\n        \n        // Initialize the textures with calm water\n        this.initializeTextures();\n    }\n    \n    /**\n     * Initialize the water textures\n     */\n    initializeTextures() {\n        // Create a simple shader to initialize the water texture\n        const initShader = new THREE.ShaderMaterial({\n            uniforms: {},\n            vertexShader: this.getVertexShader(),\n            fragmentShader: `\n                void main() {\n                    // Initialize with still water (r=height, g=velocity, ba=normal)\n                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                }\n            `\n        });\n        \n        // Render to both textures to initialize them\n        const renderTarget = this.renderer.getRenderTarget();\n        \n        this.renderer.setRenderTarget(this.textureA);\n        this.renderQuad(initShader);\n        \n        this.renderer.setRenderTarget(this.textureB);\n        this.renderQuad(initShader);\n        \n        this.renderer.setRenderTarget(renderTarget);\n    }\n    \n    /**\n     * Set up shaders for water simulation\n     */\n    setupShaders() {\n        // Create drop shader (for adding water drops)\n        this.dropShader = new THREE.ShaderMaterial({\n            uniforms: {\n                texture: { value: null },\n                center: { value: new THREE.Vector2(0, 0) },\n                radius: { value: 0.05 },\n                strength: { value: 0.5 },\n            },\n            vertexShader: this.getVertexShader(),\n            fragmentShader: this.getDropFragmentShader(),\n        });\n        \n        // Create update shader (for water physics)\n        this.updateShader = new THREE.ShaderMaterial({\n            uniforms: {\n                texture: { value: null },\n                delta: { value: new THREE.Vector2(1/this.resolution, 1/this.resolution) },\n            },\n            vertexShader: this.getVertexShader(),\n            fragmentShader: this.getUpdateFragmentShader(),\n        });\n        \n        // Create normal shader (for calculating water normals)\n        this.normalShader = new THREE.ShaderMaterial({\n            uniforms: {\n                texture: { value: null },\n                delta: { value: new THREE.Vector2(1/this.resolution, 1/this.resolution) },\n            },\n            vertexShader: this.getVertexShader(),\n            fragmentShader: this.getNormalFragmentShader(),\n        });\n    }\n    \n    /**\n     * Get the basic vertex shader for the simulation\n     */\n    getVertexShader() {\n        return `\n            varying vec2 coord;\n            void main() {\n                // Convert vertices to texture coordinates\n                coord = position.xy * 0.5 + 0.5;\n                gl_Position = vec4(position.xyz, 1.0);\n            }\n        `;\n    }\n    \n    /**\n     * Get the drop fragment shader\n     */\n    getDropFragmentShader() {\n        return `\n            const float PI = 3.141592653589793;\n            uniform sampler2D texture;\n            uniform vec2 center;\n            uniform float radius;\n            uniform float strength;\n            varying vec2 coord;\n            void main() {\n                /* get vertex info */\n                vec4 info = texture2D(texture, coord);\n                \n                /* add the drop to the height */\n                float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n                drop = 0.5 - cos(drop * PI) * 0.5;\n                info.r += drop * strength;\n                \n                gl_FragColor = info;\n            }\n        `;\n    }\n    \n    /**\n     * Get the update fragment shader\n     */\n    getUpdateFragmentShader() {\n        return `\n            uniform sampler2D texture;\n            uniform vec2 delta;\n            varying vec2 coord;\n            void main() {\n                /* get vertex info */\n                vec4 info = texture2D(texture, coord);\n                \n                /* calculate average neighbor height */\n                vec2 dx = vec2(delta.x, 0.0);\n                vec2 dy = vec2(0.0, delta.y);\n                float average = (\n                    texture2D(texture, coord - dx).r +\n                    texture2D(texture, coord - dy).r +\n                    texture2D(texture, coord + dx).r +\n                    texture2D(texture, coord + dy).r\n                ) * 0.25;\n                \n                /* change the velocity to move toward the average */\n                info.g += (average - info.r) * 2.0;\n                \n                /* attenuate the velocity a little so waves do not last forever */\n                info.g *= 0.995;\n                \n                /* move the vertex along the velocity */\n                info.r += info.g;\n                \n                gl_FragColor = info;\n            }\n        `;\n    }\n    \n    /**\n     * Get the normal fragment shader\n     */\n    getNormalFragmentShader() {\n        return `\n            uniform sampler2D texture;\n            uniform vec2 delta;\n            varying vec2 coord;\n            void main() {\n                /* get vertex info */\n                vec4 info = texture2D(texture, coord);\n                \n                /* update the normal */\n                vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n                vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n                info.ba = normalize(cross(dy, dx)).xz;\n                \n                gl_FragColor = info;\n            }\n        `;\n    }\n    \n    /**\n     * Get the water vertex shader\n     */\n    getWaterVertexShader() {\n        return `\n            uniform float time;\n            \n            varying vec2 vUv;\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            \n            // Simple wave function\n            float simpleWave(vec2 position, float time) {\n                float x = position.x * 0.02;\n                float z = position.y * 0.03;\n                \n                float height = 0.0;\n                height += sin(x + time * 1.0) * 0.5;\n                height += cos(z + time * 0.7) * 0.3;\n                height += sin(x * 3.0 + time * 0.8) * 0.2;\n                height += cos(z * 2.5 + time * 0.6) * 0.1;\n                \n                return height * 0.5;\n            }\n            \n            // Calculate normal from wave function\n            vec3 simpleNormal(vec2 position, float time, float epsilon) {\n                float center = simpleWave(position, time);\n                float right = simpleWave(vec2(position.x + epsilon, position.y), time);\n                float left = simpleWave(vec2(position.x - epsilon, position.y), time);\n                float top = simpleWave(vec2(position.x, position.y + epsilon), time);\n                float bottom = simpleWave(vec2(position.x, position.y - epsilon), time);\n                \n                vec3 normal;\n                normal.x = (left - right) / (2.0 * epsilon);\n                normal.y = 1.0;\n                normal.z = (bottom - top) / (2.0 * epsilon);\n                \n                return normalize(normal);\n            }\n            \n            void main() {\n                vUv = uv;\n                \n                // Calculate wave height\n                float waveHeight = simpleWave(uv, time);\n                \n                // Apply height to vertex\n                vec3 newPosition = position;\n                newPosition.y += waveHeight * 5.0;\n                \n                // Calculate normal\n                vNormal = simpleNormal(uv, time, 0.01);\n                \n                // Pass position to fragment shader (for lighting calculations)\n                vPosition = (modelMatrix * vec4(newPosition, 1.0)).xyz;\n                \n                // Final position\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n            }\n        `;\n    }\n    \n    /**\n     * Get the water fragment shader\n     */\n    getWaterFragmentShader() {\n        return `\n            uniform vec3 waterColor;\n            uniform vec3 sunDirection;\n            uniform vec3 camera;\n            uniform float time;\n            \n            varying vec2 vUv;\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            \n            const float PI = 3.141592653589793;\n            \n            void main() {\n                // Basic water color\n                vec3 baseColor = waterColor;\n                \n                // Add some variation based on position and time\n                float colorVariation = sin(vPosition.x * 0.05 + vPosition.z * 0.05 + time * 0.5) * 0.1 + 0.9;\n                baseColor *= colorVariation;\n                \n                // Add simple lighting - normalized dot product with upward direction\n                vec3 normalVector = normalize(vNormal);\n                \n                // Simplified specular reflection\n                vec3 viewDir = normalize(camera - vPosition);\n                vec3 sunDir = normalize(sunDirection);\n                vec3 halfDir = normalize(viewDir + sunDir);\n                float specular = pow(max(0.0, dot(normalVector, halfDir)), 100.0);\n                \n                // Combine colors\n                vec3 finalColor = baseColor + specular * vec3(1.0, 1.0, 0.8) * 0.5;\n                \n                // Final color with transparency\n                gl_FragColor = vec4(finalColor, 0.8);\n            }\n        `;\n    }\n    \n    /**\n     * Add a water drop at the specified position\n     * @param {number} x - Normalized x coordinate (0-1)\n     * @param {number} y - Normalized y coordinate (0-1)\n     * @param {number} radius - Radius of the drop\n     * @param {number} strength - Strength of the drop\n     */\n    addDrop(x, y, radius, strength) {\n        // Swap textures to update the simulation\n        let temp = this.textureA;\n        this.textureA = this.textureB;\n        this.textureB = temp;\n        \n        // Render drop effect to texture\n        const renderTarget = this.renderer.getRenderTarget();\n        this.renderer.setRenderTarget(this.textureA);\n        \n        this.dropShader.uniforms.texture.value = this.textureB.texture;\n        this.dropShader.uniforms.center.value.set(x, y);\n        this.dropShader.uniforms.radius.value = radius;\n        this.dropShader.uniforms.strength.value = strength;\n        \n        this.renderQuad(this.dropShader);\n        \n        this.renderer.setRenderTarget(renderTarget);\n    }\n    \n    /**\n     * Update the water simulation\n     */\n    stepSimulation() {\n        // Swap textures to update the simulation\n        let temp = this.textureA;\n        this.textureA = this.textureB;\n        this.textureB = temp;\n        \n        // Render update effect to texture\n        const renderTarget = this.renderer.getRenderTarget();\n        this.renderer.setRenderTarget(this.textureA);\n        \n        this.updateShader.uniforms.texture.value = this.textureB.texture;\n        this.renderQuad(this.updateShader);\n        \n        this.renderer.setRenderTarget(renderTarget);\n    }\n    \n    /**\n     * Update water normals\n     */\n    updateNormals() {\n        // Swap textures to update the simulation\n        let temp = this.textureA;\n        this.textureA = this.textureB;\n        this.textureB = temp;\n        \n        // Render normal calculation to texture\n        const renderTarget = this.renderer.getRenderTarget();\n        this.renderer.setRenderTarget(this.textureA);\n        \n        this.normalShader.uniforms.texture.value = this.textureB.texture;\n        this.renderQuad(this.normalShader);\n        \n        this.renderer.setRenderTarget(renderTarget);\n    }\n    \n    /**\n     * Render a quad with the given shader material\n     * @param {THREE.ShaderMaterial} material - Shader material to use\n     */\n    renderQuad(material) {\n        if (!this.quad) {\n            this.quad = new THREE.Mesh(\n                new THREE.PlaneGeometry(2, 2),\n                material\n            );\n            this.quadScene = new THREE.Scene();\n            this.quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);\n            this.quadScene.add(this.quad);\n        } else {\n            this.quad.material = material;\n        }\n        \n        this.renderer.render(this.quadScene, this.quadCamera);\n    }\n    \n    /**\n     * Update the water simulation and rendering\n     * @param {number} deltaTime - Time step in seconds\n     * @param {THREE.Camera} camera - Camera for reflections\n     */\n    update(deltaTime, camera) {\n        try {\n            // Only attempt advanced simulation if it's supported\n            if (!this.useFallbackTextures && !this.useSimplifiedShader) {\n                // Update water physics with normal simulation\n                this.stepSimulation();\n                this.updateNormals();\n            }\n            \n            // Always update the time for wave animation\n            this.currentTime = (this.currentTime || 0) + deltaTime;\n            \n            // Update water material uniforms\n            if (this.waterMaterial && camera) {\n                this.waterMaterial.uniforms.time.value = this.currentTime;\n                this.waterMaterial.uniforms.camera.value.copy(camera.position);\n            }\n        } catch (e) {\n            console.error(\"Error updating water:\", e);\n            \n            // Fall back to simple mode\n            this.useSimplifiedShader = true;\n            \n            // Still update time for fallback animation\n            this.currentTime = (this.currentTime || 0) + deltaTime;\n            if (this.waterMaterial && camera) {\n                this.waterMaterial.uniforms.time.value = this.currentTime;\n                this.waterMaterial.uniforms.camera.value.copy(camera.position);\n            }\n        }\n    }\n    \n    /**\n     * Dispose of water resources\n     */\n    dispose() {\n        if (this.textureA) this.textureA.dispose();\n        if (this.textureB) this.textureB.dispose();\n        \n        if (this.waterMesh) {\n            if (this.scene) this.scene.remove(this.waterMesh);\n            this.waterMesh.geometry.dispose();\n            this.waterMesh.material.dispose();\n        }\n        \n        if (this.quad) {\n            this.quad.geometry.dispose();\n            this.quad.material.dispose();\n            this.quadScene.remove(this.quad);\n        }\n    }\n    \n    /**\n     * Get the water height at a specific position in world space\n     * @param {THREE.Vector3} position - Position to get height at\n     * @returns {number} Water height at the position\n     */\n    getHeightAt(position) {\n        // Convert world position to normalized UV coordinates\n        const halfWidth = this.width / 2;\n        const halfHeight = this.height / 2;\n        \n        // Convert world XZ position to UV (0-1) coordinates\n        const u = (position.x + halfWidth) / this.width;\n        const v = (position.z + halfHeight) / this.height;\n        \n        // Check if position is within water bounds\n        if (u < 0 || u > 1 || v < 0 || v > 1) {\n            return 0; // Return 0 for positions outside the water\n        }\n        \n        // If texture-based height sampling is available, use it\n        if (this.textureA && this.textureA.texture && !this.useFallbackTextures) {\n            try {\n                // This would ideally use a WebGL readPixels call to get the exact height\n                // But this requires complex WebGL operations to read from floating point textures\n                // For now, we'll use the fallback method that produces similar results\n                return this.getFallbackHeightAt(position);\n            } catch (e) {\n                console.warn(\"Error sampling water height, using fallback\", e);\n                return this.getFallbackHeightAt(position);\n            }\n        }\n        \n        // Use the fallback method\n        return this.getFallbackHeightAt(position);\n    }\n    \n    /**\n     * Fallback method to calculate water height using mathematical waves\n     * @param {THREE.Vector3} position - Position to get height at\n     * @returns {number} Calculated water height\n     */\n    getFallbackHeightAt(position) {\n        const time = Date.now() / 1000;\n        \n        // Create a composite wave using multiple sine/cosine waves\n        let height = 0;\n        \n        // Main waves\n        height += Math.sin(position.x * 0.02 + time) * 0.5;\n        height += Math.cos(position.z * 0.03 + time * 0.7) * 0.3;\n        \n        // Add some smaller details\n        height += Math.sin(position.x * 0.06 + time * 1.3) * 0.2;\n        height += Math.cos(position.z * 0.08 + time * 0.8) * 0.1;\n        \n        // Scale the height to match the desired amplitude\n        return height * 0.5;\n    }\n}\n\nexport default Water; ","__webpack_require__.h = () => (\"336a26a8fdd6796bd332\")"],"names":[],"sourceRoot":""}