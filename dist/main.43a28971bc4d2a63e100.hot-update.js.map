{"version":3,"file":"main.43a28971bc4d2a63e100.hot-update.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACoC,CAAC;;AAErC;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,uCAAuC,kDAAiB;AACxD;AACA,kDAAkD,kDAAiB;AACnE,kDAAkD,kDAAiB;AACnE,2BAA2B,qDAAoB;AAC/C,uBAAuB,kDAAiB;AACxC,0CAA0C,kDAAiB;AAC3D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+CAAc;AAC3C;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,mCAAmC,kDAAiB;AACpD,kCAAkC,qDAAoB;AACtD;AACA;AACA,gCAAgC,kDAAiB;AACjD,8BAA8B,4CAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAiB;AAC1C;AACA,8BAA8B,4CAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAc;AAC7C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,kCAAkC,qDAAoB;AACtD;AACA;AACA;AACA,8BAA8B,4CAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qDAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAc;AACzC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAe,WAAW,EAAC;;;;;;;;UCnW3B","sources":["webpack://opensail/./src/js/environment.js","webpack://opensail/webpack/runtime/getFullHash"],"sourcesContent":["/**\n * Environment class to handle wind and waves simulation\n */\nimport * as Utils from './utils.js'; // Import all utility functions as Utils namespace\n\nclass Environment {\n    /**\n     * Create a new Environment\n     * @param {Object} options - Environment configuration options\n     * @param {THREE.Scene} options.scene - Three.js scene to add environment elements\n     */\n    constructor(options = {}) {\n        this.scene = options.scene;\n        \n        // Wind properties\n        this.wind = {\n            direction: 0, // degrees (0 = from north, 90 = from east)\n            speed: 5, // m/s\n            x: 0, // x component\n            y: 0, // y component\n            z: 0, // z component\n            gustFactor: 0.2, // How much gusts affect wind speed\n            changeRate: 0.02 // How quickly wind changes direction/speed\n        };\n        \n        // Update wind vector components\n        this.updateWindVector();\n        \n        // Wave properties\n        this.waves = {\n            isActive: true,\n            amplitude: 0.5, // meters\n            frequency: 0.2, // cycles per meter\n            direction: 0, // degrees (same as wind initially)\n            speed: 1, // wave movement speed\n            steepness: 0.5, // wave steepness factor (0-1)\n            components: [] // Will store multiple wave components for more realism\n        };\n        \n        // Initialize random wave components for more realistic ocean\n        this.initWaveComponents();\n        \n        // Create water and sky in the scene\n        if (this.scene) {\n            this.createWater();\n            this.createSky();\n        }\n    }\n    \n    /**\n     * Initialize multiple wave components for more realistic ocean waves\n     */\n    initWaveComponents() {\n        // Create 5 wave components with varying parameters\n        for (let i = 0; i < 5; i++) {\n            const directionVariation = Utils.randomRange(-20, 20);\n            this.waves.components.push({\n                amplitude: this.waves.amplitude * Utils.randomRange(0.2, 1),\n                frequency: this.waves.frequency * Utils.randomRange(0.5, 2),\n                direction: Utils.normalizeAngle(this.waves.direction + directionVariation),\n                phase: Utils.randomRange(0, Math.PI * 2),\n                speed: this.waves.speed * Utils.randomRange(0.8, 1.2)\n            });\n        }\n    }\n    \n    /**\n     * Create water surface in the scene\n     */\n    createWater() {\n        // Create a large plane for the water\n        const waterGeometry = new THREE.PlaneGeometry(5000, 5000, 100, 100);\n        \n        // Rotate to be horizontal\n        waterGeometry.rotateX(-Math.PI / 2);\n        \n        // Create water material - in a full implementation this would use custom shaders\n        // for more realistic water effects\n        const waterMaterial = new THREE.MeshPhongMaterial({\n            color: 0x2a96e5, // Lighter blue for better contrast with the boat\n            transparent: true,\n            opacity: 0.7,\n            flatShading: false,\n            shininess: 30 // Add some shininess for reflections\n        });\n        \n        // Create the water mesh\n        this.waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);\n        this.scene.add(this.waterMesh);\n        \n        // Add a simple reflection on the water\n        const waterLight = new THREE.DirectionalLight(0xffffbb, 0.5);\n        waterLight.position.set(0, 100, 0);\n        this.scene.add(waterLight);\n    }\n    \n    /**\n     * Create sky in the scene\n     */\n    createSky() {\n        // Simple sky using a large sphere\n        const skyGeometry = new THREE.SphereGeometry(2000, 32, 32);\n        // Reverse the normals to make them point inward\n        skyGeometry.scale(-1, 1, 1); \n        \n        const skyMaterial = new THREE.MeshBasicMaterial({\n            color: 0x87ceeb, // Sky blue\n            side: THREE.BackSide\n        });\n        \n        this.skyMesh = new THREE.Mesh(skyGeometry, skyMaterial);\n        this.scene.add(this.skyMesh);\n    }\n    \n    /**\n     * Update the wind vector components based on direction and speed\n     */\n    updateWindVector() {\n        const directionRad = Utils.degToRad(this.wind.direction);\n        this.wind.x = -Math.sin(directionRad) * this.wind.speed;\n        this.wind.z = -Math.cos(directionRad) * this.wind.speed;\n        this.wind.y = 0; // No vertical wind component\n    }\n    \n    /**\n     * Update the environment simulation\n     * @param {number} deltaTime - Time step in seconds\n     */\n    update(deltaTime) {\n        this.updateWind(deltaTime);\n        this.updateWaves(deltaTime);\n        \n        // Update water mesh vertices to simulate waves\n        this.updateWaterMesh();\n        \n        // Return environment data for networking/physics\n        return {\n            wind: {\n                direction: this.wind.direction,\n                speed: this.wind.speed,\n                x: this.wind.x,\n                y: this.wind.y,\n                z: this.wind.z\n            },\n            waves: {\n                isActive: this.waves.isActive,\n                amplitude: this.waves.amplitude,\n                frequency: this.waves.frequency,\n                direction: this.waves.direction,\n                speed: this.waves.speed,\n                components: this.waves.components\n            }\n        };\n    }\n    \n    /**\n     * Update wind parameters\n     * @param {number} deltaTime - Time step in seconds\n     */\n    updateWind(deltaTime) {\n        // Occasionally change wind parameters for realism\n        if (Math.random() < this.wind.changeRate * deltaTime) {\n            // Gradually shift wind direction\n            this.wind.direction += Utils.randomRange(-5, 5);\n            this.wind.direction = Utils.normalizeAngle(this.wind.direction);\n            \n            // Gradually change wind speed\n            const speedChange = Utils.randomRange(-0.5, 0.5);\n            this.wind.speed = Utils.clamp(this.wind.speed + speedChange, 1, 15);\n            \n            // Update components\n            this.updateWindVector();\n            \n            // Gradually align wave direction with wind (with some delay)\n            this.waves.direction += (this.wind.direction - this.waves.direction) * 0.01;\n        }\n        \n        // Add gusts to wind speed\n        if (Math.random() < 0.1 * deltaTime) {\n            const gust = Utils.randomRange(-this.wind.gustFactor, this.wind.gustFactor) \n                        * this.wind.speed;\n            this.wind.speed = Utils.clamp(this.wind.speed + gust, 1, 15);\n            this.updateWindVector();\n        }\n    }\n    \n    /**\n     * Update wave parameters\n     * @param {number} deltaTime - Time step in seconds\n     */\n    updateWaves(deltaTime) {\n        // Gradually adjust wave height based on wind speed\n        const targetAmplitude = this.wind.speed * 0.1;\n        this.waves.amplitude += (targetAmplitude - this.waves.amplitude) * 0.01;\n        \n        // Update each wave component\n        this.waves.components.forEach(component => {\n            // Adjust phase based on speed\n            component.phase += component.speed * deltaTime;\n            \n            // Gradually align with main wave direction (with variation)\n            component.direction += (this.waves.direction - component.direction) * 0.01;\n        });\n    }\n    \n    /**\n     * Update water mesh vertices to create wave effect\n     */\n    updateWaterMesh() {\n        if (!this.waterMesh) return;\n        \n        const now = Date.now() / 1000;\n        const geometry = this.waterMesh.geometry;\n        const position = geometry.attributes.position;\n        \n        // For each vertex in the water geometry\n        for (let i = 0; i < position.count; i++) {\n            const x = position.getX(i);\n            const z = position.getZ(i);\n            \n            // Calculate height for this vertex\n            let height = 0;\n            \n            // Sum heights from all wave components\n            this.waves.components.forEach(wave => {\n                const dirRad = Utils.degToRad(wave.direction);\n                const dx = x * Math.cos(dirRad) + z * Math.sin(dirRad);\n                \n                // Simple sine wave\n                height += wave.amplitude * \n                          Math.sin(dx * wave.frequency + now * wave.speed + wave.phase);\n            });\n            \n            // Set the vertex height\n            position.setY(i, height);\n        }\n        \n        // Mark attributes as needing update\n        position.needsUpdate = true;\n        \n        // Update normals for proper lighting\n        geometry.computeVertexNormals();\n    }\n    \n    /**\n     * Set wind parameters manually (e.g., from server or scenario)\n     * @param {Object} windParams - Wind parameters\n     */\n    setWind(windParams) {\n        if (windParams.direction !== undefined) {\n            this.wind.direction = Utils.normalizeAngle(windParams.direction);\n        }\n        \n        if (windParams.speed !== undefined) {\n            this.wind.speed = Utils.clamp(windParams.speed, 0, 30);\n        }\n        \n        // Update wind vector\n        this.updateWindVector();\n    }\n    \n    /**\n     * Set wave parameters manually (e.g., from server or scenario)\n     * @param {Object} waveParams - Wave parameters\n     */\n    setWaves(waveParams) {\n        if (waveParams.isActive !== undefined) {\n            this.waves.isActive = waveParams.isActive;\n        }\n        \n        if (waveParams.amplitude !== undefined) {\n            this.waves.amplitude = waveParams.amplitude;\n        }\n        \n        if (waveParams.frequency !== undefined) {\n            this.waves.frequency = waveParams.frequency;\n        }\n        \n        if (waveParams.direction !== undefined) {\n            this.waves.direction = Utils.normalizeAngle(waveParams.direction);\n        }\n        \n        if (waveParams.speed !== undefined) {\n            this.waves.speed = waveParams.speed;\n        }\n        \n        // Update wave components to match new parameters\n        if (waveParams.components) {\n            this.waves.components = waveParams.components;\n        } else {\n            // Reinitialize components with the new parameters\n            this.waves.components = [];\n            this.initWaveComponents();\n        }\n    }\n    \n    /**\n     * Handle server update for environment synchronization\n     * @param {Object} environmentState - Environment state from server\n     */\n    handleServerUpdate(environmentState) {\n        if (environmentState.wind) {\n            this.setWind(environmentState.wind);\n        }\n        \n        if (environmentState.waves) {\n            this.setWaves(environmentState.waves);\n        }\n    }\n    \n    /**\n     * Calculate wave height at a specific world position\n     * @param {THREE.Vector3} position - World position\n     * @param {number} time - Current time\n     * @returns {number} Wave height at the position\n     */\n    getWaveHeight(position, time) {\n        if (!this.waves.isActive) return 0;\n        \n        time = time || Date.now() / 1000;\n        let height = 0;\n        \n        // Sum heights from all wave components\n        this.waves.components.forEach(wave => {\n            const dirRad = Utils.degToRad(wave.direction);\n            const dx = position.x * Math.cos(dirRad) + position.z * Math.sin(dirRad);\n            \n            height += wave.amplitude * \n                      Math.sin(dx * wave.frequency + time * wave.speed + wave.phase);\n        });\n        \n        return height;\n    }\n    \n    /**\n     * Remove environment elements from scene and clean up resources\n     */\n    dispose() {\n        if (this.scene) {\n            if (this.waterMesh) {\n                this.scene.remove(this.waterMesh);\n                this.waterMesh.geometry.dispose();\n                this.waterMesh.material.dispose();\n            }\n            \n            if (this.skyMesh) {\n                this.scene.remove(this.skyMesh);\n                this.skyMesh.geometry.dispose();\n                this.skyMesh.material.dispose();\n            }\n        }\n    }\n}\n\n// Export the Environment class\nexport default Environment; ","__webpack_require__.h = () => (\"89dcc518b23f55f2af7b\")"],"names":[],"sourceRoot":""}