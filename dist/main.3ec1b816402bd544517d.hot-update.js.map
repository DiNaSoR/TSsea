{"version":3,"file":"main.3ec1b816402bd544517d.hot-update.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACoC,CAAC;AACN,CAAC;AAChC;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,uCAAuC,kDAAiB;AACxD;AACA,kDAAkD,kDAAiB;AACnE,kDAAkD,kDAAiB;AACnE,2BAA2B,qDAAoB;AAC/C,uBAAuB,kDAAiB;AACxC,0CAA0C,kDAAiB;AAC3D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iDAAK;AAClC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+CAAc;AAC3C;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,mCAAmC,kDAAiB;AACpD,kCAAkC,qDAAoB;AACtD;AACA;AACA,gCAAgC,kDAAiB;AACjD,8BAA8B,4CAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAiB;AAC1C;AACA,8BAA8B,4CAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,kCAAkC,qDAAoB;AACtD;AACA;AACA;AACA,8BAA8B,4CAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qDAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAc;AACzC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,WAAW,EAAC;;;;;;;;UCpf3B","sources":["webpack://opensail/./src/js/environment.js","webpack://opensail/webpack/runtime/getFullHash"],"sourcesContent":["/**\r\n * Environment class to handle wind and waves simulation\r\n */\r\nimport * as Utils from './utils.js'; // Import all utility functions as Utils namespace\r\nimport Water from './water.js'; // Import our new WebGL Water implementation\r\n\r\nclass Environment {\r\n    /**\r\n     * Create a new Environment\r\n     * @param {Object} options - Environment configuration options\r\n     * @param {THREE.Scene} options.scene - Three.js scene to add environment elements\r\n     */\r\n    constructor(options = {}) {\r\n        this.scene = options.scene;\r\n        \r\n        // Wind properties\r\n        this.wind = {\r\n            direction: 0, // degrees (0 = from north, 90 = from east)\r\n            speed: 5, // m/s\r\n            x: 0, // x component\r\n            y: 0, // y component\r\n            z: 0, // z component\r\n            gustFactor: 0.2, // How much gusts affect wind speed\r\n            changeRate: 0.02 // How quickly wind changes direction/speed\r\n        };\r\n        \r\n        // Update wind vector components\r\n        this.updateWindVector();\r\n        \r\n        // Wave properties\r\n        this.waves = {\r\n            isActive: true,\r\n            amplitude: 0.5, // meters\r\n            frequency: 0.2, // cycles per meter\r\n            direction: 0, // degrees (same as wind initially)\r\n            speed: 1, // wave movement speed\r\n            steepness: 0.5, // wave steepness factor (0-1)\r\n            components: [] // Will store multiple wave components for more realism\r\n        };\r\n        \r\n        // Initialize random wave components for more realistic ocean\r\n        this.initWaveComponents();\r\n        \r\n        // Create water and sky in the scene\r\n        if (this.scene) {\r\n            this.createWater();\r\n            this.createSky();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Initialize multiple wave components for more realistic ocean waves\r\n     */\r\n    initWaveComponents() {\r\n        // Create 5 wave components with varying parameters\r\n        for (let i = 0; i < 5; i++) {\r\n            const directionVariation = Utils.randomRange(-20, 20);\r\n            this.waves.components.push({\r\n                amplitude: this.waves.amplitude * Utils.randomRange(0.2, 1),\r\n                frequency: this.waves.frequency * Utils.randomRange(0.5, 2),\r\n                direction: Utils.normalizeAngle(this.waves.direction + directionVariation),\r\n                phase: Utils.randomRange(0, Math.PI * 2),\r\n                speed: this.waves.speed * Utils.randomRange(0.8, 1.2)\r\n            });\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Create water in the scene\r\n     */\r\n    createWater() {\r\n        try {\r\n            // Create the WebGL water simulation\r\n            this.water = new Water({\r\n                scene: this.scene,\r\n                width: 5000,\r\n                height: 5000,\r\n                resolution: 256\r\n            });\r\n            \r\n            // Store reference to the water mesh\r\n            this.waterMesh = this.water.waterMesh;\r\n            \r\n            // Add a simple reflection on the water\r\n            const waterLight = new THREE.DirectionalLight(0xffffbb, 0.5);\r\n            waterLight.position.set(0, 100, 0);\r\n            this.scene.add(waterLight);\r\n            \r\n            // Create some initial water disturbance\r\n            this.createInitialWaves();\r\n        } catch (error) {\r\n            console.error(\"Failed to initialize WebGL water simulation:\", error);\r\n            console.log(\"Falling back to basic water mesh...\");\r\n            \r\n            // Create a basic water plane as fallback\r\n            this.createBasicWaterMesh();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Create a basic water mesh as fallback when WebGL water fails\r\n     */\r\n    createBasicWaterMesh() {\r\n        // Create a simple plane for water\r\n        const waterGeometry = new THREE.PlaneGeometry(5000, 5000, 32, 32);\r\n        waterGeometry.rotateX(-Math.PI / 2);\r\n        \r\n        // Material with simple wave animation\r\n        const waterMaterial = new THREE.MeshStandardMaterial({\r\n            color: 0x0099ff,\r\n            transparent: true,\r\n            opacity: 0.8,\r\n            side: THREE.DoubleSide,\r\n            flatShading: false,\r\n            metalness: 0.1,\r\n            roughness: 0.3,\r\n        });\r\n        \r\n        this.waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);\r\n        this.waterMesh.receiveShadow = true;\r\n        this.scene.add(this.waterMesh);\r\n        \r\n        // Make vertices wavy for basic animation\r\n        this.initWaveComponents(); // Ensure we have wave components\r\n    }\r\n    \r\n    /**\r\n     * Create initial wave disturbances\r\n     */\r\n    createInitialWaves() {\r\n        // Add some initial drops to create waves\r\n        for (let i = 0; i < 5; i++) {\r\n            const x = Math.random();\r\n            const y = Math.random();\r\n            const radius = 0.03 + Math.random() * 0.02;\r\n            const strength = 0.5 + Math.random() * 0.5;\r\n            \r\n            this.water.addDrop(x, y, radius, strength);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Create sky in the scene\r\n     */\r\n    createSky() {\r\n        // Simple sky using a large sphere\r\n        const skyGeometry = new THREE.SphereGeometry(2000, 32, 32);\r\n        // Reverse the normals to make them point inward\r\n        skyGeometry.scale(-1, 1, 1); \r\n        \r\n        const skyMaterial = new THREE.MeshBasicMaterial({\r\n            color: 0x87ceeb, // Sky blue\r\n            side: THREE.BackSide\r\n        });\r\n        \r\n        this.skyMesh = new THREE.Mesh(skyGeometry, skyMaterial);\r\n        this.scene.add(this.skyMesh);\r\n    }\r\n    \r\n    /**\r\n     * Update the wind vector components based on direction and speed\r\n     */\r\n    updateWindVector() {\r\n        const directionRad = Utils.degToRad(this.wind.direction);\r\n        this.wind.x = -Math.sin(directionRad) * this.wind.speed;\r\n        this.wind.z = -Math.cos(directionRad) * this.wind.speed;\r\n        this.wind.y = 0; // No vertical wind component\r\n    }\r\n    \r\n    /**\r\n     * Update the environment simulation\r\n     * @param {number} deltaTime - Time step in seconds\r\n     * @param {Boat} localBoat - Reference to the player's boat for wake effects\r\n     */\r\n    update(deltaTime, localBoat) {\r\n        this.updateWind(deltaTime);\r\n        this.updateWaves(deltaTime);\r\n        \r\n        // Update water mesh vertices to simulate waves\r\n        this.updateWaterMesh();\r\n        \r\n        // Create boat wake effects if a boat is provided\r\n        if (localBoat && this.water) {\r\n            this.createBoatWake(localBoat);\r\n        }\r\n        \r\n        // Return environment data for networking/physics\r\n        return {\r\n            wind: {\r\n                direction: this.wind.direction,\r\n                speed: this.wind.speed,\r\n                x: this.wind.x,\r\n                y: this.wind.y,\r\n                z: this.wind.z\r\n            },\r\n            waves: {\r\n                isActive: this.waves.isActive,\r\n                amplitude: this.waves.amplitude,\r\n                frequency: this.waves.frequency,\r\n                direction: this.waves.direction,\r\n                speed: this.waves.speed,\r\n                components: this.waves.components\r\n            }\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Update wind parameters\r\n     * @param {number} deltaTime - Time step in seconds\r\n     */\r\n    updateWind(deltaTime) {\r\n        // Occasionally change wind parameters for realism\r\n        if (Math.random() < this.wind.changeRate * deltaTime) {\r\n            // Gradually shift wind direction\r\n            this.wind.direction += Utils.randomRange(-5, 5);\r\n            this.wind.direction = Utils.normalizeAngle(this.wind.direction);\r\n            \r\n            // Gradually change wind speed\r\n            const speedChange = Utils.randomRange(-0.5, 0.5);\r\n            this.wind.speed = Utils.clamp(this.wind.speed + speedChange, 1, 15);\r\n            \r\n            // Update components\r\n            this.updateWindVector();\r\n            \r\n            // Gradually align wave direction with wind (with some delay)\r\n            this.waves.direction += (this.wind.direction - this.waves.direction) * 0.01;\r\n        }\r\n        \r\n        // Add gusts to wind speed\r\n        if (Math.random() < 0.1 * deltaTime) {\r\n            const gust = Utils.randomRange(-this.wind.gustFactor, this.wind.gustFactor) \r\n                        * this.wind.speed;\r\n            this.wind.speed = Utils.clamp(this.wind.speed + gust, 1, 15);\r\n            this.updateWindVector();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Update wave parameters\r\n     * @param {number} deltaTime - Time step in seconds\r\n     */\r\n    updateWaves(deltaTime) {\r\n        // Gradually adjust wave height based on wind speed\r\n        const targetAmplitude = this.wind.speed * 0.1;\r\n        this.waves.amplitude += (targetAmplitude - this.waves.amplitude) * 0.01;\r\n        \r\n        // Update each wave component\r\n        this.waves.components.forEach(component => {\r\n            // Adjust phase based on speed\r\n            component.phase += component.speed * deltaTime;\r\n            \r\n            // Gradually align with main wave direction (with variation)\r\n            component.direction += (this.waves.direction - component.direction) * 0.01;\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Update water mesh vertices to create wave effect\r\n     */\r\n    updateWaterMesh() {\r\n        // If we're using the new WebGL water, update it\r\n        if (this.water && !this.water.useFallbackTextures) {\r\n            try {\r\n                // Update the WebGL water simulation\r\n                this.water.update(1/60, this.scene.getObjectByProperty('isCamera', true));\r\n                \r\n                // Add occasional drops based on wind speed\r\n                if (Math.random() < 0.05 * (this.wind.speed / 15)) {\r\n                    const x = Math.random();\r\n                    const y = Math.random();\r\n                    const radius = 0.02 + Math.random() * 0.03;\r\n                    const strength = 0.3 + Math.random() * 0.7 * (this.wind.speed / 15);\r\n                    \r\n                    this.water.addDrop(x, y, radius, strength);\r\n                }\r\n                \r\n                return;\r\n            } catch (e) {\r\n                console.warn(\"Error updating water:\", e);\r\n                // Continue with fallback if error occurs\r\n            }\r\n        }\r\n        \r\n        // Original/fallback water update code\r\n        if (!this.waterMesh) return;\r\n        \r\n        const now = Date.now() / 1000;\r\n        const geometry = this.waterMesh.geometry;\r\n        const position = geometry.attributes.position;\r\n        \r\n        // Loop through vertices\r\n        for (let i = 0; i < position.count; i++) {\r\n            const x = position.getX(i);\r\n            const z = position.getZ(i);\r\n            \r\n            // Skip if this is one of the edges (keep edges flat)\r\n            if (Math.abs(x) > 2400 || Math.abs(z) > 2400) continue;\r\n            \r\n            // Calculate height based on wave components\r\n            let height = 0;\r\n            \r\n            // Sum the heights from all wave components\r\n            for (const wave of this.waves.components) {\r\n                // Direction in radians\r\n                const dirRad = Utils.degToRad(wave.direction);\r\n                \r\n                // Project the position onto the wave direction vector\r\n                const projectedPos = x * Math.sin(dirRad) + z * Math.cos(dirRad);\r\n                \r\n                // Add this wave's contribution\r\n                height += wave.amplitude * Math.sin(\r\n                    wave.frequency * projectedPos + wave.phase\r\n                );\r\n            }\r\n            \r\n            // Update the vertex Y position\r\n            position.setY(i, height);\r\n        }\r\n        \r\n        // Flag geometry for update\r\n        geometry.attributes.position.needsUpdate = true;\r\n        geometry.computeVertexNormals();\r\n    }\r\n    \r\n    /**\r\n     * Set wind parameters manually (e.g., from server or scenario)\r\n     * @param {Object} windParams - Wind parameters\r\n     */\r\n    setWind(windParams) {\r\n        if (windParams.direction !== undefined) {\r\n            this.wind.direction = Utils.normalizeAngle(windParams.direction);\r\n        }\r\n        \r\n        if (windParams.speed !== undefined) {\r\n            this.wind.speed = Utils.clamp(windParams.speed, 0, 30);\r\n        }\r\n        \r\n        // Update wind vector\r\n        this.updateWindVector();\r\n    }\r\n    \r\n    /**\r\n     * Set wave parameters manually (e.g., from server or scenario)\r\n     * @param {Object} waveParams - Wave parameters\r\n     */\r\n    setWaves(waveParams) {\r\n        if (waveParams.isActive !== undefined) {\r\n            this.waves.isActive = waveParams.isActive;\r\n        }\r\n        \r\n        if (waveParams.amplitude !== undefined) {\r\n            this.waves.amplitude = waveParams.amplitude;\r\n        }\r\n        \r\n        if (waveParams.frequency !== undefined) {\r\n            this.waves.frequency = waveParams.frequency;\r\n        }\r\n        \r\n        if (waveParams.direction !== undefined) {\r\n            this.waves.direction = Utils.normalizeAngle(waveParams.direction);\r\n        }\r\n        \r\n        if (waveParams.speed !== undefined) {\r\n            this.waves.speed = waveParams.speed;\r\n        }\r\n        \r\n        // Update wave components to match new parameters\r\n        if (waveParams.components) {\r\n            this.waves.components = waveParams.components;\r\n        } else {\r\n            // Reinitialize components with the new parameters\r\n            this.waves.components = [];\r\n            this.initWaveComponents();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle server update for environment synchronization\r\n     * @param {Object} environmentState - Environment state from server\r\n     */\r\n    handleServerUpdate(environmentState) {\r\n        if (environmentState.wind) {\r\n            this.setWind(environmentState.wind);\r\n        }\r\n        \r\n        if (environmentState.waves) {\r\n            this.setWaves(environmentState.waves);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Calculate wave height at a specific position\r\n     * @param {THREE.Vector3} position - Position to get wave height for\r\n     * @param {number} time - Current time in seconds\r\n     * @returns {number} Wave height at the position\r\n     */\r\n    getWaveHeight(position, time) {\r\n        // If we're using the new WebGL water, use its height calculation\r\n        if (this.water) {\r\n            return this.water.getHeightAt(position);\r\n        }\r\n        \r\n        // Original wave height calculation\r\n        let height = 0;\r\n        \r\n        // Skip calculation if waves are disabled\r\n        if (!this.waves.isActive) return height;\r\n        \r\n        // Sum heights from all wave components\r\n        this.waves.components.forEach(wave => {\r\n            const dirRad = Utils.degToRad(wave.direction);\r\n            const dx = position.x * Math.cos(dirRad) + position.z * Math.sin(dirRad);\r\n            \r\n            // Simple sine wave\r\n            height += wave.amplitude * \r\n                     Math.sin(dx * wave.frequency + time * wave.speed + wave.phase);\r\n        });\r\n        \r\n        return height;\r\n    }\r\n    \r\n    /**\r\n     * Dispose of environment resources\r\n     */\r\n    dispose() {\r\n        // Clean up WebGL water\r\n        if (this.water) {\r\n            this.water.dispose();\r\n            this.water = null;\r\n        }\r\n        \r\n        // Original cleanup\r\n        if (this.waterMesh) {\r\n            this.scene.remove(this.waterMesh);\r\n            this.waterMesh.geometry.dispose();\r\n            this.waterMesh.material.dispose();\r\n            this.waterMesh = null;\r\n        }\r\n        \r\n        if (this.skyMesh) {\r\n            this.scene.remove(this.skyMesh);\r\n            this.skyMesh.geometry.dispose();\r\n            this.skyMesh.material.dispose();\r\n            this.skyMesh = null;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Create wake effects from boat movement\r\n     * @param {Boat} boat - The boat to create wake for\r\n     */\r\n    createBoatWake(boat) {\r\n        if (!this.water || !boat) return;\r\n        \r\n        // Only create wake if boat is moving fast enough\r\n        if (boat.speed < 1) return;\r\n        \r\n        // Get boat position in water UV space (0-1)\r\n        const halfWidth = this.water.width / 2;\r\n        const halfHeight = this.water.height / 2;\r\n        \r\n        const x = (boat.position.x + halfWidth) / this.water.width;\r\n        const y = (boat.position.z + halfHeight) / this.water.height;\r\n        \r\n        // Check if position is within water bounds\r\n        if (x < 0 || x > 1 || y < 0 || y > 1) return;\r\n        \r\n        // Create wake strength based on boat speed\r\n        const strength = Math.min(1.0, boat.speed / 10);\r\n        const radius = 0.02 + (boat.speed / 20) * 0.03;\r\n        \r\n        // Add drop at boat position\r\n        this.water.addDrop(x, y, radius, strength);\r\n        \r\n        // Add smaller drops behind boat for wake effect\r\n        if (boat.speed > 5) {\r\n            // Get boat's backward direction\r\n            const direction = new THREE.Vector3(0, 0, 1);\r\n            direction.applyQuaternion(boat.orientation);\r\n            direction.normalize();\r\n            \r\n            // Create wake behind boat\r\n            for (let i = 1; i <= 2; i++) {\r\n                const wakeX = x - direction.x * i * 0.02;\r\n                const wakeY = y - direction.z * i * 0.02;\r\n                \r\n                if (wakeX >= 0 && wakeX <= 1 && wakeY >= 0 && wakeY <= 1) {\r\n                    this.water.addDrop(\r\n                        wakeX, \r\n                        wakeY, \r\n                        radius * 0.7, \r\n                        strength * 0.5\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Export the Environment class\r\nexport default Environment; ","__webpack_require__.h = () => (\"215e3d9cd52c0c6981cf\")"],"names":[],"sourceRoot":""}