{"version":3,"file":"main.fa383c117d1c52522edb.hot-update.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA,sDAAsD,iBAAiB;AACvE,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC,gCAAgC,aAAa;AAC7C,gCAAgC,uCAAuC;AACvE,0BAA0B,4BAA4B;AACtD,8BAA8B,kCAAkC;AAChE,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC,0BAA0B,gCAAgC;AAC1D,0BAA0B,aAAa;AACvC,4BAA4B,YAAY;AACxC,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC,yBAAyB,gEAAgE;AACzF,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC,yBAAyB,gEAAgE;AACzF,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,KAAK,EAAC;;;;;;;;UChfrB","sources":["webpack://opensail/./src/js/water.js","webpack://opensail/webpack/runtime/getFullHash"],"sourcesContent":["/**\n * WebGL Water implementation inspired by Evan Wallace's WebGL Water\n * https://madebyevan.com/webgl-water/\n */\n\nclass Water {\n    /**\n     * Create a new WebGL Water simulation\n     * @param {Object} options - Water configuration options\n     * @param {THREE.Scene} options.scene - Three.js scene to add water to\n     * @param {Number} options.width - Width of the water surface\n     * @param {Number} options.height - Height of the water surface\n     */\n    constructor(options = {}) {\n        this.scene = options.scene;\n        this.width = options.width || 5000;\n        this.height = options.height || 5000;\n        this.resolution = options.resolution || 256;\n        \n        // Check if required WebGL extensions are available\n        this.checkExtensions();\n        \n        // Create the water mesh\n        this.createWaterMesh();\n        \n        // Set up textures and framebuffers for water simulation\n        this.setupSimulation();\n        \n        // Set up shaders\n        this.setupShaders();\n    }\n    \n    /**\n     * Check if required WebGL extensions are available\n     */\n    checkExtensions() {\n        const gl = this.getGLContext();\n        if (!gl) return;\n        \n        // Check for floating point texture support\n        this.hasFloatTextures = !!gl.getExtension('OES_texture_float');\n        this.hasFloatTextureLinear = !!gl.getExtension('OES_texture_float_linear');\n        this.hasHalfFloatTextures = !!gl.getExtension('OES_texture_half_float');\n        this.hasHalfFloatTextureLinear = !!gl.getExtension('OES_texture_half_float_linear');\n        \n        if (!this.hasFloatTextures && !this.hasHalfFloatTextures) {\n            console.warn('This water simulation requires floating point texture support.');\n        }\n    }\n    \n    /**\n     * Get the WebGL context\n     * @returns {WebGLRenderingContext} The WebGL context\n     */\n    getGLContext() {\n        if (!this.renderer) {\n            this.renderer = new THREE.WebGLRenderer({ antialias: true });\n            this.renderer.setSize(1, 1); // Minimal size for context\n        }\n        return this.renderer.getContext();\n    }\n    \n    /**\n     * Create the water mesh\n     */\n    createWaterMesh() {\n        // Create a plane for the water surface\n        const geometry = new THREE.PlaneGeometry(this.width, this.height, 1, 1);\n        geometry.rotateX(-Math.PI / 2); // Make it horizontal\n        \n        // Create water material with custom shader\n        this.waterMaterial = new THREE.ShaderMaterial({\n            uniforms: {\n                time: { value: 0 },\n                waterTexture: { value: null },\n                sunDirection: { value: new THREE.Vector3(0.5, 0.5, 0) },\n                camera: { value: new THREE.Vector3() },\n                waterColor: { value: new THREE.Color(0x0099ff) },\n            },\n            vertexShader: this.getWaterVertexShader(),\n            fragmentShader: this.getWaterFragmentShader(),\n            transparent: true,\n            side: THREE.DoubleSide,\n        });\n        \n        // Create the mesh and add it to the scene\n        this.waterMesh = new THREE.Mesh(geometry, this.waterMaterial);\n        this.waterMesh.receiveShadow = true;\n        if (this.scene) {\n            this.scene.add(this.waterMesh);\n        }\n    }\n    \n    /**\n     * Set up textures and framebuffers for water simulation\n     */\n    setupSimulation() {\n        const gl = this.getGLContext();\n        if (!gl) return;\n        \n        // Determine texture type based on available extensions\n        const textureType = this.hasFloatTextures ? THREE.FloatType : \n                           (this.hasHalfFloatTextures ? THREE.HalfFloatType : THREE.UnsignedByteType);\n        const filter = (this.hasFloatTextureLinear || this.hasHalfFloatTextureLinear) ? \n                      THREE.LinearFilter : THREE.NearestFilter;\n        \n        // Create textures for water simulation\n        this.textureA = new THREE.WebGLRenderTarget(\n            this.resolution, \n            this.resolution, \n            {\n                type: textureType,\n                minFilter: filter,\n                magFilter: filter,\n                format: THREE.RGBAFormat,\n                stencilBuffer: false,\n                depthBuffer: false,\n            }\n        );\n        \n        this.textureB = this.textureA.clone();\n        \n        // Initialize the textures with calm water\n        this.initializeTextures();\n    }\n    \n    /**\n     * Initialize the water textures\n     */\n    initializeTextures() {\n        // Initialize with a flat water surface\n        // This would be implemented using a shader to fill the texture with initial values\n    }\n    \n    /**\n     * Set up shaders for water simulation\n     */\n    setupShaders() {\n        // Create drop shader (for adding water drops)\n        this.dropShader = new THREE.ShaderMaterial({\n            uniforms: {\n                texture: { value: null },\n                center: { value: new THREE.Vector2(0, 0) },\n                radius: { value: 0.05 },\n                strength: { value: 0.5 },\n            },\n            vertexShader: this.getVertexShader(),\n            fragmentShader: this.getDropFragmentShader(),\n        });\n        \n        // Create update shader (for water physics)\n        this.updateShader = new THREE.ShaderMaterial({\n            uniforms: {\n                texture: { value: null },\n                delta: { value: new THREE.Vector2(1/this.resolution, 1/this.resolution) },\n            },\n            vertexShader: this.getVertexShader(),\n            fragmentShader: this.getUpdateFragmentShader(),\n        });\n        \n        // Create normal shader (for calculating water normals)\n        this.normalShader = new THREE.ShaderMaterial({\n            uniforms: {\n                texture: { value: null },\n                delta: { value: new THREE.Vector2(1/this.resolution, 1/this.resolution) },\n            },\n            vertexShader: this.getVertexShader(),\n            fragmentShader: this.getNormalFragmentShader(),\n        });\n    }\n    \n    /**\n     * Get the basic vertex shader for the simulation\n     */\n    getVertexShader() {\n        return `\n            varying vec2 coord;\n            void main() {\n                coord = position.xy * 0.5 + 0.5;\n                gl_Position = vec4(position.xyz, 1.0);\n            }\n        `;\n    }\n    \n    /**\n     * Get the drop fragment shader\n     */\n    getDropFragmentShader() {\n        return `\n            const float PI = 3.141592653589793;\n            uniform sampler2D texture;\n            uniform vec2 center;\n            uniform float radius;\n            uniform float strength;\n            varying vec2 coord;\n            void main() {\n                /* get vertex info */\n                vec4 info = texture2D(texture, coord);\n                \n                /* add the drop to the height */\n                float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n                drop = 0.5 - cos(drop * PI) * 0.5;\n                info.r += drop * strength;\n                \n                gl_FragColor = info;\n            }\n        `;\n    }\n    \n    /**\n     * Get the update fragment shader\n     */\n    getUpdateFragmentShader() {\n        return `\n            uniform sampler2D texture;\n            uniform vec2 delta;\n            varying vec2 coord;\n            void main() {\n                /* get vertex info */\n                vec4 info = texture2D(texture, coord);\n                \n                /* calculate average neighbor height */\n                vec2 dx = vec2(delta.x, 0.0);\n                vec2 dy = vec2(0.0, delta.y);\n                float average = (\n                    texture2D(texture, coord - dx).r +\n                    texture2D(texture, coord - dy).r +\n                    texture2D(texture, coord + dx).r +\n                    texture2D(texture, coord + dy).r\n                ) * 0.25;\n                \n                /* change the velocity to move toward the average */\n                info.g += (average - info.r) * 2.0;\n                \n                /* attenuate the velocity a little so waves do not last forever */\n                info.g *= 0.995;\n                \n                /* move the vertex along the velocity */\n                info.r += info.g;\n                \n                gl_FragColor = info;\n            }\n        `;\n    }\n    \n    /**\n     * Get the normal fragment shader\n     */\n    getNormalFragmentShader() {\n        return `\n            uniform sampler2D texture;\n            uniform vec2 delta;\n            varying vec2 coord;\n            void main() {\n                /* get vertex info */\n                vec4 info = texture2D(texture, coord);\n                \n                /* update the normal */\n                vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\n                vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\n                info.ba = normalize(cross(dy, dx)).xz;\n                \n                gl_FragColor = info;\n            }\n        `;\n    }\n    \n    /**\n     * Get the water vertex shader\n     */\n    getWaterVertexShader() {\n        return `\n            uniform sampler2D waterTexture;\n            uniform float time;\n            varying vec2 vUv;\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            \n            void main() {\n                vUv = uv;\n                \n                // Sample water height from texture\n                vec4 waterInfo = texture2D(waterTexture, uv);\n                \n                // Get vertex position with water height\n                vec3 pos = position;\n                pos.y += waterInfo.r * 5.0; // Scale the wave height\n                \n                // Get water normal from texture\n                vNormal = normalize(vec3(waterInfo.b, 1.0, waterInfo.a));\n                \n                // Transform position to world space\n                vPosition = (modelMatrix * vec4(pos, 1.0)).xyz;\n                \n                // Standard transformation\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n            }\n        `;\n    }\n    \n    /**\n     * Get the water fragment shader\n     */\n    getWaterFragmentShader() {\n        return `\n            uniform vec3 waterColor;\n            uniform vec3 sunDirection;\n            uniform vec3 camera;\n            varying vec2 vUv;\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            \n            void main() {\n                // Calculate view direction\n                vec3 viewDirection = normalize(camera - vPosition);\n                \n                // Calculate reflection\n                float fresnel = 0.02 + 0.98 * pow(1.0 - dot(viewDirection, vNormal), 5.0);\n                \n                // Calculate sun reflection\n                float sunReflection = pow(max(0.0, dot(reflect(-viewDirection, vNormal), sunDirection)), 100.0);\n                \n                // Final color\n                vec3 color = waterColor;\n                color += sunReflection * 0.5;\n                \n                gl_FragColor = vec4(color, 0.8);\n            }\n        `;\n    }\n    \n    /**\n     * Add a water drop at the specified position\n     * @param {number} x - Normalized x coordinate (0-1)\n     * @param {number} y - Normalized y coordinate (0-1)\n     * @param {number} radius - Radius of the drop\n     * @param {number} strength - Strength of the drop\n     */\n    addDrop(x, y, radius, strength) {\n        // Swap textures to update the simulation\n        let temp = this.textureA;\n        this.textureA = this.textureB;\n        this.textureB = temp;\n        \n        // Render drop effect to texture\n        const renderTarget = this.renderer.getRenderTarget();\n        this.renderer.setRenderTarget(this.textureA);\n        \n        this.dropShader.uniforms.texture.value = this.textureB.texture;\n        this.dropShader.uniforms.center.value.set(x, y);\n        this.dropShader.uniforms.radius.value = radius;\n        this.dropShader.uniforms.strength.value = strength;\n        \n        this.renderQuad(this.dropShader);\n        \n        this.renderer.setRenderTarget(renderTarget);\n    }\n    \n    /**\n     * Update the water simulation\n     */\n    stepSimulation() {\n        // Swap textures to update the simulation\n        let temp = this.textureA;\n        this.textureA = this.textureB;\n        this.textureB = temp;\n        \n        // Render update effect to texture\n        const renderTarget = this.renderer.getRenderTarget();\n        this.renderer.setRenderTarget(this.textureA);\n        \n        this.updateShader.uniforms.texture.value = this.textureB.texture;\n        this.renderQuad(this.updateShader);\n        \n        this.renderer.setRenderTarget(renderTarget);\n    }\n    \n    /**\n     * Update water normals\n     */\n    updateNormals() {\n        // Swap textures to update the simulation\n        let temp = this.textureA;\n        this.textureA = this.textureB;\n        this.textureB = temp;\n        \n        // Render normal calculation to texture\n        const renderTarget = this.renderer.getRenderTarget();\n        this.renderer.setRenderTarget(this.textureA);\n        \n        this.normalShader.uniforms.texture.value = this.textureB.texture;\n        this.renderQuad(this.normalShader);\n        \n        this.renderer.setRenderTarget(renderTarget);\n    }\n    \n    /**\n     * Render a quad with the given shader material\n     * @param {THREE.ShaderMaterial} material - Shader material to use\n     */\n    renderQuad(material) {\n        if (!this.quad) {\n            this.quad = new THREE.Mesh(\n                new THREE.PlaneGeometry(2, 2),\n                material\n            );\n            this.quadScene = new THREE.Scene();\n            this.quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);\n            this.quadScene.add(this.quad);\n        } else {\n            this.quad.material = material;\n        }\n        \n        this.renderer.render(this.quadScene, this.quadCamera);\n    }\n    \n    /**\n     * Update the water simulation and rendering\n     * @param {number} deltaTime - Time step in seconds\n     * @param {THREE.Camera} camera - Camera for reflections\n     */\n    update(deltaTime, camera) {\n        // Update water physics\n        this.stepSimulation();\n        this.updateNormals();\n        \n        // Update water material uniforms\n        if (this.waterMaterial && camera) {\n            this.waterMaterial.uniforms.time.value += deltaTime;\n            this.waterMaterial.uniforms.waterTexture.value = this.textureA.texture;\n            this.waterMaterial.uniforms.camera.value.copy(camera.position);\n        }\n    }\n    \n    /**\n     * Dispose of water resources\n     */\n    dispose() {\n        if (this.textureA) this.textureA.dispose();\n        if (this.textureB) this.textureB.dispose();\n        \n        if (this.waterMesh) {\n            if (this.scene) this.scene.remove(this.waterMesh);\n            this.waterMesh.geometry.dispose();\n            this.waterMesh.material.dispose();\n        }\n        \n        if (this.quad) {\n            this.quad.geometry.dispose();\n            this.quad.material.dispose();\n            this.quadScene.remove(this.quad);\n        }\n    }\n    \n    /**\n     * Get the water height at a specific position in world space\n     * @param {THREE.Vector3} position - Position to get height at\n     * @returns {number} Water height at the position\n     */\n    getHeightAt(position) {\n        // Convert world position to normalized UV coordinates\n        const halfWidth = this.width / 2;\n        const halfHeight = this.height / 2;\n        \n        // Convert world XZ position to UV (0-1) coordinates\n        const u = (position.x + halfWidth) / this.width;\n        const v = (position.z + halfHeight) / this.height;\n        \n        // Check if position is within water bounds\n        if (u < 0 || u > 1 || v < 0 || v > 1) {\n            return 0; // Return 0 for positions outside the water\n        }\n        \n        // If we have valid water texture data, sample it\n        if (this.textureA && this.textureA.texture) {\n            // Create a temporary canvas to read pixel data\n            if (!this.canvas) {\n                this.canvas = document.createElement('canvas');\n                this.canvas.width = 1;\n                this.canvas.height = 1;\n                this.context = this.canvas.getContext('2d');\n            }\n            \n            // This would ideally use a WebGL shader to sample the texture\n            // For simplicity, we'll approximate with a sine wave based on the position\n            const time = Date.now() / 1000;\n            const waveHeight = Math.sin(position.x * 0.02 + time) * 0.5 + \n                               Math.cos(position.z * 0.03 + time * 0.7) * 0.3;\n            \n            return waveHeight;\n        }\n        \n        return 0;\n    }\n}\n\nexport default Water; ","__webpack_require__.h = () => (\"11d7aab6137bfd4d59ac\")"],"names":[],"sourceRoot":""}