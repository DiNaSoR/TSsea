{"version":3,"file":"main.1c6e0c9d949bd024e82e.hot-update.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA,sDAAsD,iBAAiB;AACvE,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC,gCAAgC,aAAa;AAC7C,gCAAgC,uCAAuC;AACvE,0BAA0B,4BAA4B;AACtD,8BAA8B,kCAAkC;AAChE,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC,0BAA0B,gCAAgC;AAC1D,0BAA0B,aAAa;AACvC,4BAA4B,YAAY;AACxC,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC,yBAAyB,gEAAgE;AACzF,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC,yBAAyB,gEAAgE;AACzF,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;UChfrB","sources":["webpack://opensail/./src/js/water.js","webpack://opensail/webpack/runtime/getFullHash"],"sourcesContent":["/**\r\n * WebGL Water implementation inspired by Evan Wallace's WebGL Water\r\n * https://madebyevan.com/webgl-water/\r\n */\r\n\r\nclass Water {\r\n    /**\r\n     * Create a new WebGL Water simulation\r\n     * @param {Object} options - Water configuration options\r\n     * @param {THREE.Scene} options.scene - Three.js scene to add water to\r\n     * @param {Number} options.width - Width of the water surface\r\n     * @param {Number} options.height - Height of the water surface\r\n     */\r\n    constructor(options = {}) {\r\n        this.scene = options.scene;\r\n        this.width = options.width || 5000;\r\n        this.height = options.height || 5000;\r\n        this.resolution = options.resolution || 256;\r\n        \r\n        // Check if required WebGL extensions are available\r\n        this.checkExtensions();\r\n        \r\n        // Create the water mesh\r\n        this.createWaterMesh();\r\n        \r\n        // Set up textures and framebuffers for water simulation\r\n        this.setupSimulation();\r\n        \r\n        // Set up shaders\r\n        this.setupShaders();\r\n    }\r\n    \r\n    /**\r\n     * Check if required WebGL extensions are available\r\n     */\r\n    checkExtensions() {\r\n        const gl = this.getGLContext();\r\n        if (!gl) return;\r\n        \r\n        // Check for floating point texture support\r\n        this.hasFloatTextures = !!gl.getExtension('OES_texture_float');\r\n        this.hasFloatTextureLinear = !!gl.getExtension('OES_texture_float_linear');\r\n        this.hasHalfFloatTextures = !!gl.getExtension('OES_texture_half_float');\r\n        this.hasHalfFloatTextureLinear = !!gl.getExtension('OES_texture_half_float_linear');\r\n        \r\n        if (!this.hasFloatTextures && !this.hasHalfFloatTextures) {\r\n            console.warn('This water simulation requires floating point texture support.');\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Get the WebGL context\r\n     * @returns {WebGLRenderingContext} The WebGL context\r\n     */\r\n    getGLContext() {\r\n        if (!this.renderer) {\r\n            this.renderer = new THREE.WebGLRenderer({ antialias: true });\r\n            this.renderer.setSize(1, 1); // Minimal size for context\r\n        }\r\n        return this.renderer.getContext();\r\n    }\r\n    \r\n    /**\r\n     * Create the water mesh\r\n     */\r\n    createWaterMesh() {\r\n        // Create a plane for the water surface\r\n        const geometry = new THREE.PlaneGeometry(this.width, this.height, 1, 1);\r\n        geometry.rotateX(-Math.PI / 2); // Make it horizontal\r\n        \r\n        // Create water material with custom shader\r\n        this.waterMaterial = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                time: { value: 0 },\r\n                waterTexture: { value: null },\r\n                sunDirection: { value: new THREE.Vector3(0.5, 0.5, 0) },\r\n                camera: { value: new THREE.Vector3() },\r\n                waterColor: { value: new THREE.Color(0x0099ff) },\r\n            },\r\n            vertexShader: this.getWaterVertexShader(),\r\n            fragmentShader: this.getWaterFragmentShader(),\r\n            transparent: true,\r\n            side: THREE.DoubleSide,\r\n        });\r\n        \r\n        // Create the mesh and add it to the scene\r\n        this.waterMesh = new THREE.Mesh(geometry, this.waterMaterial);\r\n        this.waterMesh.receiveShadow = true;\r\n        if (this.scene) {\r\n            this.scene.add(this.waterMesh);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Set up textures and framebuffers for water simulation\r\n     */\r\n    setupSimulation() {\r\n        const gl = this.getGLContext();\r\n        if (!gl) return;\r\n        \r\n        // Determine texture type based on available extensions\r\n        const textureType = this.hasFloatTextures ? THREE.FloatType : \r\n                           (this.hasHalfFloatTextures ? THREE.HalfFloatType : THREE.UnsignedByteType);\r\n        const filter = (this.hasFloatTextureLinear || this.hasHalfFloatTextureLinear) ? \r\n                      THREE.LinearFilter : THREE.NearestFilter;\r\n        \r\n        // Create textures for water simulation\r\n        this.textureA = new THREE.WebGLRenderTarget(\r\n            this.resolution, \r\n            this.resolution, \r\n            {\r\n                type: textureType,\r\n                minFilter: filter,\r\n                magFilter: filter,\r\n                format: THREE.RGBAFormat,\r\n                stencilBuffer: false,\r\n                depthBuffer: false,\r\n            }\r\n        );\r\n        \r\n        this.textureB = this.textureA.clone();\r\n        \r\n        // Initialize the textures with calm water\r\n        this.initializeTextures();\r\n    }\r\n    \r\n    /**\r\n     * Initialize the water textures\r\n     */\r\n    initializeTextures() {\r\n        // Initialize with a flat water surface\r\n        // This would be implemented using a shader to fill the texture with initial values\r\n    }\r\n    \r\n    /**\r\n     * Set up shaders for water simulation\r\n     */\r\n    setupShaders() {\r\n        // Create drop shader (for adding water drops)\r\n        this.dropShader = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                texture: { value: null },\r\n                center: { value: new THREE.Vector2(0, 0) },\r\n                radius: { value: 0.05 },\r\n                strength: { value: 0.5 },\r\n            },\r\n            vertexShader: this.getVertexShader(),\r\n            fragmentShader: this.getDropFragmentShader(),\r\n        });\r\n        \r\n        // Create update shader (for water physics)\r\n        this.updateShader = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                texture: { value: null },\r\n                delta: { value: new THREE.Vector2(1/this.resolution, 1/this.resolution) },\r\n            },\r\n            vertexShader: this.getVertexShader(),\r\n            fragmentShader: this.getUpdateFragmentShader(),\r\n        });\r\n        \r\n        // Create normal shader (for calculating water normals)\r\n        this.normalShader = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                texture: { value: null },\r\n                delta: { value: new THREE.Vector2(1/this.resolution, 1/this.resolution) },\r\n            },\r\n            vertexShader: this.getVertexShader(),\r\n            fragmentShader: this.getNormalFragmentShader(),\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Get the basic vertex shader for the simulation\r\n     */\r\n    getVertexShader() {\r\n        return `\r\n            varying vec2 coord;\r\n            void main() {\r\n                coord = position.xy * 0.5 + 0.5;\r\n                gl_Position = vec4(position.xyz, 1.0);\r\n            }\r\n        `;\r\n    }\r\n    \r\n    /**\r\n     * Get the drop fragment shader\r\n     */\r\n    getDropFragmentShader() {\r\n        return `\r\n            const float PI = 3.141592653589793;\r\n            uniform sampler2D texture;\r\n            uniform vec2 center;\r\n            uniform float radius;\r\n            uniform float strength;\r\n            varying vec2 coord;\r\n            void main() {\r\n                /* get vertex info */\r\n                vec4 info = texture2D(texture, coord);\r\n                \r\n                /* add the drop to the height */\r\n                float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\r\n                drop = 0.5 - cos(drop * PI) * 0.5;\r\n                info.r += drop * strength;\r\n                \r\n                gl_FragColor = info;\r\n            }\r\n        `;\r\n    }\r\n    \r\n    /**\r\n     * Get the update fragment shader\r\n     */\r\n    getUpdateFragmentShader() {\r\n        return `\r\n            uniform sampler2D texture;\r\n            uniform vec2 delta;\r\n            varying vec2 coord;\r\n            void main() {\r\n                /* get vertex info */\r\n                vec4 info = texture2D(texture, coord);\r\n                \r\n                /* calculate average neighbor height */\r\n                vec2 dx = vec2(delta.x, 0.0);\r\n                vec2 dy = vec2(0.0, delta.y);\r\n                float average = (\r\n                    texture2D(texture, coord - dx).r +\r\n                    texture2D(texture, coord - dy).r +\r\n                    texture2D(texture, coord + dx).r +\r\n                    texture2D(texture, coord + dy).r\r\n                ) * 0.25;\r\n                \r\n                /* change the velocity to move toward the average */\r\n                info.g += (average - info.r) * 2.0;\r\n                \r\n                /* attenuate the velocity a little so waves do not last forever */\r\n                info.g *= 0.995;\r\n                \r\n                /* move the vertex along the velocity */\r\n                info.r += info.g;\r\n                \r\n                gl_FragColor = info;\r\n            }\r\n        `;\r\n    }\r\n    \r\n    /**\r\n     * Get the normal fragment shader\r\n     */\r\n    getNormalFragmentShader() {\r\n        return `\r\n            uniform sampler2D texture;\r\n            uniform vec2 delta;\r\n            varying vec2 coord;\r\n            void main() {\r\n                /* get vertex info */\r\n                vec4 info = texture2D(texture, coord);\r\n                \r\n                /* update the normal */\r\n                vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\r\n                vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\r\n                info.ba = normalize(cross(dy, dx)).xz;\r\n                \r\n                gl_FragColor = info;\r\n            }\r\n        `;\r\n    }\r\n    \r\n    /**\r\n     * Get the water vertex shader\r\n     */\r\n    getWaterVertexShader() {\r\n        return `\r\n            uniform sampler2D waterTexture;\r\n            uniform float time;\r\n            varying vec2 vUv;\r\n            varying vec3 vPosition;\r\n            varying vec3 vNormal;\r\n            \r\n            void main() {\r\n                vUv = uv;\r\n                \r\n                // Sample water height from texture\r\n                vec4 waterInfo = texture2D(waterTexture, uv);\r\n                \r\n                // Get vertex position with water height\r\n                vec3 pos = position;\r\n                pos.y += waterInfo.r * 5.0; // Scale the wave height\r\n                \r\n                // Get water normal from texture\r\n                vNormal = normalize(vec3(waterInfo.b, 1.0, waterInfo.a));\r\n                \r\n                // Transform position to world space\r\n                vPosition = (modelMatrix * vec4(pos, 1.0)).xyz;\r\n                \r\n                // Standard transformation\r\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n            }\r\n        `;\r\n    }\r\n    \r\n    /**\r\n     * Get the water fragment shader\r\n     */\r\n    getWaterFragmentShader() {\r\n        return `\r\n            uniform vec3 waterColor;\r\n            uniform vec3 sunDirection;\r\n            uniform vec3 camera;\r\n            varying vec2 vUv;\r\n            varying vec3 vPosition;\r\n            varying vec3 vNormal;\r\n            \r\n            void main() {\r\n                // Calculate view direction\r\n                vec3 viewDirection = normalize(camera - vPosition);\r\n                \r\n                // Calculate reflection\r\n                float fresnel = 0.02 + 0.98 * pow(1.0 - dot(viewDirection, vNormal), 5.0);\r\n                \r\n                // Calculate sun reflection\r\n                float sunReflection = pow(max(0.0, dot(reflect(-viewDirection, vNormal), sunDirection)), 100.0);\r\n                \r\n                // Final color\r\n                vec3 color = waterColor;\r\n                color += sunReflection * 0.5;\r\n                \r\n                gl_FragColor = vec4(color, 0.8);\r\n            }\r\n        `;\r\n    }\r\n    \r\n    /**\r\n     * Add a water drop at the specified position\r\n     * @param {number} x - Normalized x coordinate (0-1)\r\n     * @param {number} y - Normalized y coordinate (0-1)\r\n     * @param {number} radius - Radius of the drop\r\n     * @param {number} strength - Strength of the drop\r\n     */\r\n    addDrop(x, y, radius, strength) {\r\n        // Swap textures to update the simulation\r\n        let temp = this.textureA;\r\n        this.textureA = this.textureB;\r\n        this.textureB = temp;\r\n        \r\n        // Render drop effect to texture\r\n        const renderTarget = this.renderer.getRenderTarget();\r\n        this.renderer.setRenderTarget(this.textureA);\r\n        \r\n        this.dropShader.uniforms.texture.value = this.textureB.texture;\r\n        this.dropShader.uniforms.center.value.set(x, y);\r\n        this.dropShader.uniforms.radius.value = radius;\r\n        this.dropShader.uniforms.strength.value = strength;\r\n        \r\n        this.renderQuad(this.dropShader);\r\n        \r\n        this.renderer.setRenderTarget(renderTarget);\r\n    }\r\n    \r\n    /**\r\n     * Update the water simulation\r\n     */\r\n    stepSimulation() {\r\n        // Swap textures to update the simulation\r\n        let temp = this.textureA;\r\n        this.textureA = this.textureB;\r\n        this.textureB = temp;\r\n        \r\n        // Render update effect to texture\r\n        const renderTarget = this.renderer.getRenderTarget();\r\n        this.renderer.setRenderTarget(this.textureA);\r\n        \r\n        this.updateShader.uniforms.texture.value = this.textureB.texture;\r\n        this.renderQuad(this.updateShader);\r\n        \r\n        this.renderer.setRenderTarget(renderTarget);\r\n    }\r\n    \r\n    /**\r\n     * Update water normals\r\n     */\r\n    updateNormals() {\r\n        // Swap textures to update the simulation\r\n        let temp = this.textureA;\r\n        this.textureA = this.textureB;\r\n        this.textureB = temp;\r\n        \r\n        // Render normal calculation to texture\r\n        const renderTarget = this.renderer.getRenderTarget();\r\n        this.renderer.setRenderTarget(this.textureA);\r\n        \r\n        this.normalShader.uniforms.texture.value = this.textureB.texture;\r\n        this.renderQuad(this.normalShader);\r\n        \r\n        this.renderer.setRenderTarget(renderTarget);\r\n    }\r\n    \r\n    /**\r\n     * Render a quad with the given shader material\r\n     * @param {THREE.ShaderMaterial} material - Shader material to use\r\n     */\r\n    renderQuad(material) {\r\n        if (!this.quad) {\r\n            this.quad = new THREE.Mesh(\r\n                new THREE.PlaneGeometry(2, 2),\r\n                material\r\n            );\r\n            this.quadScene = new THREE.Scene();\r\n            this.quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);\r\n            this.quadScene.add(this.quad);\r\n        } else {\r\n            this.quad.material = material;\r\n        }\r\n        \r\n        this.renderer.render(this.quadScene, this.quadCamera);\r\n    }\r\n    \r\n    /**\r\n     * Update the water simulation and rendering\r\n     * @param {number} deltaTime - Time step in seconds\r\n     * @param {THREE.Camera} camera - Camera for reflections\r\n     */\r\n    update(deltaTime, camera) {\r\n        // Update water physics\r\n        this.stepSimulation();\r\n        this.updateNormals();\r\n        \r\n        // Update water material uniforms\r\n        if (this.waterMaterial && camera) {\r\n            this.waterMaterial.uniforms.time.value += deltaTime;\r\n            this.waterMaterial.uniforms.waterTexture.value = this.textureA.texture;\r\n            this.waterMaterial.uniforms.camera.value.copy(camera.position);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Dispose of water resources\r\n     */\r\n    dispose() {\r\n        if (this.textureA) this.textureA.dispose();\r\n        if (this.textureB) this.textureB.dispose();\r\n        \r\n        if (this.waterMesh) {\r\n            if (this.scene) this.scene.remove(this.waterMesh);\r\n            this.waterMesh.geometry.dispose();\r\n            this.waterMesh.material.dispose();\r\n        }\r\n        \r\n        if (this.quad) {\r\n            this.quad.geometry.dispose();\r\n            this.quad.material.dispose();\r\n            this.quadScene.remove(this.quad);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Get the water height at a specific position in world space\r\n     * @param {THREE.Vector3} position - Position to get height at\r\n     * @returns {number} Water height at the position\r\n     */\r\n    getHeightAt(position) {\r\n        // Convert world position to normalized UV coordinates\r\n        const halfWidth = this.width / 2;\r\n        const halfHeight = this.height / 2;\r\n        \r\n        // Convert world XZ position to UV (0-1) coordinates\r\n        const u = (position.x + halfWidth) / this.width;\r\n        const v = (position.z + halfHeight) / this.height;\r\n        \r\n        // Check if position is within water bounds\r\n        if (u < 0 || u > 1 || v < 0 || v > 1) {\r\n            return 0; // Return 0 for positions outside the water\r\n        }\r\n        \r\n        // If we have valid water texture data, sample it\r\n        if (this.textureA && this.textureA.texture) {\r\n            // Create a temporary canvas to read pixel data\r\n            if (!this.canvas) {\r\n                this.canvas = document.createElement('canvas');\r\n                this.canvas.width = 1;\r\n                this.canvas.height = 1;\r\n                this.context = this.canvas.getContext('2d');\r\n            }\r\n            \r\n            // This would ideally use a WebGL shader to sample the texture\r\n            // For simplicity, we'll approximate with a sine wave based on the position\r\n            const time = Date.now() / 1000;\r\n            const waveHeight = Math.sin(position.x * 0.02 + time) * 0.5 + \r\n                               Math.cos(position.z * 0.03 + time * 0.7) * 0.3;\r\n            \r\n            return waveHeight;\r\n        }\r\n        \r\n        return 0;\r\n    }\r\n}\r\n\r\nexport default Water; ","__webpack_require__.h = () => (\"1f749f303812f786bb45\")"],"names":[],"sourceRoot":""}