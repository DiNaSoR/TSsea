{"version":3,"file":"main.e55c58063fb922a3a7fd.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAC2C;AACN;AACA;AACR;AACO,CAAC;AACwC;;AAE7E;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,mBAAmB;AAClC,eAAe,SAAS;AACxB;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,+BAA+B;AAC/B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAQ;AACpC;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B,uDAAW;AAC1C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAQ;AACpC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gDAAI;AAC7B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iBAAiB;AAC5E;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,iBAAiB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,wCAAwC,gDAAI;AAC5C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4BAA4B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wBAAwB,KAAK,iBAAiB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iDAAgB,sBAAsB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mCAAmC;AACxF;AACA;AACA;AACA,iDAAiD,iCAAiC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,gBAAgB;AAC3E,cAAc;AACd;AACA;AACA,2DAA2D,gBAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,mDAAmD,sBAAsB,GAAG,cAAc;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iDAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,4BAA4B,GAAG,0BAA0B,SAAS,2BAA2B,GAAG,iBAAiB;AACpK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAe,IAAI,EAAC;;;;;;;;UCv3BpB","sources":["webpack://opensail/./src/js/game.js","webpack://opensail/webpack/runtime/getFullHash"],"sourcesContent":["/**\n * Game class to manage the overall game state and coordinate components\n */\nimport Environment from './environment.js';\nimport Renderer from './renderer.js';\nimport Controls from './controls.js';\nimport Boat from './boat.js';\nimport * as Utils from './utils.js'; // Import all utility functions as Utils namespace\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\n\nclass Game {\n    /**\n     * Create a new Game\n     * @param {Object} options - Game configuration options\n     * @param {HTMLCanvasElement} options.canvas - Canvas element for rendering\n     * @param {boolean} options.debug - Enable debug features\n     */\n    constructor(options = {}) {\n        this.canvas = options.canvas;\n        this.debug = options.debug || false;\n        \n        // Game objects\n        this.renderer = null;\n        this.environment = null;\n        this.boats = new Map(); // Map of boat id to boat object\n        this.localBoat = null; // Reference to the player's boat\n        this.controls = null;\n        this.course = null; // Will store race course data\n        \n        // Game state\n        this.state = {\n            isRunning: false,\n            isPaused: false,\n            raceStarted: false,\n            raceFinished: false,\n            raceTime: 0,\n            timeOfDay: 12, // Noon by default\n        };\n        \n        // Game configuration\n        this.config = {\n            boatCount: 1, // Number of boats (default single player)\n            initialPosition: new THREE.Vector3(0, 0, 0),\n            timeScale: 1, // For speeding up or slowing down physics\n        };\n        \n        // Multiplayer settings\n        this.multiplayer = {\n            enabled: false,\n            socket: null,\n            playerId: null,\n            serverUpdateRate: 20, // Hz\n            interpolation: true,\n            playerName: 'Player',\n        };\n        \n        // Initialize components\n        this.init();\n    }\n    \n    /**\n     * Initialize game components\n     */\n    init() {\n        console.log('Initializing game...');\n        \n        // Create renderer\n        this.renderer = new Renderer({\n            canvas: this.canvas,\n            debug: this.debug,\n        });\n        \n        // Create environment\n        this.environment = new Environment({\n            scene: this.renderer.scene,\n        });\n        \n        // Set environment in renderer for time of day effects\n        this.renderer.setEnvironment(this.environment);\n        \n        // Create controls\n        this.controls = new Controls({\n            onControlsChange: (controls) => this.handleControlsChange(controls),\n        });\n        \n        // Set up loading screen\n        this.showLoadingScreen();\n        \n        // Set up menu event listeners\n        this.setupMenuListeners();\n    }\n    \n    /**\n     * Show the loading screen\n     */\n    showLoadingScreen() {\n        const loadingScreen = document.getElementById('loading-screen');\n        const loadingBar = document.getElementById('loading-bar');\n        \n        if (loadingScreen) {\n            loadingScreen.style.display = 'flex';\n        }\n        \n        // Simulate loading progress\n        let progress = 0;\n        const loadingInterval = setInterval(() => {\n            progress += 5;\n            if (loadingBar) {\n                loadingBar.style.width = `${progress}%`;\n            }\n            \n            if (progress >= 100) {\n                clearInterval(loadingInterval);\n                // Show menu after loading\n                this.hideLoadingScreen();\n                this.showMenu();\n            }\n        }, 100);\n    }\n    \n    /**\n     * Hide the loading screen\n     */\n    hideLoadingScreen() {\n        const loadingScreen = document.getElementById('loading-screen');\n        if (loadingScreen) {\n            loadingScreen.style.display = 'none';\n        }\n    }\n    \n    /**\n     * Show the game menu\n     */\n    showMenu() {\n        const menu = document.getElementById('game-menu');\n        if (menu) {\n            menu.style.display = 'flex';\n        }\n    }\n    \n    /**\n     * Hide the game menu\n     */\n    hideMenu() {\n        const menu = document.getElementById('game-menu');\n        if (menu) {\n            menu.style.display = 'none';\n        }\n    }\n    \n    /**\n     * Set up menu button listeners\n     */\n    setupMenuListeners() {\n        const startButton = document.getElementById('start-game');\n        if (startButton) {\n            startButton.addEventListener('click', () => {\n                this.multiplayer.enabled = false;\n                this.hideMenu();\n                this.startSinglePlayer();\n            });\n        }\n        \n        const joinButton = document.getElementById('join-game');\n        if (joinButton) {\n            joinButton.addEventListener('click', () => {\n                this.multiplayer.enabled = true;\n                this.hideMenu();\n                this.startMultiplayer();\n            });\n        }\n        \n        // Update player name when input changes\n        const playerNameInput = document.getElementById('player-name');\n        if (playerNameInput) {\n            playerNameInput.addEventListener('input', (e) => {\n                this.multiplayer.playerName = e.target.value || 'Player';\n            });\n        }\n    }\n    \n    /**\n     * Start a single player game\n     */\n    startSinglePlayer() {\n        console.log('Starting single player game...');\n        \n        // Create a boat for the player\n        this.createLocalBoat();\n        \n        // Set up camera in orbit mode\n        this.setCameraView('orbit');\n        \n        // Set up a simple race course\n        this.setupRaceCourse();\n        \n        // Start the game loop\n        this.start();\n    }\n    \n    /**\n     * Start a multiplayer game\n     */\n    startMultiplayer() {\n        console.log('Starting multiplayer game...');\n        \n        // Connect to the server\n        this.connectToServer();\n        \n        // The rest will be handled by the server connection\n    }\n    \n    /**\n     * Create the local player's boat\n     */\n    createLocalBoat() {\n        const boat = new Boat({\n            id: 'local_player',\n            playerName: this.multiplayer.playerName,\n            position: this.config.initialPosition.clone(),\n            orientation: new THREE.Quaternion(),\n            scene: this.renderer.scene,\n        });\n        \n        this.boats.set(boat.id, boat);\n        this.localBoat = boat;\n        \n        // Update UI with player name\n        this.updatePlayerInfo();\n    }\n    \n    /**\n     * Set up a basic race course\n     */\n    setupRaceCourse() {\n        // Define a simple triangular course with start/finish line and buoys\n        this.course = {\n            startPosition: new THREE.Vector3(0, 0, 0),\n            buoys: [\n                { \n                    position: new THREE.Vector3(100, 0, 0),\n                    passed: false,\n                    mesh: null\n                },\n                { \n                    position: new THREE.Vector3(50, 0, 100),\n                    passed: false,\n                    mesh: null\n                },\n                { \n                    position: new THREE.Vector3(-50, 0, 50),\n                    passed: false,\n                    mesh: null\n                }\n            ],\n            finishPosition: new THREE.Vector3(0, 0, 0),\n            currentBuoy: 0,\n            laps: 1,\n            currentLap: 0,\n        };\n        \n        // Create visual markers for the course\n        this.createCourseMarkers();\n    }\n    \n    /**\n     * Create visual markers for the race course\n     */\n    createCourseMarkers() {\n        // Create buoys\n        const buoyGeometry = new THREE.SphereGeometry(2, 16, 16);\n        const buoyMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });\n        \n        this.course.buoys.forEach((buoy, index) => {\n            const buoyMesh = new THREE.Mesh(buoyGeometry, buoyMaterial);\n            buoyMesh.position.copy(buoy.position);\n            buoyMesh.position.y = 2; // Raise above water\n            this.renderer.scene.add(buoyMesh);\n            \n            // Store reference to the mesh\n            buoy.mesh = buoyMesh;\n            \n            // Add a pole\n            const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 8);\n            const poleMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });\n            const pole = new THREE.Mesh(poleGeometry, poleMaterial);\n            pole.position.set(0, -1.5, 0);\n            buoyMesh.add(pole);\n            \n            // Add buoy number\n            // In a real implementation, we would add a sprite with text\n        });\n        \n        // Create start/finish line\n        const lineGeometry = new THREE.BoxGeometry(20, 0.5, 2);\n        const lineMaterial = new THREE.MeshPhongMaterial({ \n            color: 0xffffff,\n            transparent: true,\n            opacity: 0.7,\n        });\n        const startLine = new THREE.Mesh(lineGeometry, lineMaterial);\n        startLine.position.copy(this.course.startPosition);\n        startLine.position.y = 0.3; // Slightly above water\n        this.renderer.scene.add(startLine);\n    }\n    \n    /**\n     * Connect to multiplayer server\n     */\n    connectToServer() {\n        // Create a socket.io connection using our socketConnect helper\n        this.multiplayer.socket = window.socketConnect();\n        \n        // Set up socket event handlers\n        this.setupSocketHandlers();\n    }\n    \n    /**\n     * Set up socket.io event handlers\n     */\n    setupSocketHandlers() {\n        const socket = this.multiplayer.socket;\n        \n        // Handle connection\n        socket.on('connect', () => {\n            console.log('Connected to server');\n            \n            // Send player info to server\n            socket.emit('player_join', {\n                name: this.multiplayer.playerName\n            });\n        });\n        \n        // Handle player ID assignment\n        socket.on('player_id', (data) => {\n            console.log('Received player ID:', data.id);\n            this.multiplayer.playerId = data.id;\n            \n            // Create local boat with assigned ID\n            this.createLocalBoat();\n            \n            // Set up camera to follow the player's boat\n            this.renderer.setupBoatCamera(this.localBoat);\n        });\n        \n        // Handle game state update from server\n        socket.on('game_state', (data) => {\n            // Update game state\n            this.state.raceStarted = data.raceStarted;\n            this.state.raceFinished = data.raceFinished;\n            this.state.raceTime = data.raceTime;\n            \n            // Update environment\n            if (data.environment) {\n                this.environment.handleServerUpdate(data.environment);\n            }\n            \n            // Update boats\n            if (data.boats) {\n                this.updateBoatsFromServer(data.boats);\n            }\n            \n            // Check if the game is now running\n            if (!this.state.isRunning && data.raceStarted) {\n                this.start();\n            }\n        });\n        \n        // Handle disconnection\n        socket.on('disconnect', () => {\n            console.log('Disconnected from server');\n            \n            // Handle disconnection (e.g., show a message, return to menu)\n            this.stop();\n            this.showMenu();\n        });\n    }\n    \n    /**\n     * Update boats from server data\n     * @param {Array} boatData - Array of boat states from server\n     */\n    updateBoatsFromServer(boatData) {\n        // Process each boat in the server data\n        boatData.forEach(serverBoat => {\n            const boatId = serverBoat.id;\n            \n            if (boatId === this.multiplayer.playerId) {\n                // This is our boat - only update if significant drift\n                // Client prediction would normally handle our movement\n                if (this.localBoat) {\n                    // For now, just apply server state - replace with proper reconciliation later\n                    this.localBoat.handleServerUpdate(serverBoat);\n                }\n            } else {\n                // This is another player's boat\n                if (this.boats.has(boatId)) {\n                    // Update existing boat\n                    this.boats.get(boatId).handleServerUpdate(serverBoat);\n                } else {\n                    // Create new boat\n                    const newBoat = new Boat({\n                        id: boatId,\n                        playerName: serverBoat.playerName || 'Other Player',\n                        scene: this.renderer.scene,\n                    });\n                    \n                    // Apply server state\n                    newBoat.handleServerUpdate(serverBoat);\n                    \n                    // Add to boats collection\n                    this.boats.set(boatId, newBoat);\n                }\n            }\n        });\n        \n        // Check for boats that no longer exist on server (player left)\n        this.boats.forEach((boat, id) => {\n            const stillExists = boatData.some(serverBoat => serverBoat.id === id);\n            \n            if (!stillExists && id !== this.multiplayer.playerId) {\n                // Remove boat that's no longer on the server\n                boat.dispose();\n                this.boats.delete(id);\n            }\n        });\n    }\n    \n    /**\n     * Start the game\n     */\n    start() {\n        if (this.state.isRunning) return;\n        \n        console.log('Starting game...');\n        \n        // Set game state\n        this.state.isRunning = true;\n        this.state.isPaused = false;\n        \n        // Start the renderer\n        this.renderer.start((deltaTime) => this.update(deltaTime));\n        \n        // Hide UI elements\n        this.hideMenu();\n        \n        // Update UI\n        this.updateUI();\n    }\n    \n    /**\n     * Update game state\n     * @param {number} deltaTime - Time since last update in seconds\n     */\n    update(deltaTime) {\n        if (!this.state.isRunning || this.state.isPaused) return;\n        \n        // Scale delta time to limit physics issues on slow framerates\n        const scaledDeltaTime = Math.min(deltaTime, 0.033);\n        \n        // Update controls\n        this.controls.update(scaledDeltaTime);\n        \n        // Update environment\n        const environmentState = this.environment.update(scaledDeltaTime);\n        \n        // Update all boats\n        this.boats.forEach(boat => {\n            boat.update(environmentState, scaledDeltaTime);\n        });\n        \n        // Check boat position against course markers\n        if (this.localBoat && this.course) {\n            this.checkCourseProgress();\n        }\n        \n        // Update camera based on view\n        if (this.localBoat && this.renderer) {\n            switch(this.cameraView) {\n                case 'first-person':\n                    this.updateFirstPersonCamera();\n                    break;\n                    \n                case '3rd-person':\n                    this.update3rdPersonCamera();\n                    break;\n                    \n                case 'orbit':\n                    // Orbit controls are updated in the renderer animation loop\n                    // We just need to ensure the target is set correctly\n                    if (this.renderer.controls) {\n                        this.renderer.controls.target.copy(this.localBoat.position);\n                    }\n                    break;\n                    \n                // top-down has static camera, no updates needed\n            }\n        }\n        \n        // Update UI\n        this.updateUI();\n        \n        // Send updates to server if in multiplayer mode\n        if (this.multiplayer.enabled && this.multiplayer.socket && this.localBoat) {\n            this.sendUpdatesToServer();\n        }\n        \n        // Update race time if race started\n        if (this.state.raceStarted && !this.state.raceFinished) {\n            this.state.raceTime += scaledDeltaTime;\n        }\n    }\n    \n    /**\n     * Check the player's progress on the race course\n     */\n    checkCourseProgress() {\n        if (!this.localBoat || !this.course) return;\n        \n        // Get the next buoy to pass\n        const nextBuoy = this.course.buoys[this.course.currentBuoy];\n        \n        // Check distance to next buoy\n        const distance = this.localBoat.position.distanceTo(nextBuoy.position);\n        \n        // If close enough to the buoy, mark it as passed\n        if (distance < 10 && !nextBuoy.passed) {\n            console.log(`Passed buoy ${this.course.currentBuoy + 1}`);\n            nextBuoy.passed = true;\n            \n            // Change buoy color to green to indicate it's been passed\n            if (nextBuoy.mesh) {\n                nextBuoy.mesh.material.color.set(0x00ff00);\n            }\n            \n            // Move to next buoy\n            this.course.currentBuoy = (this.course.currentBuoy + 1) % this.course.buoys.length;\n            \n            // If we've completed a lap\n            if (this.course.currentBuoy === 0) {\n                this.course.currentLap++;\n                console.log(`Completed lap ${this.course.currentLap} of ${this.course.laps}`);\n                \n                // Reset buoys for next lap\n                if (this.course.currentLap < this.course.laps) {\n                    this.course.buoys.forEach(buoy => {\n                        buoy.passed = false;\n                        if (buoy.mesh) {\n                            buoy.mesh.material.color.set(0xff0000);\n                        }\n                    });\n                } else {\n                    // Race finished\n                    this.finishRace();\n                }\n            }\n            \n            // Update UI\n            this.updateCourseInfo();\n        }\n    }\n    \n    /**\n     * Handle race finish\n     */\n    finishRace() {\n        console.log('Race finished!');\n        this.state.raceFinished = true;\n        \n        // Show race results\n        this.showRaceResults();\n    }\n    \n    /**\n     * Show race results\n     */\n    showRaceResults() {\n        // In a real implementation, this would display a UI with race results\n        alert(`Race Finished! Time: ${Utils.formatTime(this.state.raceTime)}`);\n    }\n    \n    /**\n     * Send local boat updates to the server\n     */\n    sendUpdatesToServer() {\n        if (!this.multiplayer.socket || !this.localBoat) return;\n        \n        // Get boat state\n        const boatState = this.localBoat.update(\n            this.environment.update(0), // Get current environment without updating\n            0 // Don't update physics again\n        );\n        \n        // Send boat state to server\n        this.multiplayer.socket.emit('boat_update', boatState);\n    }\n    \n    /**\n     * Handle controls changes from the Controls class\n     * @param {Object} controls - Current control state\n     */\n    handleControlsChange(controls) {\n        // Apply controls to local boat\n        if (this.localBoat) {\n            this.localBoat.rudderAngle = controls.rudderAngle;\n            this.localBoat.sailAngle = controls.sailAngle;\n            this.localBoat.throttle = controls.throttle;\n        }\n        \n        // We no longer need to handle camera view changes since we only use orbit mode\n    }\n    \n    /**\n     * Set camera view mode\n     * @param {string} view - Camera view mode ('orbit', 'first-person', 'top-down', '3rd-person')\n     */\n    setCameraView(view) {\n        if (!this.renderer) return;\n        \n        // Store the current view\n        this.cameraView = view;\n        \n        // Prevent the context menu on right-click for better camera control\n        // Apply this globally regardless of camera mode\n        this.renderer.canvas.addEventListener('contextmenu', (e) => e.preventDefault());\n        \n        switch(view) {\n            case 'top-down':\n                // Clean up any existing controls\n                if (this.renderer.controls) {\n                    this.renderer.controls.dispose();\n                    this.renderer.controls = null;\n                }\n                \n                // Set the camera position high above\n                this.renderer.camera.position.set(0, 100, 0);\n                this.renderer.camera.lookAt(0, 0, 0);\n                break;\n                \n            case 'first-person':\n                // Clean up any existing controls\n                if (this.renderer.controls) {\n                    this.renderer.controls.dispose();\n                    this.renderer.controls = null;\n                }\n                \n                this.renderer.setupBoatCamera(this.localBoat);\n                this.renderer.followBoatMode = true;\n                break;\n\n            case 'orbit':\n                // Set up OrbitControls centered on the boat\n                if (this.renderer.controls) {\n                    this.renderer.controls.dispose();\n                }\n                \n                // Set the boat as follow target to ensure camera follows it\n                this.renderer.setupControls();\n                this.renderer.followBoat = this.localBoat;\n                this.renderer.followBoatMode = true;\n                break;\n                \n            case '3rd-person':\n                // Clean up any existing controls\n                if (this.renderer.controls) {\n                    this.renderer.controls.dispose();\n                    this.renderer.controls = null;\n                }\n                \n                this.renderer.followBoat = this.localBoat;\n                this.renderer.followBoatMode = true;\n                break;\n        }\n    }\n    \n    /**\n     * Update the 3rd person camera position\n     */\n    update3rdPersonCamera() {\n        if (!this.localBoat || !this.renderer) return;\n        \n        const boat = this.localBoat;\n        const camera = this.renderer.camera;\n        \n        // Get boat's position and direction\n        const boatPosition = boat.position.clone();\n        const boatDirection = new THREE.Vector3(0, 0, 1).applyQuaternion(boat.orientation);\n        \n        // Calculate camera position: behind and above the boat\n        // Adjust these values to get the desired camera position\n        const distanceBehind = 10; // Distance behind the boat\n        const heightAbove = 5;    // Height above the boat\n        \n        // Calculate the position behind the boat using its direction\n        const cameraOffset = boatDirection.clone().multiplyScalar(-distanceBehind);\n        cameraOffset.y = heightAbove;\n        \n        // Set camera position\n        const targetCameraPosition = boatPosition.clone().add(cameraOffset);\n        \n        // Smoothly interpolate current camera position to target position\n        camera.position.lerp(targetCameraPosition, 0.05);\n        \n        // Look at a point slightly ahead of the boat\n        const lookAtOffset = boatDirection.clone().multiplyScalar(5);\n        const lookAtPosition = boatPosition.clone().add(lookAtOffset);\n        lookAtPosition.y += 1; // Look slightly above the boat\n        \n        camera.lookAt(lookAtPosition);\n    }\n    \n    /**\n     * Update the UI with current game state\n     */\n    updateUI() {\n        this.updateWindIndicator();\n        this.updateBoatInfo();\n        this.updateRaceInfo();\n    }\n    \n    /**\n     * Update the wind indicator in the UI\n     */\n    updateWindIndicator() {\n        const windArrow = document.getElementById('wind-arrow');\n        const windSpeed = document.getElementById('wind-speed');\n        \n        if (windArrow && this.environment) {\n            // Rotate arrow to point in wind direction\n            windArrow.style.transform = `rotate(${this.environment.wind.direction}deg)`;\n        }\n        \n        if (windSpeed && this.environment) {\n            // Display wind speed in knots (1 m/s ≈ 1.94 knots)\n            const knotsSpeed = (this.environment.wind.speed * 1.94).toFixed(1);\n            windSpeed.textContent = `${knotsSpeed} knots`;\n        }\n    }\n    \n    /**\n     * Update boat information in the UI\n     */\n    updateBoatInfo() {\n        const headingElement = document.getElementById('heading');\n        const speedElement = document.getElementById('speed');\n        const throttleElement = document.getElementById('throttle');\n        const rudderElement = document.getElementById('rudder');\n        \n        if (headingElement && this.localBoat) {\n            headingElement.textContent = `Heading: ${Math.round(this.localBoat.heading)}°`;\n        }\n        \n        if (speedElement && this.localBoat) {\n            speedElement.textContent = `Speed: ${this.localBoat.speed.toFixed(1)} knots`;\n        }\n        \n        if (throttleElement && this.localBoat) {\n            // Convert throttle from -0.5 to 1 range to percentage display\n            let throttlePercent;\n            if (this.localBoat.throttle >= 0) {\n                // Forward throttle: 0-100%\n                throttlePercent = Math.round(this.localBoat.throttle * 100);\n                throttleElement.textContent = `Throttle: ${throttlePercent}% Forward`;\n            } else {\n                // Reverse throttle: 0-50%\n                throttlePercent = Math.round(Math.abs(this.localBoat.throttle) * 100);\n                throttleElement.textContent = `Throttle: ${throttlePercent}% Reverse`;\n            }\n        }\n        \n        if (rudderElement && this.localBoat) {\n            const rudderAngle = Math.round(this.localBoat.rudderAngle);\n            let turnDirection = \"\";\n            \n            if (rudderAngle < 0) {\n                turnDirection = \" Left\";\n            } else if (rudderAngle > 0) {\n                turnDirection = \" Right\";\n            }\n            \n            rudderElement.textContent = `Rudder: ${Math.abs(rudderAngle)}°${turnDirection}`;\n        }\n    }\n    \n    /**\n     * Update race information in the UI\n     */\n    updateRaceInfo() {\n        const positionElement = document.getElementById('position');\n        const timerElement = document.getElementById('timer');\n        \n        if (positionElement) {\n            // In multiplayer, this would show race position\n            positionElement.textContent = 'Position: 1/1';\n        }\n        \n        if (timerElement) {\n            timerElement.textContent = Utils.formatTime(this.state.raceTime);\n        }\n    }\n    \n    /**\n     * Update course information in the UI\n     */\n    updateCourseInfo() {\n        const positionElement = document.getElementById('position');\n        \n        if (positionElement && this.course) {\n            positionElement.textContent = `Buoy: ${this.course.currentBuoy + 1}/${this.course.buoys.length} - Lap: ${this.course.currentLap + 1}/${this.course.laps}`;\n        }\n    }\n    \n    /**\n     * Update player information in the UI\n     */\n    updatePlayerInfo() {\n        // In a real implementation, this would update player-specific UI elements\n    }\n    \n    /**\n     * Stop the game\n     */\n    stop() {\n        if (!this.state.isRunning) return;\n        \n        console.log('Stopping game...');\n        \n        // Stop the renderer\n        this.renderer.stop();\n        \n        // Set game state\n        this.state.isRunning = false;\n        \n        // Disconnect multiplayer if active\n        if (this.multiplayer.enabled && this.multiplayer.socket) {\n            this.multiplayer.socket.disconnect();\n        }\n    }\n    \n    /**\n     * Pause the game\n     */\n    pause() {\n        if (!this.state.isRunning || this.state.isPaused) return;\n        \n        console.log('Pausing game...');\n        this.state.isPaused = true;\n    }\n    \n    /**\n     * Resume the game\n     */\n    resume() {\n        if (!this.state.isRunning || !this.state.isPaused) return;\n        \n        console.log('Resuming game...');\n        this.state.isPaused = false;\n    }\n    \n    /**\n     * Clean up resources\n     */\n    dispose() {\n        this.stop();\n        \n        // Clean up all boats\n        this.boats.forEach(boat => boat.dispose());\n        this.boats.clear();\n        \n        // Clean up environment\n        if (this.environment) {\n            this.environment.dispose();\n        }\n        \n        // Clean up renderer\n        if (this.renderer) {\n            this.renderer.dispose();\n        }\n        \n        // Clean up controls\n        if (this.controls) {\n            this.controls.dispose();\n        }\n    }\n}\n\n// Export the Game class for use in other modules\nexport default Game; ","__webpack_require__.h = () => (\"e8c45b95efd76bb95b0d\")"],"names":[],"sourceRoot":""}