{"version":3,"file":"main.68560b53f7947241d443.hot-update.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACoC,CAAC;AACN,CAAC;AAChC;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,uCAAuC,kDAAiB;AACxD;AACA,kDAAkD,kDAAiB;AACnE,kDAAkD,kDAAiB;AACnE,2BAA2B,qDAAoB;AAC/C,uBAAuB,kDAAiB;AACxC,0CAA0C,kDAAiB;AAC3D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iDAAK;AAC9B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+CAAc;AAC3C;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,mCAAmC,kDAAiB;AACpD,kCAAkC,qDAAoB;AACtD;AACA;AACA,gCAAgC,kDAAiB;AACjD,8BAA8B,4CAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAiB;AAC1C;AACA,8BAA8B,4CAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAc;AAC7C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,kCAAkC,qDAAoB;AACtD;AACA;AACA;AACA,8BAA8B,4CAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qDAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAc;AACzC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;ACvY3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA,sDAAsD,iBAAiB;AACvE,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC,gCAAgC,aAAa;AAC7C,gCAAgC,uCAAuC;AACvE,0BAA0B,4BAA4B;AACtD,8BAA8B,kCAAkC;AAChE,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC,0BAA0B,gCAAgC;AAC1D,0BAA0B,aAAa;AACvC,4BAA4B,YAAY;AACxC,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC,yBAAyB,gEAAgE;AACzF,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC,yBAAyB,gEAAgE;AACzF,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;UCvcrB","sources":["webpack://opensail/./src/js/environment.js","webpack://opensail/./src/js/water.js","webpack://opensail/webpack/runtime/getFullHash"],"sourcesContent":["/**\r\n * Environment class to handle wind and waves simulation\r\n */\r\nimport * as Utils from './utils.js'; // Import all utility functions as Utils namespace\r\nimport Water from './water.js'; // Import our new WebGL Water implementation\r\n\r\nclass Environment {\r\n    /**\r\n     * Create a new Environment\r\n     * @param {Object} options - Environment configuration options\r\n     * @param {THREE.Scene} options.scene - Three.js scene to add environment elements\r\n     */\r\n    constructor(options = {}) {\r\n        this.scene = options.scene;\r\n        \r\n        // Wind properties\r\n        this.wind = {\r\n            direction: 0, // degrees (0 = from north, 90 = from east)\r\n            speed: 5, // m/s\r\n            x: 0, // x component\r\n            y: 0, // y component\r\n            z: 0, // z component\r\n            gustFactor: 0.2, // How much gusts affect wind speed\r\n            changeRate: 0.02 // How quickly wind changes direction/speed\r\n        };\r\n        \r\n        // Update wind vector components\r\n        this.updateWindVector();\r\n        \r\n        // Wave properties\r\n        this.waves = {\r\n            isActive: true,\r\n            amplitude: 0.5, // meters\r\n            frequency: 0.2, // cycles per meter\r\n            direction: 0, // degrees (same as wind initially)\r\n            speed: 1, // wave movement speed\r\n            steepness: 0.5, // wave steepness factor (0-1)\r\n            components: [] // Will store multiple wave components for more realism\r\n        };\r\n        \r\n        // Initialize random wave components for more realistic ocean\r\n        this.initWaveComponents();\r\n        \r\n        // Create water and sky in the scene\r\n        if (this.scene) {\r\n            this.createWater();\r\n            this.createSky();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Initialize multiple wave components for more realistic ocean waves\r\n     */\r\n    initWaveComponents() {\r\n        // Create 5 wave components with varying parameters\r\n        for (let i = 0; i < 5; i++) {\r\n            const directionVariation = Utils.randomRange(-20, 20);\r\n            this.waves.components.push({\r\n                amplitude: this.waves.amplitude * Utils.randomRange(0.2, 1),\r\n                frequency: this.waves.frequency * Utils.randomRange(0.5, 2),\r\n                direction: Utils.normalizeAngle(this.waves.direction + directionVariation),\r\n                phase: Utils.randomRange(0, Math.PI * 2),\r\n                speed: this.waves.speed * Utils.randomRange(0.8, 1.2)\r\n            });\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Create water surface in the scene\r\n     */\r\n    createWater() {\r\n        // Create the new WebGL water simulation\r\n        this.water = new Water({\r\n            scene: this.scene,\r\n            width: 5000,\r\n            height: 5000,\r\n            resolution: 256\r\n        });\r\n        \r\n        // Store reference to the water mesh\r\n        this.waterMesh = this.water.waterMesh;\r\n        \r\n        // Add a simple reflection on the water\r\n        const waterLight = new THREE.DirectionalLight(0xffffbb, 0.5);\r\n        waterLight.position.set(0, 100, 0);\r\n        this.scene.add(waterLight);\r\n        \r\n        // Create some initial water disturbance\r\n        this.createInitialWaves();\r\n    }\r\n    \r\n    /**\r\n     * Create initial wave disturbances\r\n     */\r\n    createInitialWaves() {\r\n        // Add some initial drops to create waves\r\n        for (let i = 0; i < 5; i++) {\r\n            const x = Math.random();\r\n            const y = Math.random();\r\n            const radius = 0.03 + Math.random() * 0.02;\r\n            const strength = 0.5 + Math.random() * 0.5;\r\n            \r\n            this.water.addDrop(x, y, radius, strength);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Create sky in the scene\r\n     */\r\n    createSky() {\r\n        // Simple sky using a large sphere\r\n        const skyGeometry = new THREE.SphereGeometry(2000, 32, 32);\r\n        // Reverse the normals to make them point inward\r\n        skyGeometry.scale(-1, 1, 1); \r\n        \r\n        const skyMaterial = new THREE.MeshBasicMaterial({\r\n            color: 0x87ceeb, // Sky blue\r\n            side: THREE.BackSide\r\n        });\r\n        \r\n        this.skyMesh = new THREE.Mesh(skyGeometry, skyMaterial);\r\n        this.scene.add(this.skyMesh);\r\n    }\r\n    \r\n    /**\r\n     * Update the wind vector components based on direction and speed\r\n     */\r\n    updateWindVector() {\r\n        const directionRad = Utils.degToRad(this.wind.direction);\r\n        this.wind.x = -Math.sin(directionRad) * this.wind.speed;\r\n        this.wind.z = -Math.cos(directionRad) * this.wind.speed;\r\n        this.wind.y = 0; // No vertical wind component\r\n    }\r\n    \r\n    /**\r\n     * Update the environment simulation\r\n     * @param {number} deltaTime - Time step in seconds\r\n     */\r\n    update(deltaTime) {\r\n        this.updateWind(deltaTime);\r\n        this.updateWaves(deltaTime);\r\n        \r\n        // Update water mesh vertices to simulate waves\r\n        this.updateWaterMesh();\r\n        \r\n        // Return environment data for networking/physics\r\n        return {\r\n            wind: {\r\n                direction: this.wind.direction,\r\n                speed: this.wind.speed,\r\n                x: this.wind.x,\r\n                y: this.wind.y,\r\n                z: this.wind.z\r\n            },\r\n            waves: {\r\n                isActive: this.waves.isActive,\r\n                amplitude: this.waves.amplitude,\r\n                frequency: this.waves.frequency,\r\n                direction: this.waves.direction,\r\n                speed: this.waves.speed,\r\n                components: this.waves.components\r\n            }\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Update wind parameters\r\n     * @param {number} deltaTime - Time step in seconds\r\n     */\r\n    updateWind(deltaTime) {\r\n        // Occasionally change wind parameters for realism\r\n        if (Math.random() < this.wind.changeRate * deltaTime) {\r\n            // Gradually shift wind direction\r\n            this.wind.direction += Utils.randomRange(-5, 5);\r\n            this.wind.direction = Utils.normalizeAngle(this.wind.direction);\r\n            \r\n            // Gradually change wind speed\r\n            const speedChange = Utils.randomRange(-0.5, 0.5);\r\n            this.wind.speed = Utils.clamp(this.wind.speed + speedChange, 1, 15);\r\n            \r\n            // Update components\r\n            this.updateWindVector();\r\n            \r\n            // Gradually align wave direction with wind (with some delay)\r\n            this.waves.direction += (this.wind.direction - this.waves.direction) * 0.01;\r\n        }\r\n        \r\n        // Add gusts to wind speed\r\n        if (Math.random() < 0.1 * deltaTime) {\r\n            const gust = Utils.randomRange(-this.wind.gustFactor, this.wind.gustFactor) \r\n                        * this.wind.speed;\r\n            this.wind.speed = Utils.clamp(this.wind.speed + gust, 1, 15);\r\n            this.updateWindVector();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Update wave parameters\r\n     * @param {number} deltaTime - Time step in seconds\r\n     */\r\n    updateWaves(deltaTime) {\r\n        // Gradually adjust wave height based on wind speed\r\n        const targetAmplitude = this.wind.speed * 0.1;\r\n        this.waves.amplitude += (targetAmplitude - this.waves.amplitude) * 0.01;\r\n        \r\n        // Update each wave component\r\n        this.waves.components.forEach(component => {\r\n            // Adjust phase based on speed\r\n            component.phase += component.speed * deltaTime;\r\n            \r\n            // Gradually align with main wave direction (with variation)\r\n            component.direction += (this.waves.direction - component.direction) * 0.01;\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Update water mesh vertices to create wave effect\r\n     */\r\n    updateWaterMesh() {\r\n        // If we're using the new WebGL water, update it\r\n        if (this.water) {\r\n            // Update the WebGL water simulation\r\n            this.water.update(1/60, this.scene.getObjectByProperty('isCamera', true));\r\n            \r\n            // Add occasional drops based on wind speed\r\n            if (Math.random() < 0.05 * (this.wind.speed / 15)) {\r\n                const x = Math.random();\r\n                const y = Math.random();\r\n                const radius = 0.02 + Math.random() * 0.03;\r\n                const strength = 0.3 + Math.random() * 0.7 * (this.wind.speed / 15);\r\n                \r\n                this.water.addDrop(x, y, radius, strength);\r\n            }\r\n            \r\n            return;\r\n        }\r\n        \r\n        // Original water update code (fallback)\r\n        if (!this.waterMesh) return;\r\n        \r\n        const now = Date.now() / 1000;\r\n        const geometry = this.waterMesh.geometry;\r\n        const position = geometry.attributes.position;\r\n        \r\n        // For each vertex in the water geometry\r\n        for (let i = 0; i < position.count; i++) {\r\n            const x = position.getX(i);\r\n            const z = position.getZ(i);\r\n            \r\n            // Calculate height for this vertex\r\n            let height = 0;\r\n            \r\n            // Sum heights from all wave components\r\n            this.waves.components.forEach(wave => {\r\n                const dirRad = Utils.degToRad(wave.direction);\r\n                const dx = x * Math.cos(dirRad) + z * Math.sin(dirRad);\r\n                \r\n                // Simple sine wave\r\n                height += wave.amplitude * \r\n                          Math.sin(dx * wave.frequency + now * wave.speed + wave.phase);\r\n            });\r\n            \r\n            // Set the vertex height\r\n            position.setY(i, height);\r\n        }\r\n        \r\n        // Mark attributes as needing update\r\n        position.needsUpdate = true;\r\n        \r\n        // Update normals for proper lighting\r\n        geometry.computeVertexNormals();\r\n    }\r\n    \r\n    /**\r\n     * Set wind parameters manually (e.g., from server or scenario)\r\n     * @param {Object} windParams - Wind parameters\r\n     */\r\n    setWind(windParams) {\r\n        if (windParams.direction !== undefined) {\r\n            this.wind.direction = Utils.normalizeAngle(windParams.direction);\r\n        }\r\n        \r\n        if (windParams.speed !== undefined) {\r\n            this.wind.speed = Utils.clamp(windParams.speed, 0, 30);\r\n        }\r\n        \r\n        // Update wind vector\r\n        this.updateWindVector();\r\n    }\r\n    \r\n    /**\r\n     * Set wave parameters manually (e.g., from server or scenario)\r\n     * @param {Object} waveParams - Wave parameters\r\n     */\r\n    setWaves(waveParams) {\r\n        if (waveParams.isActive !== undefined) {\r\n            this.waves.isActive = waveParams.isActive;\r\n        }\r\n        \r\n        if (waveParams.amplitude !== undefined) {\r\n            this.waves.amplitude = waveParams.amplitude;\r\n        }\r\n        \r\n        if (waveParams.frequency !== undefined) {\r\n            this.waves.frequency = waveParams.frequency;\r\n        }\r\n        \r\n        if (waveParams.direction !== undefined) {\r\n            this.waves.direction = Utils.normalizeAngle(waveParams.direction);\r\n        }\r\n        \r\n        if (waveParams.speed !== undefined) {\r\n            this.waves.speed = waveParams.speed;\r\n        }\r\n        \r\n        // Update wave components to match new parameters\r\n        if (waveParams.components) {\r\n            this.waves.components = waveParams.components;\r\n        } else {\r\n            // Reinitialize components with the new parameters\r\n            this.waves.components = [];\r\n            this.initWaveComponents();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle server update for environment synchronization\r\n     * @param {Object} environmentState - Environment state from server\r\n     */\r\n    handleServerUpdate(environmentState) {\r\n        if (environmentState.wind) {\r\n            this.setWind(environmentState.wind);\r\n        }\r\n        \r\n        if (environmentState.waves) {\r\n            this.setWaves(environmentState.waves);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Calculate wave height at a specific world position\r\n     * @param {THREE.Vector3} position - World position\r\n     * @param {number} time - Current time\r\n     * @returns {number} Wave height at the position\r\n     */\r\n    getWaveHeight(position, time) {\r\n        if (!this.waves.isActive) return 0;\r\n        \r\n        time = time || Date.now() / 1000;\r\n        let height = 0;\r\n        \r\n        // Sum heights from all wave components\r\n        this.waves.components.forEach(wave => {\r\n            const dirRad = Utils.degToRad(wave.direction);\r\n            const dx = position.x * Math.cos(dirRad) + position.z * Math.sin(dirRad);\r\n            \r\n            height += wave.amplitude * \r\n                      Math.sin(dx * wave.frequency + time * wave.speed + wave.phase);\r\n        });\r\n        \r\n        return height;\r\n    }\r\n    \r\n    /**\r\n     * Dispose of environment resources\r\n     */\r\n    dispose() {\r\n        // Clean up WebGL water\r\n        if (this.water) {\r\n            this.water.dispose();\r\n            this.water = null;\r\n        }\r\n        \r\n        // Original cleanup\r\n        if (this.waterMesh) {\r\n            this.scene.remove(this.waterMesh);\r\n            this.waterMesh.geometry.dispose();\r\n            this.waterMesh.material.dispose();\r\n            this.waterMesh = null;\r\n        }\r\n        \r\n        if (this.skyMesh) {\r\n            this.scene.remove(this.skyMesh);\r\n            this.skyMesh.geometry.dispose();\r\n            this.skyMesh.material.dispose();\r\n            this.skyMesh = null;\r\n        }\r\n    }\r\n}\r\n\r\n// Export the Environment class\r\nexport default Environment; ","/**\r\n * WebGL Water implementation inspired by Evan Wallace's WebGL Water\r\n * https://madebyevan.com/webgl-water/\r\n */\r\n\r\nclass Water {\r\n    /**\r\n     * Create a new WebGL Water simulation\r\n     * @param {Object} options - Water configuration options\r\n     * @param {THREE.Scene} options.scene - Three.js scene to add water to\r\n     * @param {Number} options.width - Width of the water surface\r\n     * @param {Number} options.height - Height of the water surface\r\n     */\r\n    constructor(options = {}) {\r\n        this.scene = options.scene;\r\n        this.width = options.width || 5000;\r\n        this.height = options.height || 5000;\r\n        this.resolution = options.resolution || 256;\r\n        \r\n        // Check if required WebGL extensions are available\r\n        this.checkExtensions();\r\n        \r\n        // Create the water mesh\r\n        this.createWaterMesh();\r\n        \r\n        // Set up textures and framebuffers for water simulation\r\n        this.setupSimulation();\r\n        \r\n        // Set up shaders\r\n        this.setupShaders();\r\n    }\r\n    \r\n    /**\r\n     * Check if required WebGL extensions are available\r\n     */\r\n    checkExtensions() {\r\n        const gl = this.getGLContext();\r\n        if (!gl) return;\r\n        \r\n        // Check for floating point texture support\r\n        this.hasFloatTextures = !!gl.getExtension('OES_texture_float');\r\n        this.hasFloatTextureLinear = !!gl.getExtension('OES_texture_float_linear');\r\n        this.hasHalfFloatTextures = !!gl.getExtension('OES_texture_half_float');\r\n        this.hasHalfFloatTextureLinear = !!gl.getExtension('OES_texture_half_float_linear');\r\n        \r\n        if (!this.hasFloatTextures && !this.hasHalfFloatTextures) {\r\n            console.warn('This water simulation requires floating point texture support.');\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Get the WebGL context\r\n     * @returns {WebGLRenderingContext} The WebGL context\r\n     */\r\n    getGLContext() {\r\n        if (!this.renderer) {\r\n            this.renderer = new THREE.WebGLRenderer({ antialias: true });\r\n            this.renderer.setSize(1, 1); // Minimal size for context\r\n        }\r\n        return this.renderer.getContext();\r\n    }\r\n    \r\n    /**\r\n     * Create the water mesh\r\n     */\r\n    createWaterMesh() {\r\n        // Create a plane for the water surface\r\n        const geometry = new THREE.PlaneGeometry(this.width, this.height, 1, 1);\r\n        geometry.rotateX(-Math.PI / 2); // Make it horizontal\r\n        \r\n        // Create water material with custom shader\r\n        this.waterMaterial = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                time: { value: 0 },\r\n                waterTexture: { value: null },\r\n                sunDirection: { value: new THREE.Vector3(0.5, 0.5, 0) },\r\n                camera: { value: new THREE.Vector3() },\r\n                waterColor: { value: new THREE.Color(0x0099ff) },\r\n            },\r\n            vertexShader: this.getWaterVertexShader(),\r\n            fragmentShader: this.getWaterFragmentShader(),\r\n            transparent: true,\r\n            side: THREE.DoubleSide,\r\n        });\r\n        \r\n        // Create the mesh and add it to the scene\r\n        this.waterMesh = new THREE.Mesh(geometry, this.waterMaterial);\r\n        this.waterMesh.receiveShadow = true;\r\n        if (this.scene) {\r\n            this.scene.add(this.waterMesh);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Set up textures and framebuffers for water simulation\r\n     */\r\n    setupSimulation() {\r\n        const gl = this.getGLContext();\r\n        if (!gl) return;\r\n        \r\n        // Determine texture type based on available extensions\r\n        const textureType = this.hasFloatTextures ? THREE.FloatType : \r\n                           (this.hasHalfFloatTextures ? THREE.HalfFloatType : THREE.UnsignedByteType);\r\n        const filter = (this.hasFloatTextureLinear || this.hasHalfFloatTextureLinear) ? \r\n                      THREE.LinearFilter : THREE.NearestFilter;\r\n        \r\n        // Create textures for water simulation\r\n        this.textureA = new THREE.WebGLRenderTarget(\r\n            this.resolution, \r\n            this.resolution, \r\n            {\r\n                type: textureType,\r\n                minFilter: filter,\r\n                magFilter: filter,\r\n                format: THREE.RGBAFormat,\r\n                stencilBuffer: false,\r\n                depthBuffer: false,\r\n            }\r\n        );\r\n        \r\n        this.textureB = this.textureA.clone();\r\n        \r\n        // Initialize the textures with calm water\r\n        this.initializeTextures();\r\n    }\r\n    \r\n    /**\r\n     * Initialize the water textures\r\n     */\r\n    initializeTextures() {\r\n        // Initialize with a flat water surface\r\n        // This would be implemented using a shader to fill the texture with initial values\r\n    }\r\n    \r\n    /**\r\n     * Set up shaders for water simulation\r\n     */\r\n    setupShaders() {\r\n        // Create drop shader (for adding water drops)\r\n        this.dropShader = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                texture: { value: null },\r\n                center: { value: new THREE.Vector2(0, 0) },\r\n                radius: { value: 0.05 },\r\n                strength: { value: 0.5 },\r\n            },\r\n            vertexShader: this.getVertexShader(),\r\n            fragmentShader: this.getDropFragmentShader(),\r\n        });\r\n        \r\n        // Create update shader (for water physics)\r\n        this.updateShader = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                texture: { value: null },\r\n                delta: { value: new THREE.Vector2(1/this.resolution, 1/this.resolution) },\r\n            },\r\n            vertexShader: this.getVertexShader(),\r\n            fragmentShader: this.getUpdateFragmentShader(),\r\n        });\r\n        \r\n        // Create normal shader (for calculating water normals)\r\n        this.normalShader = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                texture: { value: null },\r\n                delta: { value: new THREE.Vector2(1/this.resolution, 1/this.resolution) },\r\n            },\r\n            vertexShader: this.getVertexShader(),\r\n            fragmentShader: this.getNormalFragmentShader(),\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Get the basic vertex shader for the simulation\r\n     */\r\n    getVertexShader() {\r\n        return `\r\n            varying vec2 coord;\r\n            void main() {\r\n                coord = gl_Vertex.xy * 0.5 + 0.5;\r\n                gl_Position = vec4(gl_Vertex.xyz, 1.0);\r\n            }\r\n        `;\r\n    }\r\n    \r\n    /**\r\n     * Get the drop fragment shader\r\n     */\r\n    getDropFragmentShader() {\r\n        return `\r\n            const float PI = 3.141592653589793;\r\n            uniform sampler2D texture;\r\n            uniform vec2 center;\r\n            uniform float radius;\r\n            uniform float strength;\r\n            varying vec2 coord;\r\n            void main() {\r\n                /* get vertex info */\r\n                vec4 info = texture2D(texture, coord);\r\n                \r\n                /* add the drop to the height */\r\n                float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\r\n                drop = 0.5 - cos(drop * PI) * 0.5;\r\n                info.r += drop * strength;\r\n                \r\n                gl_FragColor = info;\r\n            }\r\n        `;\r\n    }\r\n    \r\n    /**\r\n     * Get the update fragment shader\r\n     */\r\n    getUpdateFragmentShader() {\r\n        return `\r\n            uniform sampler2D texture;\r\n            uniform vec2 delta;\r\n            varying vec2 coord;\r\n            void main() {\r\n                /* get vertex info */\r\n                vec4 info = texture2D(texture, coord);\r\n                \r\n                /* calculate average neighbor height */\r\n                vec2 dx = vec2(delta.x, 0.0);\r\n                vec2 dy = vec2(0.0, delta.y);\r\n                float average = (\r\n                    texture2D(texture, coord - dx).r +\r\n                    texture2D(texture, coord - dy).r +\r\n                    texture2D(texture, coord + dx).r +\r\n                    texture2D(texture, coord + dy).r\r\n                ) * 0.25;\r\n                \r\n                /* change the velocity to move toward the average */\r\n                info.g += (average - info.r) * 2.0;\r\n                \r\n                /* attenuate the velocity a little so waves do not last forever */\r\n                info.g *= 0.995;\r\n                \r\n                /* move the vertex along the velocity */\r\n                info.r += info.g;\r\n                \r\n                gl_FragColor = info;\r\n            }\r\n        `;\r\n    }\r\n    \r\n    /**\r\n     * Get the normal fragment shader\r\n     */\r\n    getNormalFragmentShader() {\r\n        return `\r\n            uniform sampler2D texture;\r\n            uniform vec2 delta;\r\n            varying vec2 coord;\r\n            void main() {\r\n                /* get vertex info */\r\n                vec4 info = texture2D(texture, coord);\r\n                \r\n                /* update the normal */\r\n                vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\r\n                vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\r\n                info.ba = normalize(cross(dy, dx)).xz;\r\n                \r\n                gl_FragColor = info;\r\n            }\r\n        `;\r\n    }\r\n    \r\n    /**\r\n     * Get the water vertex shader\r\n     */\r\n    getWaterVertexShader() {\r\n        return `\r\n            uniform sampler2D waterTexture;\r\n            uniform float time;\r\n            varying vec2 vUv;\r\n            varying vec3 vPosition;\r\n            varying vec3 vNormal;\r\n            \r\n            void main() {\r\n                vUv = uv;\r\n                \r\n                // Sample water height from texture\r\n                vec4 waterInfo = texture2D(waterTexture, uv);\r\n                \r\n                // Get vertex position with water height\r\n                vec3 pos = position;\r\n                pos.y += waterInfo.r * 5.0; // Scale the wave height\r\n                \r\n                // Get water normal from texture\r\n                vNormal = normalize(vec3(waterInfo.b, 1.0, waterInfo.a));\r\n                \r\n                // Transform position to world space\r\n                vPosition = (modelMatrix * vec4(pos, 1.0)).xyz;\r\n                \r\n                // Standard transformation\r\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n            }\r\n        `;\r\n    }\r\n    \r\n    /**\r\n     * Get the water fragment shader\r\n     */\r\n    getWaterFragmentShader() {\r\n        return `\r\n            uniform vec3 waterColor;\r\n            uniform vec3 sunDirection;\r\n            uniform vec3 camera;\r\n            varying vec2 vUv;\r\n            varying vec3 vPosition;\r\n            varying vec3 vNormal;\r\n            \r\n            void main() {\r\n                // Calculate view direction\r\n                vec3 viewDirection = normalize(camera - vPosition);\r\n                \r\n                // Calculate reflection\r\n                float fresnel = 0.02 + 0.98 * pow(1.0 - dot(viewDirection, vNormal), 5.0);\r\n                \r\n                // Calculate sun reflection\r\n                float sunReflection = pow(max(0.0, dot(reflect(-viewDirection, vNormal), sunDirection)), 100.0);\r\n                \r\n                // Final color\r\n                vec3 color = waterColor;\r\n                color += sunReflection * 0.5;\r\n                \r\n                gl_FragColor = vec4(color, 0.8);\r\n            }\r\n        `;\r\n    }\r\n    \r\n    /**\r\n     * Add a water drop at the specified position\r\n     * @param {number} x - Normalized x coordinate (0-1)\r\n     * @param {number} y - Normalized y coordinate (0-1)\r\n     * @param {number} radius - Radius of the drop\r\n     * @param {number} strength - Strength of the drop\r\n     */\r\n    addDrop(x, y, radius, strength) {\r\n        // Swap textures to update the simulation\r\n        let temp = this.textureA;\r\n        this.textureA = this.textureB;\r\n        this.textureB = temp;\r\n        \r\n        // Render drop effect to texture\r\n        const renderTarget = this.renderer.getRenderTarget();\r\n        this.renderer.setRenderTarget(this.textureA);\r\n        \r\n        this.dropShader.uniforms.texture.value = this.textureB.texture;\r\n        this.dropShader.uniforms.center.value.set(x, y);\r\n        this.dropShader.uniforms.radius.value = radius;\r\n        this.dropShader.uniforms.strength.value = strength;\r\n        \r\n        this.renderQuad(this.dropShader);\r\n        \r\n        this.renderer.setRenderTarget(renderTarget);\r\n    }\r\n    \r\n    /**\r\n     * Update the water simulation\r\n     */\r\n    stepSimulation() {\r\n        // Swap textures to update the simulation\r\n        let temp = this.textureA;\r\n        this.textureA = this.textureB;\r\n        this.textureB = temp;\r\n        \r\n        // Render update effect to texture\r\n        const renderTarget = this.renderer.getRenderTarget();\r\n        this.renderer.setRenderTarget(this.textureA);\r\n        \r\n        this.updateShader.uniforms.texture.value = this.textureB.texture;\r\n        this.renderQuad(this.updateShader);\r\n        \r\n        this.renderer.setRenderTarget(renderTarget);\r\n    }\r\n    \r\n    /**\r\n     * Update water normals\r\n     */\r\n    updateNormals() {\r\n        // Swap textures to update the simulation\r\n        let temp = this.textureA;\r\n        this.textureA = this.textureB;\r\n        this.textureB = temp;\r\n        \r\n        // Render normal calculation to texture\r\n        const renderTarget = this.renderer.getRenderTarget();\r\n        this.renderer.setRenderTarget(this.textureA);\r\n        \r\n        this.normalShader.uniforms.texture.value = this.textureB.texture;\r\n        this.renderQuad(this.normalShader);\r\n        \r\n        this.renderer.setRenderTarget(renderTarget);\r\n    }\r\n    \r\n    /**\r\n     * Render a quad with the given shader material\r\n     * @param {THREE.ShaderMaterial} material - Shader material to use\r\n     */\r\n    renderQuad(material) {\r\n        if (!this.quad) {\r\n            this.quad = new THREE.Mesh(\r\n                new THREE.PlaneGeometry(2, 2),\r\n                material\r\n            );\r\n            this.quadScene = new THREE.Scene();\r\n            this.quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);\r\n            this.quadScene.add(this.quad);\r\n        } else {\r\n            this.quad.material = material;\r\n        }\r\n        \r\n        this.renderer.render(this.quadScene, this.quadCamera);\r\n    }\r\n    \r\n    /**\r\n     * Update the water simulation and rendering\r\n     * @param {number} deltaTime - Time step in seconds\r\n     * @param {THREE.Camera} camera - Camera for reflections\r\n     */\r\n    update(deltaTime, camera) {\r\n        // Update water physics\r\n        this.stepSimulation();\r\n        this.updateNormals();\r\n        \r\n        // Update water material uniforms\r\n        if (this.waterMaterial && camera) {\r\n            this.waterMaterial.uniforms.time.value += deltaTime;\r\n            this.waterMaterial.uniforms.waterTexture.value = this.textureA.texture;\r\n            this.waterMaterial.uniforms.camera.value.copy(camera.position);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Dispose of water resources\r\n     */\r\n    dispose() {\r\n        if (this.textureA) this.textureA.dispose();\r\n        if (this.textureB) this.textureB.dispose();\r\n        \r\n        if (this.waterMesh) {\r\n            if (this.scene) this.scene.remove(this.waterMesh);\r\n            this.waterMesh.geometry.dispose();\r\n            this.waterMesh.material.dispose();\r\n        }\r\n        \r\n        if (this.quad) {\r\n            this.quad.geometry.dispose();\r\n            this.quad.material.dispose();\r\n            this.quadScene.remove(this.quad);\r\n        }\r\n    }\r\n}\r\n\r\nexport default Water; ","__webpack_require__.h = () => (\"99554484c32f7daedcd8\")"],"names":[],"sourceRoot":""}