{"version":3,"file":"main.4ce6a26a6375cd030d59.hot-update.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,mBAAmB;AAClC;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,QAAQ,EAAC;;;;;;;;UCpUxB","sources":["webpack://opensail/./src/js/renderer.js","webpack://opensail/webpack/runtime/getFullHash"],"sourcesContent":["/**\r\n * Renderer class to handle Three.js scene and rendering\r\n */\r\nclass Renderer {\r\n    /**\r\n     * Create a new Renderer\r\n     * @param {Object} options - Renderer configuration options\r\n     * @param {HTMLCanvasElement} options.canvas - Canvas element to render to\r\n     */\r\n    constructor(options = {}) {\r\n        this.canvas = options.canvas || document.createElement('canvas');\r\n        this.width = this.canvas.clientWidth;\r\n        this.height = this.canvas.clientHeight;\r\n        \r\n        // Create the Three.js scene\r\n        this.scene = new THREE.Scene();\r\n        \r\n        // Create the camera\r\n        this.camera = new THREE.PerspectiveCamera(\r\n            75, // Field of view\r\n            this.width / this.height, // Aspect ratio\r\n            0.1, // Near plane\r\n            5000 // Far plane\r\n        );\r\n        \r\n        // Set initial camera position\r\n        this.camera.position.set(0, 10, 20);\r\n        this.camera.lookAt(0, 0, 0);\r\n        \r\n        // Create the WebGL renderer\r\n        this.renderer = new THREE.WebGLRenderer({\r\n            canvas: this.canvas,\r\n            antialias: true,\r\n            alpha: true\r\n        });\r\n        this.renderer.setSize(this.width, this.height);\r\n        this.renderer.setPixelRatio(window.devicePixelRatio);\r\n        \r\n        // Add basic lighting\r\n        this.setupLighting();\r\n        \r\n        // Add controls for camera movement\r\n        this.setupControls();\r\n        \r\n        // Add a grid helper for development\r\n        if (options.debug) {\r\n            const gridHelper = new THREE.GridHelper(1000, 100);\r\n            this.scene.add(gridHelper);\r\n            \r\n            const axesHelper = new THREE.AxesHelper(5);\r\n            this.scene.add(axesHelper);\r\n        }\r\n        \r\n        // Set up event listeners\r\n        this.setupEventListeners();\r\n        \r\n        // Animation frame request ID\r\n        this.animationFrameId = null;\r\n        \r\n        // Track performance with stats if in debug mode\r\n        if (options.debug && window.Stats) {\r\n            this.stats = new Stats();\r\n            document.body.appendChild(this.stats.dom);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Set up scene lighting\r\n     */\r\n    setupLighting() {\r\n        // Add ambient light - increased intensity for better visibility\r\n        const ambientLight = new THREE.AmbientLight(0x404040, 0.7);\r\n        this.scene.add(ambientLight);\r\n        \r\n        // Add directional light (sun)\r\n        this.sunLight = new THREE.DirectionalLight(0xffffff, 1);\r\n        this.sunLight.position.set(50, 100, -50);\r\n        this.sunLight.castShadow = true;\r\n        \r\n        // Configure shadow properties\r\n        this.sunLight.shadow.mapSize.width = 2048;\r\n        this.sunLight.shadow.mapSize.height = 2048;\r\n        this.sunLight.shadow.camera.near = 0.5;\r\n        this.sunLight.shadow.camera.far = 500;\r\n        this.sunLight.shadow.camera.left = -100;\r\n        this.sunLight.shadow.camera.right = 100;\r\n        this.sunLight.shadow.camera.top = 100;\r\n        this.sunLight.shadow.camera.bottom = -100;\r\n        \r\n        this.scene.add(this.sunLight);\r\n        \r\n        // Add a second directional light from the opposite side for fill\r\n        const fillLight = new THREE.DirectionalLight(0xffffcc, 0.5);\r\n        fillLight.position.set(-50, 75, 50);\r\n        this.scene.add(fillLight);\r\n        \r\n        // Set up shadow rendering\r\n        this.renderer.shadowMap.enabled = true;\r\n        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\r\n    }\r\n    \r\n    /**\r\n     * Set up camera controls\r\n     */\r\n    setupControls() {\r\n        // We'll use OrbitControls for development/testing\r\n        if (THREE.OrbitControls) {\r\n            this.controls = new THREE.OrbitControls(this.camera, this.canvas);\r\n            this.controls.enableDamping = true;\r\n            this.controls.dampingFactor = 0.05;\r\n            this.controls.screenSpacePanning = false;\r\n            this.controls.minDistance = 5;\r\n            this.controls.maxDistance = 100;\r\n            this.controls.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent going below ground\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Set up event listeners for window resize\r\n     */\r\n    setupEventListeners() {\r\n        window.addEventListener('resize', () => this.handleResize());\r\n    }\r\n    \r\n    /**\r\n     * Handle window resize\r\n     */\r\n    handleResize() {\r\n        this.width = this.canvas.clientWidth;\r\n        this.height = this.canvas.clientHeight;\r\n        \r\n        this.camera.aspect = this.width / this.height;\r\n        this.camera.updateProjectionMatrix();\r\n        \r\n        this.renderer.setSize(this.width, this.height);\r\n    }\r\n    \r\n    /**\r\n     * Start the rendering loop\r\n     * @param {Function} updateCallback - Function to call each frame before rendering\r\n     */\r\n    start(updateCallback) {\r\n        if (this.animationFrameId !== null) return;\r\n        \r\n        let lastTime = 0;\r\n        \r\n        const animate = (time) => {\r\n            this.animationFrameId = requestAnimationFrame(animate);\r\n            \r\n            // Calculate delta time in seconds\r\n            const now = time * 0.001; // Convert to seconds\r\n            const deltaTime = Math.min(now - lastTime, 0.1); // Cap at 100ms\r\n            lastTime = now;\r\n            \r\n            // Update stats if available\r\n            if (this.stats) this.stats.begin();\r\n            \r\n            // Run the update callback\r\n            if (updateCallback) updateCallback(deltaTime);\r\n            \r\n            // Update controls if available\r\n            if (this.controls) this.controls.update();\r\n            \r\n            // Render the scene\r\n            this.renderer.render(this.scene, this.camera);\r\n            \r\n            // End stats measurement\r\n            if (this.stats) this.stats.end();\r\n        };\r\n        \r\n        this.animationFrameId = requestAnimationFrame(animate);\r\n    }\r\n    \r\n    /**\r\n     * Stop the rendering loop\r\n     */\r\n    stop() {\r\n        if (this.animationFrameId !== null) {\r\n            cancelAnimationFrame(this.animationFrameId);\r\n            this.animationFrameId = null;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Add an object to the scene\r\n     * @param {THREE.Object3D} object - Object to add to the scene\r\n     */\r\n    addObject(object) {\r\n        this.scene.add(object);\r\n    }\r\n    \r\n    /**\r\n     * Remove an object from the scene\r\n     * @param {THREE.Object3D} object - Object to remove from the scene\r\n     */\r\n    removeObject(object) {\r\n        this.scene.remove(object);\r\n    }\r\n    \r\n    /**\r\n     * Set up a camera to follow a boat\r\n     * @param {Boat} boat - Boat to follow\r\n     */\r\n    setupBoatCamera(boat) {\r\n        this.followBoat = boat;\r\n        \r\n        // Remove orbit controls if they exist\r\n        if (this.controls) {\r\n            this.controls.dispose();\r\n            this.controls = null;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Update the camera to follow a boat if set\r\n     */\r\n    updateBoatCamera() {\r\n        if (!this.followBoat || !this.followBoat.mesh) return;\r\n        \r\n        // If we have orbit controls, update the target to follow the boat\r\n        if (this.controls && this.controls instanceof THREE.OrbitControls) {\r\n            // Update the target position to the boat's current position\r\n            this.controls.target.copy(this.followBoat.position);\r\n            // We don't need to do anything else for orbit controls since they're updated in the animation loop\r\n            return;\r\n        }\r\n        \r\n        // Regular boat camera follow logic for other camera modes\r\n        // Get boat position and orientation\r\n        const boatPosition = this.followBoat.position.clone();\r\n        const boatQuaternion = this.followBoat.orientation.clone();\r\n        const boatEuler = new THREE.Euler().setFromQuaternion(boatQuaternion);\r\n        \r\n        // Calculate camera position: behind and above the boat\r\n        // Adjusted for Tugboat model - higher and further back\r\n        const cameraOffset = new THREE.Vector3(0, 8, -15); // Above and behind\r\n        cameraOffset.applyEuler(boatEuler);\r\n        \r\n        const cameraPosition = boatPosition.clone().add(cameraOffset);\r\n        \r\n        // Smoothly move camera to new position\r\n        this.camera.position.lerp(cameraPosition, 0.1);\r\n        \r\n        // Look at the boat, slightly above its position\r\n        const targetPosition = boatPosition.clone().add(new THREE.Vector3(0, 1.5, 0));\r\n        this.camera.lookAt(targetPosition);\r\n    }\r\n    \r\n    /**\r\n     * Set the time of day affecting lighting\r\n     * @param {number} timeOfDay - Time in hours (0-24)\r\n     */\r\n    setTimeOfDay(timeOfDay) {\r\n        // Normalize time to 0-1 range\r\n        const normalizedTime = (timeOfDay % 24) / 24;\r\n        \r\n        // Calculate sun position based on time\r\n        const sunAngle = normalizedTime * Math.PI * 2 - Math.PI / 2;\r\n        const sunHeight = Math.sin(sunAngle);\r\n        const sunDistance = 100;\r\n        \r\n        this.sunLight.position.set(\r\n            Math.cos(sunAngle) * sunDistance,\r\n            Math.max(0.1, sunHeight) * sunDistance,\r\n            0\r\n        );\r\n        \r\n        // Adjust light intensity based on time\r\n        const dayIntensity = Math.max(0, Math.sin(sunAngle));\r\n        this.sunLight.intensity = 0.5 + dayIntensity * 0.5;\r\n        \r\n        // Adjust ambient light intensity\r\n        const ambientIntensity = 0.2 + dayIntensity * 0.3;\r\n        this.scene.children.forEach(child => {\r\n            if (child instanceof THREE.AmbientLight) {\r\n                child.intensity = ambientIntensity;\r\n            }\r\n        });\r\n        \r\n        // Adjust sky color based on time\r\n        if (this.environment && this.environment.skyMesh) {\r\n            // Blend between night blue and day blue\r\n            const nightColor = new THREE.Color(0x0a1a2a);\r\n            const dayColor = new THREE.Color(0x87ceeb);\r\n            const skyColor = new THREE.Color().lerpColors(\r\n                nightColor,\r\n                dayColor,\r\n                dayIntensity\r\n            );\r\n            \r\n            this.environment.skyMesh.material.color = skyColor;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Set the environment object for time of day effects\r\n     * @param {Environment} environment - Environment object\r\n     */\r\n    setEnvironment(environment) {\r\n        this.environment = environment;\r\n    }\r\n    \r\n    /**\r\n     * Clean up resources when no longer needed\r\n     */\r\n    dispose() {\r\n        this.stop();\r\n        \r\n        window.removeEventListener('resize', this.handleResize);\r\n        \r\n        if (this.controls) {\r\n            this.controls.dispose();\r\n        }\r\n        \r\n        if (this.stats) {\r\n            document.body.removeChild(this.stats.dom);\r\n        }\r\n        \r\n        // Dispose of the renderer\r\n        this.renderer.dispose();\r\n    }\r\n}\r\n\r\n// Export the Renderer class\r\nexport default Renderer; ","__webpack_require__.h = () => (\"72e4c5f4f7abba1a0a25\")"],"names":[],"sourceRoot":""}