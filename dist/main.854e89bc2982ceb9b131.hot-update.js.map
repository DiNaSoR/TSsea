{"version":3,"file":"main.854e89bc2982ceb9b131.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAC2C;AACN;AACA;AACR;AACO,CAAC;AACwC;AAC7E;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,mBAAmB;AAClC,eAAe,SAAS;AACxB;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,+BAA+B;AAC/B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAQ;AACpC;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B,uDAAW;AAC1C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAQ;AACpC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gDAAI;AAC7B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iBAAiB;AAC5E;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,iBAAiB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,wCAAwC,gDAAI;AAC5C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4BAA4B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wBAAwB,KAAK,iBAAiB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iDAAgB,sBAAsB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uFAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mCAAmC;AACxF;AACA;AACA;AACA,iDAAiD,iCAAiC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iDAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,4BAA4B,GAAG,0BAA0B,SAAS,2BAA2B,GAAG,iBAAiB;AACpK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,IAAI,EAAC;;;;;;;;UCjyBpB","sources":["webpack://opensail/./src/js/game.js","webpack://opensail/webpack/runtime/getFullHash"],"sourcesContent":["/**\r\n * Game class to manage the overall game state and coordinate components\r\n */\r\nimport Environment from './environment.js';\r\nimport Renderer from './renderer.js';\r\nimport Controls from './controls.js';\r\nimport Boat from './boat.js';\r\nimport * as Utils from './utils.js'; // Import all utility functions as Utils namespace\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\r\n\r\nclass Game {\r\n    /**\r\n     * Create a new Game\r\n     * @param {Object} options - Game configuration options\r\n     * @param {HTMLCanvasElement} options.canvas - Canvas element for rendering\r\n     * @param {boolean} options.debug - Enable debug features\r\n     */\r\n    constructor(options = {}) {\r\n        this.canvas = options.canvas;\r\n        this.debug = options.debug || false;\r\n        \r\n        // Game objects\r\n        this.renderer = null;\r\n        this.environment = null;\r\n        this.boats = new Map(); // Map of boat id to boat object\r\n        this.localBoat = null; // Reference to the player's boat\r\n        this.controls = null;\r\n        this.course = null; // Will store race course data\r\n        \r\n        // Game state\r\n        this.state = {\r\n            isRunning: false,\r\n            isPaused: false,\r\n            raceStarted: false,\r\n            raceFinished: false,\r\n            raceTime: 0,\r\n            timeOfDay: 12, // Noon by default\r\n        };\r\n        \r\n        // Game configuration\r\n        this.config = {\r\n            boatCount: 1, // Number of boats (default single player)\r\n            initialPosition: new THREE.Vector3(0, 0, 0),\r\n            timeScale: 1, // For speeding up or slowing down physics\r\n        };\r\n        \r\n        // Multiplayer settings\r\n        this.multiplayer = {\r\n            enabled: false,\r\n            socket: null,\r\n            playerId: null,\r\n            serverUpdateRate: 20, // Hz\r\n            interpolation: true,\r\n            playerName: 'Player',\r\n        };\r\n        \r\n        // Initialize components\r\n        this.init();\r\n    }\r\n    \r\n    /**\r\n     * Initialize game components\r\n     */\r\n    init() {\r\n        console.log('Initializing game...');\r\n        \r\n        // Create renderer\r\n        this.renderer = new Renderer({\r\n            canvas: this.canvas,\r\n            debug: this.debug,\r\n        });\r\n        \r\n        // Create environment\r\n        this.environment = new Environment({\r\n            scene: this.renderer.scene,\r\n        });\r\n        \r\n        // Set environment in renderer for time of day effects\r\n        this.renderer.setEnvironment(this.environment);\r\n        \r\n        // Create controls\r\n        this.controls = new Controls({\r\n            onControlsChange: (controls) => this.handleControlsChange(controls),\r\n        });\r\n        \r\n        // Set up loading screen\r\n        this.showLoadingScreen();\r\n        \r\n        // Set up menu event listeners\r\n        this.setupMenuListeners();\r\n    }\r\n    \r\n    /**\r\n     * Show the loading screen\r\n     */\r\n    showLoadingScreen() {\r\n        const loadingScreen = document.getElementById('loading-screen');\r\n        const loadingBar = document.getElementById('loading-bar');\r\n        \r\n        if (loadingScreen) {\r\n            loadingScreen.style.display = 'flex';\r\n        }\r\n        \r\n        // Simulate loading progress\r\n        let progress = 0;\r\n        const loadingInterval = setInterval(() => {\r\n            progress += 5;\r\n            if (loadingBar) {\r\n                loadingBar.style.width = `${progress}%`;\r\n            }\r\n            \r\n            if (progress >= 100) {\r\n                clearInterval(loadingInterval);\r\n                // Show menu after loading\r\n                this.hideLoadingScreen();\r\n                this.showMenu();\r\n            }\r\n        }, 100);\r\n    }\r\n    \r\n    /**\r\n     * Hide the loading screen\r\n     */\r\n    hideLoadingScreen() {\r\n        const loadingScreen = document.getElementById('loading-screen');\r\n        if (loadingScreen) {\r\n            loadingScreen.style.display = 'none';\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Show the game menu\r\n     */\r\n    showMenu() {\r\n        const menu = document.getElementById('game-menu');\r\n        if (menu) {\r\n            menu.style.display = 'flex';\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Hide the game menu\r\n     */\r\n    hideMenu() {\r\n        const menu = document.getElementById('game-menu');\r\n        if (menu) {\r\n            menu.style.display = 'none';\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Set up menu button listeners\r\n     */\r\n    setupMenuListeners() {\r\n        const startButton = document.getElementById('start-game');\r\n        if (startButton) {\r\n            startButton.addEventListener('click', () => {\r\n                this.multiplayer.enabled = false;\r\n                this.hideMenu();\r\n                this.startSinglePlayer();\r\n            });\r\n        }\r\n        \r\n        const joinButton = document.getElementById('join-game');\r\n        if (joinButton) {\r\n            joinButton.addEventListener('click', () => {\r\n                this.multiplayer.enabled = true;\r\n                this.hideMenu();\r\n                this.startMultiplayer();\r\n            });\r\n        }\r\n        \r\n        // Update player name when input changes\r\n        const playerNameInput = document.getElementById('player-name');\r\n        if (playerNameInput) {\r\n            playerNameInput.addEventListener('input', (e) => {\r\n                this.multiplayer.playerName = e.target.value || 'Player';\r\n            });\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Start a single player game\r\n     */\r\n    startSinglePlayer() {\r\n        console.log('Starting single player game...');\r\n        \r\n        // Create a boat for the player\r\n        this.createLocalBoat();\r\n        \r\n        // Set up camera in orbit mode\r\n        this.setCameraView('orbit');\r\n        \r\n        // Set up a simple race course\r\n        this.setupRaceCourse();\r\n        \r\n        // Start the game loop\r\n        this.start();\r\n    }\r\n    \r\n    /**\r\n     * Start a multiplayer game\r\n     */\r\n    startMultiplayer() {\r\n        console.log('Starting multiplayer game...');\r\n        \r\n        // Connect to the server\r\n        this.connectToServer();\r\n        \r\n        // The rest will be handled by the server connection\r\n    }\r\n    \r\n    /**\r\n     * Create the local player's boat\r\n     */\r\n    createLocalBoat() {\r\n        const boat = new Boat({\r\n            id: 'local_player',\r\n            playerName: this.multiplayer.playerName,\r\n            position: this.config.initialPosition.clone(),\r\n            orientation: new THREE.Quaternion(),\r\n            scene: this.renderer.scene,\r\n        });\r\n        \r\n        this.boats.set(boat.id, boat);\r\n        this.localBoat = boat;\r\n        \r\n        // Update UI with player name\r\n        this.updatePlayerInfo();\r\n    }\r\n    \r\n    /**\r\n     * Set up a basic race course\r\n     */\r\n    setupRaceCourse() {\r\n        // Define a simple triangular course with start/finish line and buoys\r\n        this.course = {\r\n            startPosition: new THREE.Vector3(0, 0, 0),\r\n            buoys: [\r\n                { \r\n                    position: new THREE.Vector3(100, 0, 0),\r\n                    passed: false,\r\n                    mesh: null\r\n                },\r\n                { \r\n                    position: new THREE.Vector3(50, 0, 100),\r\n                    passed: false,\r\n                    mesh: null\r\n                },\r\n                { \r\n                    position: new THREE.Vector3(-50, 0, 50),\r\n                    passed: false,\r\n                    mesh: null\r\n                }\r\n            ],\r\n            finishPosition: new THREE.Vector3(0, 0, 0),\r\n            currentBuoy: 0,\r\n            laps: 1,\r\n            currentLap: 0,\r\n        };\r\n        \r\n        // Create visual markers for the course\r\n        this.createCourseMarkers();\r\n    }\r\n    \r\n    /**\r\n     * Create visual markers for the race course\r\n     */\r\n    createCourseMarkers() {\r\n        // Create buoys\r\n        const buoyGeometry = new THREE.SphereGeometry(2, 16, 16);\r\n        const buoyMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });\r\n        \r\n        this.course.buoys.forEach((buoy, index) => {\r\n            const buoyMesh = new THREE.Mesh(buoyGeometry, buoyMaterial);\r\n            buoyMesh.position.copy(buoy.position);\r\n            buoyMesh.position.y = 2; // Raise above water\r\n            this.renderer.scene.add(buoyMesh);\r\n            \r\n            // Store reference to the mesh\r\n            buoy.mesh = buoyMesh;\r\n            \r\n            // Add a pole\r\n            const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 8);\r\n            const poleMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });\r\n            const pole = new THREE.Mesh(poleGeometry, poleMaterial);\r\n            pole.position.set(0, -1.5, 0);\r\n            buoyMesh.add(pole);\r\n            \r\n            // Add buoy number\r\n            // In a real implementation, we would add a sprite with text\r\n        });\r\n        \r\n        // Create start/finish line\r\n        const lineGeometry = new THREE.BoxGeometry(20, 0.5, 2);\r\n        const lineMaterial = new THREE.MeshPhongMaterial({ \r\n            color: 0xffffff,\r\n            transparent: true,\r\n            opacity: 0.7,\r\n        });\r\n        const startLine = new THREE.Mesh(lineGeometry, lineMaterial);\r\n        startLine.position.copy(this.course.startPosition);\r\n        startLine.position.y = 0.3; // Slightly above water\r\n        this.renderer.scene.add(startLine);\r\n    }\r\n    \r\n    /**\r\n     * Connect to multiplayer server\r\n     */\r\n    connectToServer() {\r\n        // Create a socket.io connection using our socketConnect helper\r\n        this.multiplayer.socket = window.socketConnect();\r\n        \r\n        // Set up socket event handlers\r\n        this.setupSocketHandlers();\r\n    }\r\n    \r\n    /**\r\n     * Set up socket.io event handlers\r\n     */\r\n    setupSocketHandlers() {\r\n        const socket = this.multiplayer.socket;\r\n        \r\n        // Handle connection\r\n        socket.on('connect', () => {\r\n            console.log('Connected to server');\r\n            \r\n            // Send player info to server\r\n            socket.emit('player_join', {\r\n                name: this.multiplayer.playerName\r\n            });\r\n        });\r\n        \r\n        // Handle player ID assignment\r\n        socket.on('player_id', (data) => {\r\n            console.log('Received player ID:', data.id);\r\n            this.multiplayer.playerId = data.id;\r\n            \r\n            // Create local boat with assigned ID\r\n            this.createLocalBoat();\r\n            \r\n            // Set up camera to follow the player's boat\r\n            this.renderer.setupBoatCamera(this.localBoat);\r\n        });\r\n        \r\n        // Handle game state update from server\r\n        socket.on('game_state', (data) => {\r\n            // Update game state\r\n            this.state.raceStarted = data.raceStarted;\r\n            this.state.raceFinished = data.raceFinished;\r\n            this.state.raceTime = data.raceTime;\r\n            \r\n            // Update environment\r\n            if (data.environment) {\r\n                this.environment.handleServerUpdate(data.environment);\r\n            }\r\n            \r\n            // Update boats\r\n            if (data.boats) {\r\n                this.updateBoatsFromServer(data.boats);\r\n            }\r\n            \r\n            // Check if the game is now running\r\n            if (!this.state.isRunning && data.raceStarted) {\r\n                this.start();\r\n            }\r\n        });\r\n        \r\n        // Handle disconnection\r\n        socket.on('disconnect', () => {\r\n            console.log('Disconnected from server');\r\n            \r\n            // Handle disconnection (e.g., show a message, return to menu)\r\n            this.stop();\r\n            this.showMenu();\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Update boats from server data\r\n     * @param {Array} boatData - Array of boat states from server\r\n     */\r\n    updateBoatsFromServer(boatData) {\r\n        // Process each boat in the server data\r\n        boatData.forEach(serverBoat => {\r\n            const boatId = serverBoat.id;\r\n            \r\n            if (boatId === this.multiplayer.playerId) {\r\n                // This is our boat - only update if significant drift\r\n                // Client prediction would normally handle our movement\r\n                if (this.localBoat) {\r\n                    // For now, just apply server state - replace with proper reconciliation later\r\n                    this.localBoat.handleServerUpdate(serverBoat);\r\n                }\r\n            } else {\r\n                // This is another player's boat\r\n                if (this.boats.has(boatId)) {\r\n                    // Update existing boat\r\n                    this.boats.get(boatId).handleServerUpdate(serverBoat);\r\n                } else {\r\n                    // Create new boat\r\n                    const newBoat = new Boat({\r\n                        id: boatId,\r\n                        playerName: serverBoat.playerName || 'Other Player',\r\n                        scene: this.renderer.scene,\r\n                    });\r\n                    \r\n                    // Apply server state\r\n                    newBoat.handleServerUpdate(serverBoat);\r\n                    \r\n                    // Add to boats collection\r\n                    this.boats.set(boatId, newBoat);\r\n                }\r\n            }\r\n        });\r\n        \r\n        // Check for boats that no longer exist on server (player left)\r\n        this.boats.forEach((boat, id) => {\r\n            const stillExists = boatData.some(serverBoat => serverBoat.id === id);\r\n            \r\n            if (!stillExists && id !== this.multiplayer.playerId) {\r\n                // Remove boat that's no longer on the server\r\n                boat.dispose();\r\n                this.boats.delete(id);\r\n            }\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Start the game\r\n     */\r\n    start() {\r\n        if (this.state.isRunning) return;\r\n        \r\n        console.log('Starting game...');\r\n        \r\n        // Set game state\r\n        this.state.isRunning = true;\r\n        this.state.isPaused = false;\r\n        \r\n        // Start the renderer\r\n        this.renderer.start((deltaTime) => this.update(deltaTime));\r\n        \r\n        // Hide UI elements\r\n        this.hideMenu();\r\n        \r\n        // Update UI\r\n        this.updateUI();\r\n    }\r\n    \r\n    /**\r\n     * Main update loop\r\n     */\r\n    update(deltaTime) {\r\n        if (!this.state.isRunning || this.state.isPaused) return;\r\n        \r\n        // Calculate delta time\r\n        const now = performance.now();\r\n        const limitedDeltaTime = Math.min((now - this.lastUpdateTime) / 1000, 0.1);\r\n        this.lastUpdateTime = now;\r\n        \r\n        // Update controls\r\n        if (this.controls) {\r\n            this.controls.deltaTime = limitedDeltaTime;\r\n            this.controls.calculateKeyboardInput();\r\n        }\r\n        \r\n        // Update environment\r\n        const environmentState = this.environment.update(limitedDeltaTime);\r\n        \r\n        // Update all boats\r\n        this.boats.forEach(boat => {\r\n            boat.update(environmentState, limitedDeltaTime);\r\n        });\r\n        \r\n        // Check boat position against course markers\r\n        if (this.localBoat && this.course) {\r\n            this.checkCourseProgress();\r\n        }\r\n        \r\n        // Update camera if following a boat\r\n        this.renderer.updateBoatCamera();\r\n        \r\n        // Update UI\r\n        this.updateUI();\r\n        \r\n        // Send updates to server if in multiplayer mode\r\n        if (this.multiplayer.enabled && this.multiplayer.socket && this.localBoat) {\r\n            this.sendUpdatesToServer();\r\n        }\r\n        \r\n        // Update race time if race started\r\n        if (this.state.raceStarted && !this.state.raceFinished) {\r\n            this.state.raceTime += limitedDeltaTime;\r\n        }\r\n        \r\n        // Render scene\r\n        this.renderer.render(this.renderer.scene, this.renderer.camera);\r\n        \r\n        // Request next frame\r\n        requestAnimationFrame(() => this.update(limitedDeltaTime));\r\n    }\r\n    \r\n    /**\r\n     * Check the player's progress on the race course\r\n     */\r\n    checkCourseProgress() {\r\n        if (!this.localBoat || !this.course) return;\r\n        \r\n        // Get the next buoy to pass\r\n        const nextBuoy = this.course.buoys[this.course.currentBuoy];\r\n        \r\n        // Check distance to next buoy\r\n        const distance = this.localBoat.position.distanceTo(nextBuoy.position);\r\n        \r\n        // If close enough to the buoy, mark it as passed\r\n        if (distance < 10 && !nextBuoy.passed) {\r\n            console.log(`Passed buoy ${this.course.currentBuoy + 1}`);\r\n            nextBuoy.passed = true;\r\n            \r\n            // Change buoy color to green to indicate it's been passed\r\n            if (nextBuoy.mesh) {\r\n                nextBuoy.mesh.material.color.set(0x00ff00);\r\n            }\r\n            \r\n            // Move to next buoy\r\n            this.course.currentBuoy = (this.course.currentBuoy + 1) % this.course.buoys.length;\r\n            \r\n            // If we've completed a lap\r\n            if (this.course.currentBuoy === 0) {\r\n                this.course.currentLap++;\r\n                console.log(`Completed lap ${this.course.currentLap} of ${this.course.laps}`);\r\n                \r\n                // Reset buoys for next lap\r\n                if (this.course.currentLap < this.course.laps) {\r\n                    this.course.buoys.forEach(buoy => {\r\n                        buoy.passed = false;\r\n                        if (buoy.mesh) {\r\n                            buoy.mesh.material.color.set(0xff0000);\r\n                        }\r\n                    });\r\n                } else {\r\n                    // Race finished\r\n                    this.finishRace();\r\n                }\r\n            }\r\n            \r\n            // Update UI\r\n            this.updateCourseInfo();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle race finish\r\n     */\r\n    finishRace() {\r\n        console.log('Race finished!');\r\n        this.state.raceFinished = true;\r\n        \r\n        // Show race results\r\n        this.showRaceResults();\r\n    }\r\n    \r\n    /**\r\n     * Show race results\r\n     */\r\n    showRaceResults() {\r\n        // In a real implementation, this would display a UI with race results\r\n        alert(`Race Finished! Time: ${Utils.formatTime(this.state.raceTime)}`);\r\n    }\r\n    \r\n    /**\r\n     * Send local boat updates to the server\r\n     */\r\n    sendUpdatesToServer() {\r\n        if (!this.multiplayer.socket || !this.localBoat) return;\r\n        \r\n        // Get boat state\r\n        const boatState = this.localBoat.update(\r\n            this.environment.update(0), // Get current environment without updating\r\n            0 // Don't update physics again\r\n        );\r\n        \r\n        // Send boat state to server\r\n        this.multiplayer.socket.emit('boat_update', boatState);\r\n    }\r\n    \r\n    /**\r\n     * Handle controls changes from the Controls class\r\n     * @param {Object} controls - Current control state\r\n     */\r\n    handleControlsChange(controls) {\r\n        // Apply controls to local boat\r\n        if (this.localBoat) {\r\n            this.localBoat.rudderAngle = controls.rudderAngle;\r\n            this.localBoat.sailAngle = controls.sailAngle;\r\n            this.localBoat.throttle = controls.throttle;\r\n        }\r\n        \r\n        // We no longer need to handle camera view changes since we only use orbit mode\r\n    }\r\n    \r\n    /**\r\n     * Set camera view\r\n     * @param {string} view - Camera view type\r\n     */\r\n    setCameraView(view) {\r\n        if (!this.renderer || !this.localBoat) return;\r\n        \r\n        // We only support orbit mode now\r\n        this.currentCameraView = 'orbit';\r\n        \r\n        // Set up OrbitControls centered on the boat\r\n        if (this.renderer.controls) {\r\n            this.renderer.controls.dispose();\r\n        }\r\n        \r\n        // Use OrbitControls directly (not through THREE namespace)\r\n        this.renderer.controls = new OrbitControls(\r\n            this.renderer.camera,\r\n            this.renderer.canvas\r\n        );\r\n        \r\n        // Prevent the context menu on right-click\r\n        this.renderer.canvas.addEventListener('contextmenu', (e) => {\r\n            e.preventDefault();\r\n        }, false);\r\n        \r\n        // Configure the orbit controls for a boat-centric view\r\n        this.renderer.controls.enableDamping = true;\r\n        this.renderer.controls.dampingFactor = 0.1;\r\n        this.renderer.controls.rotateSpeed = 0.7;\r\n        this.renderer.controls.minDistance = 5;\r\n        this.renderer.controls.maxDistance = 50;\r\n        this.renderer.followBoatMode = true;\r\n        \r\n        // Disable panning so the focus stays on the boat\r\n        this.renderer.controls.enablePan = false;\r\n        \r\n        // Set initial camera position relative to the boat\r\n        const boatPosition = this.localBoat.position.clone();\r\n        this.renderer.camera.position.set(\r\n            boatPosition.x - 10,\r\n            boatPosition.y + 8,\r\n            boatPosition.z - 10\r\n        );\r\n        \r\n        // Set target to the boat\r\n        this.renderer.controls.target.copy(boatPosition);\r\n        \r\n        // Make sure controls are updated immediately\r\n        this.renderer.controls.update();\r\n    }\r\n    \r\n    /**\r\n     * Update the UI with current game state\r\n     */\r\n    updateUI() {\r\n        this.updateWindIndicator();\r\n        this.updateBoatInfo();\r\n        this.updateRaceInfo();\r\n    }\r\n    \r\n    /**\r\n     * Update the wind indicator in the UI\r\n     */\r\n    updateWindIndicator() {\r\n        const windArrow = document.getElementById('wind-arrow');\r\n        const windSpeed = document.getElementById('wind-speed');\r\n        \r\n        if (windArrow && this.environment) {\r\n            // Rotate arrow to point in wind direction\r\n            windArrow.style.transform = `rotate(${this.environment.wind.direction}deg)`;\r\n        }\r\n        \r\n        if (windSpeed && this.environment) {\r\n            // Display wind speed in knots (1 m/s ≈ 1.94 knots)\r\n            const knotsSpeed = (this.environment.wind.speed * 1.94).toFixed(1);\r\n            windSpeed.textContent = `${knotsSpeed} knots`;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Update boat information in the UI\r\n     */\r\n    updateBoatInfo() {\r\n        const headingElement = document.getElementById('heading');\r\n        const speedElement = document.getElementById('speed');\r\n        \r\n        if (headingElement && this.localBoat) {\r\n            headingElement.textContent = `Heading: ${Math.round(this.localBoat.heading)}°`;\r\n        }\r\n        \r\n        if (speedElement && this.localBoat) {\r\n            speedElement.textContent = `Speed: ${this.localBoat.speed.toFixed(1)} knots`;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Update race information in the UI\r\n     */\r\n    updateRaceInfo() {\r\n        const positionElement = document.getElementById('position');\r\n        const timerElement = document.getElementById('timer');\r\n        \r\n        if (positionElement) {\r\n            // In multiplayer, this would show race position\r\n            positionElement.textContent = 'Position: 1/1';\r\n        }\r\n        \r\n        if (timerElement) {\r\n            timerElement.textContent = Utils.formatTime(this.state.raceTime);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Update course information in the UI\r\n     */\r\n    updateCourseInfo() {\r\n        const positionElement = document.getElementById('position');\r\n        \r\n        if (positionElement && this.course) {\r\n            positionElement.textContent = `Buoy: ${this.course.currentBuoy + 1}/${this.course.buoys.length} - Lap: ${this.course.currentLap + 1}/${this.course.laps}`;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Update player information in the UI\r\n     */\r\n    updatePlayerInfo() {\r\n        // In a real implementation, this would update player-specific UI elements\r\n    }\r\n    \r\n    /**\r\n     * Stop the game\r\n     */\r\n    stop() {\r\n        if (!this.state.isRunning) return;\r\n        \r\n        console.log('Stopping game...');\r\n        \r\n        // Stop the renderer\r\n        this.renderer.stop();\r\n        \r\n        // Set game state\r\n        this.state.isRunning = false;\r\n        \r\n        // Disconnect multiplayer if active\r\n        if (this.multiplayer.enabled && this.multiplayer.socket) {\r\n            this.multiplayer.socket.disconnect();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Pause the game\r\n     */\r\n    pause() {\r\n        if (!this.state.isRunning || this.state.isPaused) return;\r\n        \r\n        console.log('Pausing game...');\r\n        this.state.isPaused = true;\r\n    }\r\n    \r\n    /**\r\n     * Resume the game\r\n     */\r\n    resume() {\r\n        if (!this.state.isRunning || !this.state.isPaused) return;\r\n        \r\n        console.log('Resuming game...');\r\n        this.state.isPaused = false;\r\n    }\r\n    \r\n    /**\r\n     * Clean up resources\r\n     */\r\n    dispose() {\r\n        this.stop();\r\n        \r\n        // Clean up all boats\r\n        this.boats.forEach(boat => boat.dispose());\r\n        this.boats.clear();\r\n        \r\n        // Clean up environment\r\n        if (this.environment) {\r\n            this.environment.dispose();\r\n        }\r\n        \r\n        // Clean up renderer\r\n        if (this.renderer) {\r\n            this.renderer.dispose();\r\n        }\r\n        \r\n        // Clean up controls\r\n        if (this.controls) {\r\n            this.controls.dispose();\r\n        }\r\n    }\r\n}\r\n\r\n// Export the Game class for use in other modules\r\nexport default Game; ","__webpack_require__.h = () => (\"db8eb905cafa9ed54c4b\")"],"names":[],"sourceRoot":""}