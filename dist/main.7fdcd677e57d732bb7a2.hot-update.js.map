{"version":3,"file":"main.7fdcd677e57d732bb7a2.hot-update.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACoC,CAAC;AACwC;;AAE7E;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,mBAAmB;AAClC;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uFAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uFAAa;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,uFAAa;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAe,QAAQ,EAAC;;;;;;;;UChbxB","sources":["webpack://opensail/./src/js/renderer.js","webpack://opensail/webpack/runtime/getFullHash"],"sourcesContent":["/**\n * Renderer class to handle THREE.js setup and rendering\n */\nimport * as Utils from './utils.js'; // Import all utility functions as Utils namespace\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\n\n/**\n * Renderer class to handle all rendering and camera logic\n */\nclass Renderer {\n    /**\n     * Create a new Renderer\n     * @param {Object} options - Renderer configuration options\n     * @param {HTMLCanvasElement} options.canvas - Canvas element to render to\n     */\n    constructor(options = {}) {\n        this.canvas = options.canvas || document.createElement('canvas');\n        this.width = this.canvas.clientWidth;\n        this.height = this.canvas.clientHeight;\n        \n        // Create the Three.js scene\n        this.scene = new THREE.Scene();\n        \n        // Create the camera\n        this.camera = new THREE.PerspectiveCamera(\n            75, // Field of view\n            this.width / this.height, // Aspect ratio\n            0.1, // Near plane\n            5000 // Far plane\n        );\n        \n        // Set initial camera position\n        this.camera.position.set(0, 10, 20);\n        this.camera.lookAt(0, 0, 0);\n        \n        // Create the WebGL renderer\n        this.renderer = new THREE.WebGLRenderer({\n            canvas: this.canvas,\n            antialias: true,\n            alpha: true\n        });\n        this.renderer.setSize(this.width, this.height);\n        this.renderer.setPixelRatio(window.devicePixelRatio);\n        \n        // Add basic lighting\n        this.setupLighting();\n        \n        // Add controls for camera movement\n        this.setupControls();\n        \n        // Add a grid helper for development\n        if (options.debug) {\n            const gridHelper = new THREE.GridHelper(1000, 100);\n            this.scene.add(gridHelper);\n            \n            const axesHelper = new THREE.AxesHelper(5);\n            this.scene.add(axesHelper);\n        }\n        \n        // Set up event listeners\n        this.setupEventListeners();\n        \n        // Animation frame request ID\n        this.animationFrameId = null;\n        \n        // Track performance with stats if in debug mode\n        if (options.debug && window.Stats) {\n            this.stats = new Stats();\n            document.body.appendChild(this.stats.dom);\n        }\n    }\n    \n    /**\n     * Set up scene lighting\n     */\n    setupLighting() {\n        // Add ambient light - increased intensity for better visibility\n        const ambientLight = new THREE.AmbientLight(0x404040, 0.7);\n        this.scene.add(ambientLight);\n        \n        // Add directional light (sun)\n        this.sunLight = new THREE.DirectionalLight(0xffffff, 1);\n        this.sunLight.position.set(50, 100, -50);\n        this.sunLight.castShadow = true;\n        \n        // Configure shadow properties\n        this.sunLight.shadow.mapSize.width = 2048;\n        this.sunLight.shadow.mapSize.height = 2048;\n        this.sunLight.shadow.camera.near = 0.5;\n        this.sunLight.shadow.camera.far = 500;\n        this.sunLight.shadow.camera.left = -100;\n        this.sunLight.shadow.camera.right = 100;\n        this.sunLight.shadow.camera.top = 100;\n        this.sunLight.shadow.camera.bottom = -100;\n        \n        this.scene.add(this.sunLight);\n        \n        // Add a second directional light from the opposite side for fill\n        const fillLight = new THREE.DirectionalLight(0xffffcc, 0.5);\n        fillLight.position.set(-50, 75, 50);\n        this.scene.add(fillLight);\n        \n        // Set up shadow rendering\n        this.renderer.shadowMap.enabled = true;\n        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n    }\n    \n    /**\n     * Set up camera controls\n     */\n    setupControls() {\n        // We'll use OrbitControls for development/testing\n        if (this.controls) {\n            this.controls.dispose();\n        }\n        \n        this.controls = new OrbitControls(this.camera, this.canvas);\n        this.controls.enableDamping = true;\n        this.controls.dampingFactor = 0.05;\n        \n        // Disable panning to ensure camera stays focused on boat\n        this.controls.enablePan = false;\n        \n        // Set appropriate zoom constraints\n        this.controls.minDistance = 5;\n        this.controls.maxDistance = 100;\n        this.controls.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent going below ground\n        \n        // Enable zoom\n        this.controls.enableZoom = true;\n        \n        // Enable rotation with left mouse button only\n        this.controls.enableRotate = true;\n        this.controls.mouseButtons = {\n            LEFT: THREE.MOUSE.ROTATE,\n            MIDDLE: THREE.MOUSE.DOLLY,\n            RIGHT: THREE.MOUSE.NONE\n        };\n        \n        // Set initial position\n        if (this.followBoat) {\n            // Position the camera behind and above the boat\n            const boatPosition = this.followBoat.position.clone();\n            this.camera.position.set(\n                boatPosition.x - 10,\n                boatPosition.y + 8,\n                boatPosition.z - 10\n            );\n            this.controls.target.copy(boatPosition);\n            this.controls.update();\n        }\n    }\n    \n    /**\n     * Set up event listeners for window resize\n     */\n    setupEventListeners() {\n        window.addEventListener('resize', () => this.handleResize());\n        \n        // Prevent context menu on right-click for the entire canvas\n        this.canvas.addEventListener('contextmenu', (e) => {\n            e.preventDefault();\n        }, false);\n    }\n    \n    /**\n     * Handle window resize\n     */\n    handleResize() {\n        this.width = this.canvas.clientWidth;\n        this.height = this.canvas.clientHeight;\n        \n        this.camera.aspect = this.width / this.height;\n        this.camera.updateProjectionMatrix();\n        \n        this.renderer.setSize(this.width, this.height);\n    }\n    \n    /**\n     * Start the rendering loop\n     * @param {Function} updateCallback - Function to call each frame before rendering\n     */\n    start(updateCallback) {\n        if (this.animationFrameId !== null) return;\n        \n        let lastTime = 0;\n        \n        const animate = (time) => {\n            this.animationFrameId = requestAnimationFrame(animate);\n            \n            // Calculate delta time in seconds\n            const now = time * 0.001; // Convert to seconds\n            const deltaTime = Math.min(now - lastTime, 0.1); // Cap at 100ms\n            lastTime = now;\n            \n            // Update stats if available\n            if (this.stats) this.stats.begin();\n            \n            // Run the update callback\n            if (updateCallback) updateCallback(deltaTime);\n            \n            // When using orbit controls, always ensure the target is the boat\n            if (this.controls instanceof OrbitControls && this.followBoat) {\n                // Always update the target to follow the boat's position\n                this.controls.target.copy(this.followBoat.position);\n            }\n            // For other camera modes, use the standard boat camera update\n            else if (this.followBoat) {\n                this.updateBoatCamera();\n            }\n            \n            // Update controls if available\n            if (this.controls) {\n                this.controls.update();\n            }\n            \n            // Render the scene\n            this.renderer.render(this.scene, this.camera);\n            \n            // End stats measurement\n            if (this.stats) this.stats.end();\n        };\n        \n        animate(0);\n    }\n    \n    /**\n     * Stop the rendering loop\n     */\n    stop() {\n        if (this.animationFrameId !== null) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = null;\n        }\n    }\n    \n    /**\n     * Add an object to the scene\n     * @param {THREE.Object3D} object - Object to add to the scene\n     */\n    addObject(object) {\n        this.scene.add(object);\n    }\n    \n    /**\n     * Remove an object from the scene\n     * @param {THREE.Object3D} object - Object to remove from the scene\n     */\n    removeObject(object) {\n        this.scene.remove(object);\n    }\n    \n    /**\n     * Set up a camera to follow a boat\n     * @param {Boat} boat - Boat to follow\n     */\n    setupBoatCamera(boat) {\n        this.followBoat = boat;\n        \n        // Remove orbit controls if they exist\n        if (this.controls) {\n            this.controls.dispose();\n            this.controls = null;\n        }\n        \n        // By default, set followBoatMode to true\n        this.followBoatMode = true;\n    }\n    \n    /**\n     * Update the camera to follow a boat if set\n     */\n    updateBoatCamera() {\n        if (!this.followBoat || !this.followBoat.mesh) return;\n        \n        // If we have orbit controls, update the target to follow the boat\n        if (this.controls && this.controls instanceof OrbitControls) {\n            // Get boat's current velocity and heading for more natural camera behavior\n            const boatVelocity = this.followBoat.velocity;\n            const boatSpeed = this.followBoat.speed;\n            \n            // Create a smoothed target position that leads the boat slightly in its direction of movement\n            // This creates a more natural looking camera that anticipates the boat's movement\n            const targetPosition = this.followBoat.position.clone();\n            \n            if (boatSpeed > 1) {\n                // Get boat direction\n                const boatDirection = new THREE.Vector3(0, 0, 1);\n                boatDirection.applyQuaternion(this.followBoat.orientation);\n                \n                // Lead distance increases with speed (looks ahead more when moving faster)\n                const leadDistance = Math.min(boatSpeed * 0.3, 5);\n                \n                // Add a small offset in the direction of movement to smooth camera motion\n                targetPosition.add(boatDirection.multiplyScalar(leadDistance));\n            }\n            \n            // Smooth camera target movement - don't snap immediately to new position\n            // Use linear interpolation (LERP) between current target and new position\n            if (this._lastTargetPosition) {\n                // Smoothing factor (0.1 = very smooth, 1.0 = instant)\n                const smoothFactor = Math.min(0.15 * (boatSpeed / 5 + 0.5), 0.3);\n                \n                // Gradually move from current position toward target position\n                this.controls.target.lerp(targetPosition, smoothFactor);\n            } else {\n                // First update - set directly\n                this.controls.target.copy(targetPosition);\n                this._lastTargetPosition = targetPosition.clone();\n            }\n            \n            // Store last position for next frame\n            this._lastTargetPosition = this.controls.target.clone();\n            \n            // Make camera height depend slightly on speed for more dynamic feel\n            const heightOffset = Math.max(2, Math.min(boatSpeed * 0.3, 5));\n            const minDistance = Math.max(10, 10 + boatSpeed * 0.5);\n            \n            // Set minimum and maximum distances for zoom\n            this.controls.minDistance = minDistance;\n            this.controls.maxDistance = 50;\n            \n            // Restrict vertical rotation for more natural viewing angles\n            this.controls.minPolarAngle = Math.PI * 0.1; // Limit how high the camera can go\n            this.controls.maxPolarAngle = Math.PI * 0.45; // Limit how low the camera can go\n            \n            // Make sure orbit controls are updated\n            this.controls.update();\n            return;\n        }\n        \n        // Skip the default camera update for first-person mode\n        // This is now handled in the setCameraView method\n        if (!this.followBoatMode) return;\n        \n        // Regular boat camera follow logic for 'follow' camera mode\n        // Get boat position and orientation\n        const boatPosition = this.followBoat.position.clone();\n        const boatQuaternion = this.followBoat.orientation.clone();\n        const boatEuler = new THREE.Euler().setFromQuaternion(boatQuaternion);\n        \n        // Calculate camera position: behind and above the boat\n        // Adjusted for Tugboat model - higher and further back\n        const cameraOffset = new THREE.Vector3(0, 8, -15); // Above and behind\n        cameraOffset.applyEuler(boatEuler);\n        \n        const cameraPosition = boatPosition.clone().add(cameraOffset);\n        \n        // Smoothly move camera to new position\n        this.camera.position.lerp(cameraPosition, 0.1);\n        \n        // Look at the boat, slightly above its position\n        const targetPosition = boatPosition.clone().add(new THREE.Vector3(0, 1.5, 0));\n        this.camera.lookAt(targetPosition);\n    }\n    \n    /**\n     * Set the time of day affecting lighting\n     * @param {number} timeOfDay - Time in hours (0-24)\n     */\n    setTimeOfDay(timeOfDay) {\n        // Normalize time to 0-1 range\n        const normalizedTime = (timeOfDay % 24) / 24;\n        \n        // Calculate sun position based on time\n        const sunAngle = normalizedTime * Math.PI * 2 - Math.PI / 2;\n        const sunHeight = Math.sin(sunAngle);\n        const sunDistance = 100;\n        \n        this.sunLight.position.set(\n            Math.cos(sunAngle) * sunDistance,\n            Math.max(0.1, sunHeight) * sunDistance,\n            0\n        );\n        \n        // Adjust light intensity based on time\n        const dayIntensity = Math.max(0, Math.sin(sunAngle));\n        this.sunLight.intensity = 0.5 + dayIntensity * 0.5;\n        \n        // Adjust ambient light intensity\n        const ambientIntensity = 0.2 + dayIntensity * 0.3;\n        this.scene.children.forEach(child => {\n            if (child instanceof THREE.AmbientLight) {\n                child.intensity = ambientIntensity;\n            }\n        });\n        \n        // Adjust sky color based on time\n        if (this.environment && this.environment.skyMesh) {\n            // Blend between night blue and day blue\n            const nightColor = new THREE.Color(0x0a1a2a);\n            const dayColor = new THREE.Color(0x87ceeb);\n            const skyColor = new THREE.Color().lerpColors(\n                nightColor,\n                dayColor,\n                dayIntensity\n            );\n            \n            this.environment.skyMesh.material.color = skyColor;\n        }\n    }\n    \n    /**\n     * Set the environment object for time of day effects\n     * @param {Environment} environment - Environment object\n     */\n    setEnvironment(environment) {\n        this.environment = environment;\n    }\n    \n    /**\n     * Clean up resources when no longer needed\n     */\n    dispose() {\n        this.stop();\n        \n        window.removeEventListener('resize', this.handleResize);\n        \n        if (this.controls) {\n            this.controls.dispose();\n        }\n        \n        if (this.stats) {\n            document.body.removeChild(this.stats.dom);\n        }\n        \n        // Dispose of the renderer\n        this.renderer.dispose();\n    }\n}\n\n// Export the Renderer class\nexport default Renderer; ","__webpack_require__.h = () => (\"76812bc904ffe2db887c\")"],"names":[],"sourceRoot":""}