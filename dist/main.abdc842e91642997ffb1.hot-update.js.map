{"version":3,"file":"main.abdc842e91642997ffb1.hot-update.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACoC,CAAC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,eAAe;AAC9B,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,yCAAyC;AACzC,2BAA2B;AAC3B;AACA;AACA,8BAA8B;AAC9B,4BAA4B;AAC5B;AACA;AACA,0BAA0B;AAC1B,wBAAwB;AACxB;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,gBAAgB;AACvF;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB;AACtB,8CAA8C,YAAY;AAC1D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,oEAAoE,UAAU;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iBAAiB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,iBAAiB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iBAAiB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAoB,CAAC,+CAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,eAAe;AAChC;AACA;AACA;AACA,2BAA2B,+CAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4DAA2B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA,kCAAkC,qDAAoB,CAAC,+CAAc;AACrE;AACA;AACA;AACA;AACA,yBAAyB,2CAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+CAAc;AACnD,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAAW;AAC9B,UAAU;AACV;AACA,mBAAmB,4CAAW;AAC9B;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA,2BAA2B,+CAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,+CAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAc;AACjD;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,+BAA+B,4CAAW;AAC1C;AACA;AACA;AACA,6BAA6B,4CAAW;AACxC;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,iEAAe,IAAI,EAAC;;;;;;;;UC/1BpB","sources":["webpack://opensail/./src/js/boat.js","webpack://opensail/webpack/runtime/getFullHash"],"sourcesContent":["/**\r\n * Boat class to handle boat physics and visualization\r\n */\r\nimport * as Utils from './utils.js'; // Import all utility functions as Utils namespace\r\n\r\n/**\r\n * Boat class representing a sailboat in the game\r\n */\r\nclass Boat {\r\n    /**\r\n     * Create a new Boat\r\n     * @param {Object} options - Boat configuration options\r\n     * @param {string} options.id - Unique identifier for the boat\r\n     * @param {string} options.playerName - Name of the player controlling the boat\r\n     * @param {THREE.Vector3} options.position - Initial position\r\n     * @param {THREE.Quaternion} options.orientation - Initial orientation\r\n     * @param {number} options.length - Boat length in meters\r\n     * @param {number} options.width - Boat width in meters\r\n     * @param {THREE.Scene} options.scene - Three.js scene to add the boat to\r\n     */\r\n    constructor(options) {\r\n        this.id = options.id || 'boat_' + Math.random().toString(36).substr(2, 9);\r\n        this.playerName = options.playerName || 'Player';\r\n        \r\n        // Physics properties\r\n        this.position = options.position || new THREE.Vector3(0, 0, 0);\r\n        this.orientation = options.orientation || new THREE.Quaternion();\r\n        this.velocity = new THREE.Vector3(0, 0, 0);\r\n        this.angularVelocity = new THREE.Vector3(0, 0, 0);\r\n        \r\n        // Boat dimensions\r\n        this.length = options.length || 6; // meters\r\n        this.width = options.width || 2; // meters\r\n        this.height = 2.5; // meters\r\n        \r\n        // Control properties\r\n        this.rudderAngle = 0; // degrees, -45 to 45\r\n        this.sailAngle = 0; // degrees, -90 to 90\r\n        \r\n        // Boat state\r\n        this.heading = 0; // degrees, 0-359\r\n        this.speed = 0; // knots\r\n        \r\n        // Physics constants (will be tuned)\r\n        this.mass = 1000; // kg\r\n        this.dragCoefficient = 0.05;\r\n        this.sailForceCoefficient = 30;\r\n        this.rudderForceCoefficient = 15;\r\n        this.lateralResistanceCoefficient = 50;\r\n        \r\n        // 3D model properties\r\n        this.mesh = null;\r\n        this.scene = options.scene;\r\n        \r\n        // Initialize the 3D model\r\n        this.initMesh();\r\n    }\r\n    \r\n    /**\r\n     * Initialize the 3D mesh for the boat\r\n     */\r\n    initMesh() {\r\n        try {\r\n            // Use GLTFLoader for loading .glb models\r\n            const loader = new GLTFLoader();\r\n            \r\n            // Try with multiple path formats\r\n            const modelPaths = [\r\n                window.ASSET_PATH.models + 'boat.glb',     // Using configured path\r\n                '/assets/models/boat.glb',                 // Absolute path from root\r\n                'assets/models/boat.glb',                  // No leading slash\r\n                './assets/models/boat.glb'                 // Relative path with dot\r\n            ];\r\n            \r\n            console.log(\"Attempting to load boat model with paths:\", modelPaths);\r\n            \r\n            // First check if the file exists using fetch\r\n            fetch(modelPaths[0])\r\n                .then(response => {\r\n                    if (!response.ok) {\r\n                        throw new Error(`File not accessible (status ${response.status})`);\r\n                    }\r\n                    console.log(\"boat.glb is accessible via fetch at:\", modelPaths[0]);\r\n                    // File exists, proceed with GLTFLoader\r\n                    return this.loadModelWithLoader(modelPaths[0]);\r\n                })\r\n                .catch(error => {\r\n                    console.error(\"Fetch failed:\", error);\r\n                    console.log(\"Trying alternate loading methods...\");\r\n                    this.tryNextPath(modelPaths, 1);\r\n                });\r\n                \r\n            // Create boat wake\r\n            this.createBoatWake();\r\n        } catch (e) {\r\n            console.error(\"Exception in initMesh:\", e);\r\n            this.createFallbackBoat();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Load model with GLTFLoader\r\n     */\r\n    loadModelWithLoader(modelPath) {\r\n        const loader = new GLTFLoader();\r\n        console.log(\"Loading boat model using GLTFLoader with path:\", modelPath);\r\n        \r\n        return new Promise((resolve, reject) => {\r\n            loader.load(\r\n                modelPath,\r\n                (gltf) => {\r\n                    console.log(\"Boat model loaded successfully with path:\", modelPath);\r\n                    this.mesh = gltf.scene;\r\n                    \r\n                    // Log the loaded model structure to help with debugging\r\n                    console.log(\"GLTF model structure:\", gltf);\r\n                    \r\n                    // Set initial position and orientation\r\n                    this.mesh.position.copy(this.position);\r\n                    this.mesh.quaternion.copy(this.orientation);\r\n                    \r\n                    // Rotate the boat model 180 degrees around the Y axis\r\n                    this.mesh.rotation.y = Math.PI; // 180 degrees in radians\r\n                    \r\n                    // Set a proper scale for the boat\r\n                    const scale = 0.5; // Start with a moderate scale, adjust based on model size\r\n                    this.mesh.scale.set(scale, scale, scale);\r\n                    \r\n                    // Lower the boat position to reduce hovering\r\n                    this.mesh.position.y -= 0.5; // Adjust this value as needed\r\n                    \r\n                    // Add boat to scene\r\n                    if (this.scene) {\r\n                        this.scene.add(this.mesh);\r\n                        console.log(\"Boat added to scene successfully\");\r\n                    } else {\r\n                        console.error(\"Scene not available, cannot add boat mesh\");\r\n                    }\r\n                    \r\n                    // Create player name label\r\n                    this.createPlayerLabel();\r\n                    \r\n                    // Set up shadows\r\n                    this.setupShadows();\r\n                    \r\n                    // Add engine exhaust effect\r\n                    this.createEngineExhaust();\r\n                    \r\n                    // Log success\r\n                    console.log(`Boat for ${this.playerName} loaded`);\r\n                    resolve(this.mesh);\r\n                },\r\n                // onProgress callback\r\n                (xhr) => {\r\n                    if (xhr.total && xhr.total > 0) {\r\n                        console.log((xhr.loaded / xhr.total * 100) + '% of boat model loaded');\r\n                    } else {\r\n                        console.log(`Loaded ${xhr.loaded} bytes`);\r\n                    }\r\n                },\r\n                // onError callback\r\n                (error) => {\r\n                    console.error(\"GLTFLoader failed with path:\", modelPath, error);\r\n                    reject(error);\r\n                }\r\n            );\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Try loading the model with the next available path\r\n     */\r\n    tryNextPath(paths, index) {\r\n        if (index >= paths.length) {\r\n            console.error(\"All paths failed, creating fallback boat\");\r\n            this.createFallbackBoat();\r\n            return;\r\n        }\r\n        \r\n        const modelPath = paths[index];\r\n        console.log(\"Trying alternate path:\", modelPath);\r\n        \r\n        const loader = new GLTFLoader();\r\n        loader.load(\r\n            modelPath,\r\n            (gltf) => {\r\n                console.log(\"Boat model loaded successfully with alternate path:\", modelPath);\r\n                this.mesh = gltf.scene;\r\n                \r\n                // Set initial position and orientation\r\n                this.mesh.position.copy(this.position);\r\n                this.mesh.quaternion.copy(this.orientation);\r\n                \r\n                // Rotate the boat model 180 degrees around the Y axis\r\n                this.mesh.rotation.y = Math.PI; // 180 degrees in radians\r\n                \r\n                // Set a proper scale for the boat\r\n                const scale = 0.5; // Adjusted scale for better visibility\r\n                this.mesh.scale.set(scale, scale, scale);\r\n                \r\n                // Lower the boat position to reduce hovering\r\n                this.mesh.position.y -= 0.5; // Adjust this value as needed\r\n                \r\n                // Add to scene\r\n                if (this.scene) {\r\n                    this.scene.add(this.mesh);\r\n                    console.log(\"Boat added to scene with alternate path\");\r\n                } else {\r\n                    console.error(\"Scene not available for alternate path loading\");\r\n                }\r\n                \r\n                // Create player name label\r\n                this.createPlayerLabel();\r\n                \r\n                // Set up shadows\r\n                this.setupShadows();\r\n                \r\n                // Add engine exhaust effect\r\n                this.createEngineExhaust();\r\n                \r\n                // Log success\r\n                console.log(`Boat for ${this.playerName} loaded with alternate path`);\r\n            },\r\n            // onProgress callback\r\n            (xhr) => {\r\n                if (xhr.total && xhr.total > 0) {\r\n                    console.log((xhr.loaded / xhr.total * 100) + '% of boat model loaded (alternate path)');\r\n                }\r\n            },\r\n            // onError callback\r\n            (error) => {\r\n                console.error(`Error loading boat model with path ${modelPath}:`, error);\r\n                // Try the next path\r\n                this.tryNextPath(paths, index + 1);\r\n            }\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * Load the boat texture (now handled by GLTFLoader for glb files)\r\n     */\r\n    loadTexture() {\r\n        // GLB files already include textures, so this method is not needed\r\n        // We'll keep it as a placeholder in case custom textures are needed later\r\n        console.log(\"Using textures embedded in the GLB file\");\r\n    }\r\n    \r\n    /**\r\n     * Create a simple fallback mesh if the model fails to load\r\n     */\r\n    createFallbackBoat() {\r\n        // Create a simple boat shape using primitive geometries\r\n        const boatGroup = new THREE.Group();\r\n        \r\n        // Hull\r\n        const hullGeometry = new THREE.BoxGeometry(this.length, this.height / 2, this.width);\r\n        const hullMaterial = new THREE.MeshPhongMaterial({ color: 0x3366ff });\r\n        const hull = new THREE.Mesh(hullGeometry, hullMaterial);\r\n        hull.position.y = -this.height / 4;\r\n        boatGroup.add(hull);\r\n        \r\n        // Cabin\r\n        const cabinGeometry = new THREE.BoxGeometry(this.length / 3, this.height / 2, this.width * 0.8);\r\n        const cabinMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });\r\n        const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);\r\n        cabin.position.set(0, this.height / 4, 0);\r\n        boatGroup.add(cabin);\r\n        \r\n        // Mast\r\n        const mastGeometry = new THREE.CylinderGeometry(0.05, 0.05, this.height * 2, 8);\r\n        const mastMaterial = new THREE.MeshPhongMaterial({ color: 0x999999 });\r\n        const mast = new THREE.Mesh(mastGeometry, mastMaterial);\r\n        mast.position.set(0, this.height, 0);\r\n        boatGroup.add(mast);\r\n        \r\n        // Sail\r\n        this.sail = new THREE.Group();\r\n        const sailGeometry = new THREE.PlaneGeometry(this.length * 0.7, this.height * 1.5);\r\n        const sailMaterial = new THREE.MeshPhongMaterial({ \r\n            color: 0xffffff,\r\n            side: THREE.DoubleSide\r\n        });\r\n        const sailMesh = new THREE.Mesh(sailGeometry, sailMaterial);\r\n        sailMesh.position.set(this.length * 0.2, 0, 0);\r\n        sailMesh.rotation.y = Math.PI / 2;\r\n        this.sail.add(sailMesh);\r\n        this.sail.position.set(0, this.height * 0.75, 0);\r\n        boatGroup.add(this.sail);\r\n        \r\n        // Center the boat\r\n        boatGroup.position.copy(this.position);\r\n        boatGroup.quaternion.copy(this.orientation);\r\n        \r\n        // Set as the boat mesh\r\n        this.mesh = boatGroup;\r\n        \r\n        // Add to scene\r\n        if (this.scene) {\r\n            this.scene.add(this.mesh);\r\n        }\r\n        \r\n        // Create player name label\r\n        this.createPlayerLabel();\r\n        \r\n        console.log(`Fallback boat for ${this.playerName} created`);\r\n    }\r\n    \r\n    /**\r\n     * Create a text label showing the player name\r\n     */\r\n    createPlayerLabel() {\r\n        // This would typically use a sprite with a dynamically generated texture\r\n        // For simplicity, we'll omit the actual implementation for now\r\n    }\r\n    \r\n    /**\r\n     * Update the boat physics\r\n     * @param {Object} environment - Environment information including wind and waves\r\n     * @param {number} deltaTime - Time step in seconds\r\n     */\r\n    update(environment, deltaTime) {\r\n        // Skip physics if deltaTime is too large (e.g., after pausing)\r\n        if (deltaTime > 0.1) deltaTime = 0.1;\r\n        \r\n        // Get environment info\r\n        const { wind, waves } = environment;\r\n        \r\n        // Calculate forces\r\n        const forces = this.calculateForces(wind, waves);\r\n        \r\n        // Apply acceleration based on forces\r\n        const acceleration = forces.clone().divideScalar(this.mass);\r\n        \r\n        // Update velocity (v = v0 + a * t)\r\n        this.velocity.add(acceleration.clone().multiplyScalar(deltaTime));\r\n        \r\n        // Apply drag (simplified)\r\n        this.velocity.multiplyScalar(1 - this.dragCoefficient * deltaTime);\r\n        \r\n        // Update position (p = p0 + v * t)\r\n        this.position.add(this.velocity.clone().multiplyScalar(deltaTime));\r\n        \r\n        // Apply angular velocity\r\n        const rotationAxis = new THREE.Vector3(0, 1, 0);\r\n        const rotationAngle = this.angularVelocity.y * deltaTime;\r\n        const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(rotationAxis, rotationAngle);\r\n        this.orientation.premultiply(rotationQuaternion);\r\n        this.orientation.normalize();\r\n        \r\n        // Update heading (in degrees)\r\n        const euler = new THREE.Euler().setFromQuaternion(this.orientation);\r\n        this.heading = Utils.normalizeAngle(Utils.radToDeg(euler.y) * -1);\r\n        \r\n        // Calculate speed in knots (1 m/s â‰ˆ 1.94 knots)\r\n        this.speed = this.velocity.length() * 1.94;\r\n        \r\n        // Create water splash effects when the boat is moving fast enough\r\n        if (this.speed > 2 && Math.random() < 0.05) {\r\n            // Create a new splash effect at random intervals\r\n            if (!this.splashParticles) {\r\n                this.createWaterSplash();\r\n            }\r\n        }\r\n        \r\n        // Update existing water splash\r\n        if (this.splashParticles) {\r\n            this.updateWaterSplash(deltaTime);\r\n        }\r\n        \r\n        // Update boat wake\r\n        this.updateBoatWake();\r\n        \r\n        // Apply wave effects on boat position and rotation\r\n        this.applyWaveEffects(waves, deltaTime);\r\n        \r\n        // Update 3D model if it exists\r\n        this.updateMesh();\r\n        \r\n        // Return state for networking\r\n        return {\r\n            id: this.id,\r\n            position: this.position.clone(),\r\n            orientation: this.orientation.clone(),\r\n            velocity: this.velocity.clone(),\r\n            angularVelocity: this.angularVelocity.clone(),\r\n            rudderAngle: this.rudderAngle,\r\n            sailAngle: this.sailAngle,\r\n            heading: this.heading,\r\n            speed: this.speed\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Calculate all forces acting on the boat\r\n     * @param {Object} wind - Wind information\r\n     * @param {Object} waves - Wave information\r\n     * @returns {THREE.Vector3} Net force acting on the boat\r\n     */\r\n    calculateForces(wind, waves) {\r\n        // Convert heading to radians and get direction vector\r\n        const headingRad = Utils.degToRad(this.heading);\r\n        const boatDirection = new THREE.Vector3(\r\n            Math.sin(headingRad),\r\n            0,\r\n            Math.cos(headingRad)\r\n        );\r\n        \r\n        // Calculate apparent wind (wind relative to boat)\r\n        const apparentWind = Utils.calculateApparentWind(\r\n            new THREE.Vector3(wind.x, wind.y, wind.z),\r\n            this.velocity\r\n        );\r\n        \r\n        // Calculate sail force\r\n        const sailForce = this.calculateSailForce(apparentWind, boatDirection);\r\n        \r\n        // Calculate rudder force\r\n        const rudderForce = this.calculateRudderForce(boatDirection);\r\n        \r\n        // Calculate lateral resistance (keeps boat from sliding sideways)\r\n        const lateralResistanceForce = this.calculateLateralResistance();\r\n        \r\n        // Sum all forces\r\n        const netForce = new THREE.Vector3(0, 0, 0)\r\n            .add(sailForce)\r\n            .add(rudderForce)\r\n            .add(lateralResistanceForce);\r\n            \r\n        return netForce;\r\n    }\r\n    \r\n    /**\r\n     * Calculate force generated by the sail\r\n     * @param {THREE.Vector3} apparentWind - Apparent wind vector\r\n     * @param {THREE.Vector3} boatDirection - Boat's forward direction\r\n     * @returns {THREE.Vector3} Sail force\r\n     */\r\n    calculateSailForce(apparentWind, boatDirection) {\r\n        // Calculate relative angle between wind and boat heading\r\n        const boatAngle = Math.atan2(boatDirection.x, boatDirection.z);\r\n        const windAngle = Math.atan2(apparentWind.x, apparentWind.z);\r\n        const relativeWindAngle = Utils.normalizeAngle(Utils.radToDeg(windAngle - boatAngle));\r\n        \r\n        // Adjust the sail angle based on relative wind (auto-trim)\r\n        // In a real implementation, the player would control this\r\n        const optimalSailAngle = this.calculateOptimalSailAngle(relativeWindAngle);\r\n        this.sailAngle = Utils.lerp(this.sailAngle, optimalSailAngle, 0.1);\r\n        \r\n        // Calculate effective sail angle (relative wind angle - sail angle)\r\n        const effectiveSailAngle = Math.abs(relativeWindAngle - this.sailAngle);\r\n        \r\n        // Calculate sail force coefficient (simplified sail physics)\r\n        // Max force at ~45 degrees to the wind, minimal when sailing directly into or away from wind\r\n        let sailForceCoef = Math.sin(Utils.degToRad(effectiveSailAngle) * 2);\r\n        sailForceCoef = Math.max(0, sailForceCoef); // No negative force\r\n        \r\n        // Scale by wind strength\r\n        const windStrength = apparentWind.length();\r\n        const forceMagnitude = this.sailForceCoefficient * sailForceCoef * windStrength;\r\n        \r\n        // Apply force in boat's forward direction (simplified)\r\n        return boatDirection.clone().multiplyScalar(forceMagnitude);\r\n    }\r\n    \r\n    /**\r\n     * Calculate optimal sail angle for current wind\r\n     * @param {number} relativeWindAngle - Angle between wind and boat heading\r\n     * @returns {number} Optimal sail angle in degrees\r\n     */\r\n    calculateOptimalSailAngle(relativeWindAngle) {\r\n        // Simplified optimal sail angle calculation\r\n        // In a real sailing sim, this would be more complex\r\n        if (relativeWindAngle > 180) {\r\n            // Wind from port side\r\n            return Utils.clamp(relativeWindAngle - 180, -80, 0);\r\n        } else {\r\n            // Wind from starboard side\r\n            return Utils.clamp(relativeWindAngle, 0, 80);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Calculate force generated by the rudder\r\n     * @param {THREE.Vector3} boatDirection - Boat's forward direction\r\n     * @returns {THREE.Vector3} Rudder torque as a force\r\n     */\r\n    calculateRudderForce(boatDirection) {\r\n        // Rudder effect increases with boat speed\r\n        const rudderEffectiveness = this.speed * 0.1;\r\n        \r\n        // Calculate angular force from rudder\r\n        this.angularVelocity.y = this.rudderAngle * this.rudderForceCoefficient * \r\n                               rudderEffectiveness * 0.001;\r\n                               \r\n        // Return zero force (rudder affects angular velocity)\r\n        return new THREE.Vector3(0, 0, 0);\r\n    }\r\n    \r\n    /**\r\n     * Calculate lateral resistance force that prevents sideways slipping\r\n     * @returns {THREE.Vector3} Lateral resistance force\r\n     */\r\n    calculateLateralResistance() {\r\n        // Get boat's right vector\r\n        const headingRad = Utils.degToRad(this.heading);\r\n        const rightVector = new THREE.Vector3(\r\n            -Math.cos(headingRad),\r\n            0,\r\n            Math.sin(headingRad)\r\n        );\r\n        \r\n        // Calculate lateral component of velocity\r\n        const lateralVelocity = rightVector.clone().multiplyScalar(\r\n            rightVector.dot(this.velocity)\r\n        );\r\n        \r\n        // Apply resistance proportional to lateral velocity\r\n        return lateralVelocity.clone().multiplyScalar(-this.lateralResistanceCoefficient);\r\n    }\r\n    \r\n    /**\r\n     * Apply wave effects to the boat\r\n     * @param {Object} waves - Wave information\r\n     * @param {number} deltaTime - Time step in seconds\r\n     */\r\n    applyWaveEffects(waves, deltaTime) {\r\n        if (!waves || !waves.isActive) return;\r\n        \r\n        // Calculate wave height at boat position\r\n        const waveHeight = this.calculateWaveHeight(this.position, waves, Date.now() / 1000);\r\n        \r\n        // Adjust boat position based on wave height\r\n        this.position.y = waveHeight;\r\n        \r\n        // Calculate wave slope at boat position for pitch and roll\r\n        const slopeX = this.calculateWaveSlope(this.position, waves, Date.now() / 1000, 'x');\r\n        const slopeZ = this.calculateWaveSlope(this.position, waves, Date.now() / 1000, 'z');\r\n        \r\n        // Apply pitch and roll based on wave slope\r\n        const targetRotation = new THREE.Quaternion().setFromEuler(\r\n            new THREE.Euler(-slopeZ * 0.5, Utils.degToRad(this.heading) * -1, slopeX * 0.5)\r\n        );\r\n        \r\n        // Smoothly interpolate rotation\r\n        this.orientation.slerp(targetRotation, 2 * deltaTime);\r\n    }\r\n    \r\n    /**\r\n     * Calculate wave height at a given position\r\n     * @param {THREE.Vector3} position - Position to calculate height at\r\n     * @param {Object} waves - Wave parameters\r\n     * @param {number} time - Current time\r\n     * @returns {number} Wave height\r\n     */\r\n    calculateWaveHeight(position, waves, time) {\r\n        // Simple sin wave function\r\n        // In a real implementation, would use a sum of multiple sine waves\r\n        const x = position.x;\r\n        const z = position.z;\r\n        const amplitude = waves.amplitude || 0.5;\r\n        const frequency = waves.frequency || 0.2;\r\n        const direction = waves.direction || 0;\r\n        const speed = waves.speed || 1;\r\n        \r\n        // Calculate directed coordinates\r\n        const dirRad = Utils.degToRad(direction);\r\n        const dx = x * Math.cos(dirRad) + z * Math.sin(dirRad);\r\n        \r\n        // Calculate height using sin wave\r\n        return amplitude * Math.sin(dx * frequency + time * speed);\r\n    }\r\n    \r\n    /**\r\n     * Calculate wave slope at a given position\r\n     * @param {THREE.Vector3} position - Position to calculate slope at\r\n     * @param {Object} waves - Wave parameters\r\n     * @param {number} time - Current time\r\n     * @param {string} axis - Axis to calculate slope for ('x' or 'z')\r\n     * @returns {number} Wave slope\r\n     */\r\n    calculateWaveSlope(position, waves, time, axis) {\r\n        // Sample height at two nearby points to calculate slope\r\n        const delta = 0.1;\r\n        let pos1 = position.clone();\r\n        let pos2 = position.clone();\r\n        \r\n        if (axis === 'x') {\r\n            pos1.x -= delta;\r\n            pos2.x += delta;\r\n        } else {\r\n            pos1.z -= delta;\r\n            pos2.z += delta;\r\n        }\r\n        \r\n        const height1 = this.calculateWaveHeight(pos1, waves, time);\r\n        const height2 = this.calculateWaveHeight(pos2, waves, time);\r\n        \r\n        return (height2 - height1) / (2 * delta);\r\n    }\r\n    \r\n    /**\r\n     * Update the 3D mesh based on current state\r\n     */\r\n    updateMesh() {\r\n        if (!this.mesh) return;\r\n        \r\n        // Update position and orientation\r\n        this.mesh.position.copy(this.position);\r\n        this.mesh.quaternion.copy(this.orientation);\r\n        \r\n        // Update sail rotation if we have a sail object\r\n        if (this.sail) {\r\n            this.sail.rotation.y = Utils.degToRad(this.sailAngle);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Set boat controls\r\n     * @param {Object} controls - Control inputs\r\n     * @param {number} controls.rudderAngle - Rudder angle (-45 to 45 degrees)\r\n     * @param {number} controls.sailAngle - Sail angle (-90 to 90 degrees)\r\n     */\r\n    setControls(controls) {\r\n        if (controls.rudderAngle !== undefined) {\r\n            this.rudderAngle = Utils.clamp(controls.rudderAngle, -45, 45);\r\n        }\r\n        \r\n        if (controls.sailAngle !== undefined) {\r\n            this.sailAngle = Utils.clamp(controls.sailAngle, -90, 90);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle server update for client-side interpolation\r\n     * @param {Object} state - Boat state from server\r\n     */\r\n    handleServerUpdate(state) {\r\n        // Update position and orientation for interpolation\r\n        this.serverPosition = new THREE.Vector3().fromArray(state.position);\r\n        this.serverOrientation = new THREE.Quaternion(\r\n            state.orientation[0],\r\n            state.orientation[1],\r\n            state.orientation[2],\r\n            state.orientation[3]\r\n        );\r\n        this.serverVelocity = new THREE.Vector3().fromArray(state.velocity);\r\n        this.heading = state.heading;\r\n        this.speed = state.speed;\r\n        \r\n        // Directly update controls\r\n        this.sailAngle = state.sailAngle;\r\n        this.rudderAngle = state.rudderAngle;\r\n    }\r\n    \r\n    /**\r\n     * Interpolate between current and server state\r\n     * @param {number} alpha - Interpolation factor (0-1)\r\n     */\r\n    interpolate(alpha) {\r\n        if (!this.serverPosition || !this.serverOrientation) return;\r\n        \r\n        // Interpolate position\r\n        this.position.lerp(this.serverPosition, alpha);\r\n        \r\n        // Interpolate orientation\r\n        this.orientation.slerp(this.serverOrientation, alpha);\r\n        \r\n        // Update mesh\r\n        this.updateMesh();\r\n    }\r\n    \r\n    /**\r\n     * Remove boat from scene and clean up resources\r\n     */\r\n    dispose() {\r\n        if (this.mesh && this.scene) {\r\n            this.scene.remove(this.mesh);\r\n            \r\n            // Dispose geometries and materials\r\n            if (this.mesh.traverse) {\r\n                this.mesh.traverse((child) => {\r\n                    if (child.geometry) child.geometry.dispose();\r\n                    if (child.material) {\r\n                        if (Array.isArray(child.material)) {\r\n                            child.material.forEach(material => material.dispose());\r\n                        } else {\r\n                            child.material.dispose();\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Set up shadows for the boat\r\n     */\r\n    setupShadows() {\r\n        if (!this.mesh) return;\r\n        \r\n        // Add shadow casting/receiving to all meshes\r\n        this.mesh.traverse(child => {\r\n            if (child.isMesh) {\r\n                child.castShadow = true;\r\n                child.receiveShadow = true;\r\n            }\r\n        });\r\n        \r\n        console.log(\"Shadows set up for the boat\");\r\n    }\r\n    \r\n    /**\r\n     * Create a water splash effect\r\n     */\r\n    createWaterSplash() {\r\n        if (!this.scene) return;\r\n        \r\n        // Create a splash particle system\r\n        const splashGeometry = new THREE.BufferGeometry();\r\n        const splashMaterial = new THREE.PointsMaterial({\r\n            color: 0xFFFFFF,\r\n            size: 0.1,\r\n            transparent: true,\r\n            opacity: 0.8\r\n        });\r\n        \r\n        // Create particles\r\n        const particleCount = 50;\r\n        const positions = new Float32Array(particleCount * 3);\r\n        \r\n        // Initialize particles at the boat position\r\n        for (let i = 0; i < particleCount; i++) {\r\n            const i3 = i * 3;\r\n            positions[i3] = this.position.x + (Math.random() - 0.5) * this.width * 0.5;\r\n            positions[i3 + 1] = 0; // At water level\r\n            positions[i3 + 2] = this.position.z + (Math.random() - 0.5) * this.length * 0.5;\r\n        }\r\n        \r\n        splashGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\r\n        \r\n        // Create the particle system\r\n        this.splashParticles = new THREE.Points(splashGeometry, splashMaterial);\r\n        this.scene.add(this.splashParticles);\r\n        \r\n        // Store particle velocities\r\n        this.splashVelocities = [];\r\n        for (let i = 0; i < particleCount; i++) {\r\n            this.splashVelocities.push({\r\n                x: (Math.random() - 0.5) * 0.1,\r\n                y: Math.random() * 0.2,\r\n                z: (Math.random() - 0.5) * 0.1\r\n            });\r\n        }\r\n        \r\n        // Set splash lifetime\r\n        this.splashLifetime = 1; // seconds\r\n        this.splashTimer = 0;\r\n    }\r\n    \r\n    /**\r\n     * Update the water splash effect\r\n     * @param {number} deltaTime - Time since last update in seconds\r\n     */\r\n    updateWaterSplash(deltaTime) {\r\n        if (!this.splashParticles) return;\r\n        \r\n        // Increment splash timer\r\n        this.splashTimer += deltaTime;\r\n        \r\n        // If the splash has lived its lifetime, remove it\r\n        if (this.splashTimer >= this.splashLifetime) {\r\n            this.scene.remove(this.splashParticles);\r\n            this.splashParticles.geometry.dispose();\r\n            this.splashParticles.material.dispose();\r\n            this.splashParticles = null;\r\n            this.splashVelocities = null;\r\n            return;\r\n        }\r\n        \r\n        // Update particle positions based on velocity\r\n        const positions = this.splashParticles.geometry.attributes.position.array;\r\n        const particleCount = positions.length / 3;\r\n        \r\n        for (let i = 0; i < particleCount; i++) {\r\n            const i3 = i * 3;\r\n            \r\n            // Update position based on velocity\r\n            positions[i3] += this.splashVelocities[i].x;\r\n            positions[i3 + 1] += this.splashVelocities[i].y;\r\n            positions[i3 + 2] += this.splashVelocities[i].z;\r\n            \r\n            // Apply gravity to y velocity\r\n            this.splashVelocities[i].y -= 0.01;\r\n        }\r\n        \r\n        // Update particle opacity based on lifetime\r\n        const progress = this.splashTimer / this.splashLifetime;\r\n        this.splashParticles.material.opacity = 0.8 * (1 - progress);\r\n        \r\n        // Mark the attribute as needing an update\r\n        this.splashParticles.geometry.attributes.position.needsUpdate = true;\r\n    }\r\n    \r\n    /**\r\n     * Create a wake trail behind the boat\r\n     */\r\n    createBoatWake() {\r\n        if (!this.scene) return;\r\n        \r\n        // Create a curved wake trail using a simple mesh\r\n        const wakeWidth = this.width * 1.5;\r\n        const wakeLength = this.length * 4;\r\n        \r\n        // Create wake geometry\r\n        const wakeGeometry = new THREE.PlaneGeometry(wakeWidth, wakeLength, 8, 16);\r\n        \r\n        // Create wake material with transparency\r\n        const wakeMaterial = new THREE.MeshBasicMaterial({\r\n            color: 0xFFFFFF,\r\n            transparent: true,\r\n            opacity: 0.3,\r\n            side: THREE.DoubleSide\r\n        });\r\n        \r\n        // Create wake mesh\r\n        this.wakeMesh = new THREE.Mesh(wakeGeometry, wakeMaterial);\r\n        \r\n        // Position wake behind the boat at water level\r\n        this.wakeMesh.position.y = 0.05; // Slightly above water to avoid z-fighting\r\n        this.wakeMesh.rotation.x = Math.PI / 2; // Lay flat on water\r\n        \r\n        // Add to scene\r\n        this.scene.add(this.wakeMesh);\r\n    }\r\n    \r\n    /**\r\n     * Update the boat wake\r\n     */\r\n    updateBoatWake() {\r\n        if (!this.wakeMesh) return;\r\n        \r\n        // Position wake behind the boat\r\n        const boatPosition = this.position.clone();\r\n        const boatDirection = new THREE.Vector3(0, 0, -1);\r\n        boatDirection.applyQuaternion(this.orientation);\r\n        \r\n        // Offset wake behind the boat\r\n        const wakeOffset = boatDirection.clone().multiplyScalar(-this.length);\r\n        this.wakeMesh.position.copy(boatPosition.clone().add(wakeOffset));\r\n        this.wakeMesh.position.y = 0.05; // Keep at water level\r\n        \r\n        // Orient wake to match boat direction\r\n        this.wakeMesh.quaternion.copy(this.orientation);\r\n        this.wakeMesh.rotation.x = Math.PI / 2; // Make sure it stays flat\r\n        \r\n        // Adjust opacity based on speed\r\n        const maxOpacity = 0.3;\r\n        const speedFactor = Math.min(this.speed / 10, 1); // Max opacity at 10 knots\r\n        this.wakeMesh.material.opacity = maxOpacity * speedFactor;\r\n    }\r\n}\r\n\r\n// Export the Boat class\r\nexport default Boat; ","__webpack_require__.h = () => (\"84c6cb71c815fec3ffbd\")"],"names":[],"sourceRoot":""}