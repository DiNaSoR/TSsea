{"version":3,"file":"main.a5b64e78f5fda7519bb2.hot-update.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACoC,CAAC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,eAAe;AAC9B,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,yCAAyC;AACzC,2BAA2B;AAC3B;AACA;AACA,8BAA8B;AAC9B,4BAA4B;AAC5B;AACA;AACA,0BAA0B;AAC1B,wBAAwB;AACxB;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,gBAAgB;AACvF;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB;AACtB,8CAA8C,YAAY;AAC1D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,oEAAoE,UAAU;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iBAAiB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,iBAAiB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iBAAiB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAoB,CAAC,+CAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,eAAe;AAChC;AACA;AACA;AACA,2BAA2B,+CAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4DAA2B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA,kCAAkC,qDAAoB,CAAC,+CAAc;AACrE;AACA;AACA;AACA;AACA,yBAAyB,2CAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+CAAc;AACnD,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAAW;AAC9B,UAAU;AACV;AACA,mBAAmB,4CAAW;AAC9B;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA,2BAA2B,+CAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,+CAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAc;AACjD;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,+BAA+B,4CAAW;AAC1C;AACA;AACA;AACA,6BAA6B,4CAAW;AACxC;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;;AAEA;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;ACj5BpB;AACA;AACA;AACoC,CAAC;;AAErC;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4CAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE,sEAAsE;AACtE;AACA;AACA;AACA,iCAAiC,4CAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;;;;AClLxB;AACA;AACA;AAC2C;AACN;AACA;AACR;AACO,CAAC;AACwC;;AAE7E;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,mBAAmB;AAClC,eAAe,SAAS;AACxB;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,+BAA+B;AAC/B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAQ;AACpC;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B,uDAAW;AAC1C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAQ;AACpC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gDAAI;AAC7B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iBAAiB;AAC5E;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,iBAAiB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,wCAAwC,gDAAI;AAC5C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4BAA4B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wBAAwB,KAAK,iBAAiB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iDAAgB,sBAAsB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uFAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mCAAmC;AACxF;AACA;AACA;AACA,iDAAiD,iCAAiC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iDAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,4BAA4B,GAAG,0BAA0B,SAAS,2BAA2B,GAAG,iBAAiB;AACpK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;ACpxBpB;AACA;AACA;AACoC,CAAC;AACwC;;AAE7E;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,mBAAmB;AAClC;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,uFAAa;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAe,QAAQ,EAAC;;;;;;;;UCtVxB","sources":["webpack://opensail/./src/js/boat.js","webpack://opensail/./src/js/controls.js","webpack://opensail/./src/js/game.js","webpack://opensail/./src/js/renderer.js","webpack://opensail/webpack/runtime/getFullHash"],"sourcesContent":["/**\n * Boat class to handle boat physics and visualization\n */\nimport * as Utils from './utils.js'; // Import all utility functions as Utils namespace\n\n/**\n * Boat class representing a sailboat in the game\n */\nclass Boat {\n    /**\n     * Create a new Boat\n     * @param {Object} options - Boat configuration options\n     * @param {string} options.id - Unique identifier for the boat\n     * @param {string} options.playerName - Name of the player controlling the boat\n     * @param {THREE.Vector3} options.position - Initial position\n     * @param {THREE.Quaternion} options.orientation - Initial orientation\n     * @param {number} options.length - Boat length in meters\n     * @param {number} options.width - Boat width in meters\n     * @param {THREE.Scene} options.scene - Three.js scene to add the boat to\n     */\n    constructor(options) {\n        this.id = options.id || 'boat_' + Math.random().toString(36).substr(2, 9);\n        this.playerName = options.playerName || 'Player';\n        \n        // Physics properties\n        this.position = options.position || new THREE.Vector3(0, 0, 0);\n        this.orientation = options.orientation || new THREE.Quaternion();\n        this.velocity = new THREE.Vector3(0, 0, 0);\n        this.angularVelocity = new THREE.Vector3(0, 0, 0);\n        \n        // Boat dimensions\n        this.length = options.length || 6; // meters\n        this.width = options.width || 2; // meters\n        this.height = 2.5; // meters\n        \n        // Control properties\n        this.rudderAngle = 0; // degrees, -45 to 45\n        this.sailAngle = 0; // degrees, -90 to 90\n        \n        // Boat state\n        this.heading = 0; // degrees, 0-359\n        this.speed = 0; // knots\n        \n        // Physics constants (will be tuned)\n        this.mass = 1000; // kg\n        this.dragCoefficient = 0.05;\n        this.sailForceCoefficient = 30;\n        this.rudderForceCoefficient = 15;\n        this.lateralResistanceCoefficient = 50;\n        \n        // 3D model properties\n        this.mesh = null;\n        this.scene = options.scene;\n        \n        // Initialize the 3D model\n        this.initMesh();\n    }\n    \n    /**\n     * Initialize the 3D mesh for the boat\n     */\n    initMesh() {\n        try {\n            // Use GLTFLoader for loading .glb models\n            const loader = new GLTFLoader();\n            \n            // Try with multiple path formats\n            const modelPaths = [\n                window.ASSET_PATH.models + 'boat.glb',     // Using configured path\n                '/assets/models/boat.glb',                 // Absolute path from root\n                'assets/models/boat.glb',                  // No leading slash\n                './assets/models/boat.glb'                 // Relative path with dot\n            ];\n            \n            console.log(\"Attempting to load boat model with paths:\", modelPaths);\n            \n            // First check if the file exists using fetch\n            fetch(modelPaths[0])\n                .then(response => {\n                    if (!response.ok) {\n                        throw new Error(`File not accessible (status ${response.status})`);\n                    }\n                    console.log(\"boat.glb is accessible via fetch at:\", modelPaths[0]);\n                    // File exists, proceed with GLTFLoader\n                    return this.loadModelWithLoader(modelPaths[0]);\n                })\n                .catch(error => {\n                    console.error(\"Fetch failed:\", error);\n                    console.log(\"Trying alternate loading methods...\");\n                    this.tryNextPath(modelPaths, 1);\n                });\n                \n            // Create boat wake\n            this.createBoatWake();\n        } catch (e) {\n            console.error(\"Exception in initMesh:\", e);\n            this.createFallbackBoat();\n        }\n    }\n    \n    /**\n     * Load model with GLTFLoader\n     */\n    loadModelWithLoader(modelPath) {\n        const loader = new GLTFLoader();\n        console.log(\"Loading boat model using GLTFLoader with path:\", modelPath);\n        \n        return new Promise((resolve, reject) => {\n            loader.load(\n                modelPath,\n                (gltf) => {\n                    console.log(\"Boat model loaded successfully with path:\", modelPath);\n                    this.mesh = gltf.scene;\n                    \n                    // Log the loaded model structure to help with debugging\n                    console.log(\"GLTF model structure:\", gltf);\n                    \n                    // Set initial position and orientation\n                    this.mesh.position.copy(this.position);\n                    this.mesh.quaternion.copy(this.orientation);\n                    \n                    // Rotate the boat model 180 degrees around the Y axis\n                    this.mesh.rotation.y = Math.PI; // 180 degrees in radians\n                    \n                    // Set a proper scale for the boat\n                    const scale = 0.5; // Start with a moderate scale, adjust based on model size\n                    this.mesh.scale.set(scale, scale, scale);\n                    \n                    // Lower the boat position to reduce hovering\n                    this.mesh.position.y -= 0.5; // Adjust this value as needed\n                    \n                    // Add boat to scene\n                    if (this.scene) {\n                        this.scene.add(this.mesh);\n                        console.log(\"Boat added to scene successfully\");\n                    } else {\n                        console.error(\"Scene not available, cannot add boat mesh\");\n                    }\n                    \n                    // Create player name label\n                    this.createPlayerLabel();\n                    \n                    // Add the sail\n                    this.addSail();\n                    \n                    // Set up shadows\n                    this.setupShadows();\n                    \n                    // Log success\n                    console.log(`Boat for ${this.playerName} loaded`);\n                    resolve(this.mesh);\n                },\n                // onProgress callback\n                (xhr) => {\n                    if (xhr.total && xhr.total > 0) {\n                        console.log((xhr.loaded / xhr.total * 100) + '% of boat model loaded');\n                    } else {\n                        console.log(`Loaded ${xhr.loaded} bytes`);\n                    }\n                },\n                // onError callback\n                (error) => {\n                    console.error(\"GLTFLoader failed with path:\", modelPath, error);\n                    reject(error);\n                }\n            );\n        });\n    }\n    \n    /**\n     * Try loading the model with the next available path\n     */\n    tryNextPath(paths, index) {\n        if (index >= paths.length) {\n            console.error(\"All paths failed, creating fallback boat\");\n            this.createFallbackBoat();\n            return;\n        }\n        \n        const modelPath = paths[index];\n        console.log(\"Trying alternate path:\", modelPath);\n        \n        const loader = new GLTFLoader();\n        loader.load(\n            modelPath,\n            (gltf) => {\n                console.log(\"Boat model loaded successfully with alternate path:\", modelPath);\n                this.mesh = gltf.scene;\n                \n                // Set initial position and orientation\n                this.mesh.position.copy(this.position);\n                this.mesh.quaternion.copy(this.orientation);\n                \n                // Rotate the boat model 180 degrees around the Y axis\n                this.mesh.rotation.y = Math.PI; // 180 degrees in radians\n                \n                // Set a proper scale for the boat\n                const scale = 0.5; // Adjusted scale for better visibility\n                this.mesh.scale.set(scale, scale, scale);\n                \n                // Lower the boat position to reduce hovering\n                this.mesh.position.y -= 0.5; // Adjust this value as needed\n                \n                // Add to scene\n                if (this.scene) {\n                    this.scene.add(this.mesh);\n                    console.log(\"Boat added to scene with alternate path\");\n                } else {\n                    console.error(\"Scene not available for alternate path loading\");\n                }\n                \n                // Create player name label\n                this.createPlayerLabel();\n                \n                // Add the sail\n                this.addSail();\n                \n                // Set up shadows\n                this.setupShadows();\n                \n                // Log success\n                console.log(`Boat for ${this.playerName} loaded with alternate path`);\n            },\n            // onProgress callback\n            (xhr) => {\n                if (xhr.total && xhr.total > 0) {\n                    console.log((xhr.loaded / xhr.total * 100) + '% of boat model loaded (alternate path)');\n                }\n            },\n            // onError callback\n            (error) => {\n                console.error(`Error loading boat model with path ${modelPath}:`, error);\n                // Try the next path\n                this.tryNextPath(paths, index + 1);\n            }\n        );\n    }\n    \n    /**\n     * Load the boat texture (now handled by GLTFLoader for glb files)\n     */\n    loadTexture() {\n        // GLB files already include textures, so this method is not needed\n        // We'll keep it as a placeholder in case custom textures are needed later\n        console.log(\"Using textures embedded in the GLB file\");\n    }\n    \n    /**\n     * Create a simple fallback mesh if the model fails to load\n     */\n    createFallbackBoat() {\n        // Create a simple boat shape using primitive geometries\n        const boatGroup = new THREE.Group();\n        \n        // Hull\n        const hullGeometry = new THREE.BoxGeometry(this.length, this.height / 2, this.width);\n        const hullMaterial = new THREE.MeshPhongMaterial({ color: 0x3366ff });\n        const hull = new THREE.Mesh(hullGeometry, hullMaterial);\n        hull.position.y = -this.height / 4;\n        boatGroup.add(hull);\n        \n        // Cabin\n        const cabinGeometry = new THREE.BoxGeometry(this.length / 3, this.height / 2, this.width * 0.8);\n        const cabinMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });\n        const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);\n        cabin.position.set(0, this.height / 4, 0);\n        boatGroup.add(cabin);\n        \n        // Mast\n        const mastGeometry = new THREE.CylinderGeometry(0.05, 0.05, this.height * 2, 8);\n        const mastMaterial = new THREE.MeshPhongMaterial({ color: 0x999999 });\n        const mast = new THREE.Mesh(mastGeometry, mastMaterial);\n        mast.position.set(0, this.height, 0);\n        boatGroup.add(mast);\n        \n        // Sail\n        this.sail = new THREE.Group();\n        const sailGeometry = new THREE.PlaneGeometry(this.length * 0.7, this.height * 1.5);\n        const sailMaterial = new THREE.MeshPhongMaterial({ \n            color: 0xffffff,\n            side: THREE.DoubleSide\n        });\n        const sailMesh = new THREE.Mesh(sailGeometry, sailMaterial);\n        sailMesh.position.set(this.length * 0.2, 0, 0);\n        sailMesh.rotation.y = Math.PI / 2;\n        this.sail.add(sailMesh);\n        this.sail.position.set(0, this.height * 0.75, 0);\n        boatGroup.add(this.sail);\n        \n        // Center the boat\n        boatGroup.position.copy(this.position);\n        boatGroup.quaternion.copy(this.orientation);\n        \n        // Set as the boat mesh\n        this.mesh = boatGroup;\n        \n        // Add to scene\n        if (this.scene) {\n            this.scene.add(this.mesh);\n        }\n        \n        // Create player name label\n        this.createPlayerLabel();\n        \n        console.log(`Fallback boat for ${this.playerName} created`);\n    }\n    \n    /**\n     * Create a text label showing the player name\n     */\n    createPlayerLabel() {\n        // This would typically use a sprite with a dynamically generated texture\n        // For simplicity, we'll omit the actual implementation for now\n    }\n    \n    /**\n     * Update the boat physics\n     * @param {Object} environment - Environment information including wind and waves\n     * @param {number} deltaTime - Time step in seconds\n     */\n    update(environment, deltaTime) {\n        // Skip physics if deltaTime is too large (e.g., after pausing)\n        if (deltaTime > 0.1) deltaTime = 0.1;\n        \n        // Get environment info\n        const { wind, waves } = environment;\n        \n        // Calculate forces\n        const forces = this.calculateForces(wind, waves);\n        \n        // Apply acceleration based on forces\n        const acceleration = forces.clone().divideScalar(this.mass);\n        \n        // Update velocity (v = v0 + a * t)\n        this.velocity.add(acceleration.clone().multiplyScalar(deltaTime));\n        \n        // Apply drag (simplified)\n        this.velocity.multiplyScalar(1 - this.dragCoefficient * deltaTime);\n        \n        // Update position (p = p0 + v * t)\n        this.position.add(this.velocity.clone().multiplyScalar(deltaTime));\n        \n        // Apply angular velocity\n        const rotationAxis = new THREE.Vector3(0, 1, 0);\n        const rotationAngle = this.angularVelocity.y * deltaTime;\n        const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(rotationAxis, rotationAngle);\n        this.orientation.premultiply(rotationQuaternion);\n        this.orientation.normalize();\n        \n        // Update heading (in degrees)\n        const euler = new THREE.Euler().setFromQuaternion(this.orientation);\n        this.heading = Utils.normalizeAngle(Utils.radToDeg(euler.y) * -1);\n        \n        // Calculate speed in knots (1 m/s ≈ 1.94 knots)\n        this.speed = this.velocity.length() * 1.94;\n        \n        // Create water splash effects when the boat is moving fast enough\n        if (this.speed > 2 && Math.random() < 0.05) {\n            // Create a new splash effect at random intervals\n            if (!this.splashParticles) {\n                this.createWaterSplash();\n            }\n        }\n        \n        // Update existing water splash\n        if (this.splashParticles) {\n            this.updateWaterSplash(deltaTime);\n        }\n        \n        // Update boat wake\n        this.updateBoatWake();\n        \n        // Apply wave effects on boat position and rotation\n        this.applyWaveEffects(waves, deltaTime);\n        \n        // Update 3D model if it exists\n        this.updateMesh();\n        \n        // Return state for networking\n        return {\n            id: this.id,\n            position: this.position.clone(),\n            orientation: this.orientation.clone(),\n            velocity: this.velocity.clone(),\n            angularVelocity: this.angularVelocity.clone(),\n            rudderAngle: this.rudderAngle,\n            sailAngle: this.sailAngle,\n            heading: this.heading,\n            speed: this.speed\n        };\n    }\n    \n    /**\n     * Calculate all forces acting on the boat\n     * @param {Object} wind - Wind information\n     * @param {Object} waves - Wave information\n     * @returns {THREE.Vector3} Net force acting on the boat\n     */\n    calculateForces(wind, waves) {\n        // Convert heading to radians and get direction vector\n        const headingRad = Utils.degToRad(this.heading);\n        const boatDirection = new THREE.Vector3(\n            Math.sin(headingRad),\n            0,\n            Math.cos(headingRad)\n        );\n        \n        // Calculate apparent wind (wind relative to boat)\n        const apparentWind = Utils.calculateApparentWind(\n            new THREE.Vector3(wind.x, wind.y, wind.z),\n            this.velocity\n        );\n        \n        // Calculate sail force\n        const sailForce = this.calculateSailForce(apparentWind, boatDirection);\n        \n        // Calculate rudder force\n        const rudderForce = this.calculateRudderForce(boatDirection);\n        \n        // Calculate lateral resistance (keeps boat from sliding sideways)\n        const lateralResistanceForce = this.calculateLateralResistance();\n        \n        // Sum all forces\n        const netForce = new THREE.Vector3(0, 0, 0)\n            .add(sailForce)\n            .add(rudderForce)\n            .add(lateralResistanceForce);\n            \n        return netForce;\n    }\n    \n    /**\n     * Calculate force generated by the sail\n     * @param {THREE.Vector3} apparentWind - Apparent wind vector\n     * @param {THREE.Vector3} boatDirection - Boat's forward direction\n     * @returns {THREE.Vector3} Sail force\n     */\n    calculateSailForce(apparentWind, boatDirection) {\n        // Calculate relative angle between wind and boat heading\n        const boatAngle = Math.atan2(boatDirection.x, boatDirection.z);\n        const windAngle = Math.atan2(apparentWind.x, apparentWind.z);\n        const relativeWindAngle = Utils.normalizeAngle(Utils.radToDeg(windAngle - boatAngle));\n        \n        // Adjust the sail angle based on relative wind (auto-trim)\n        // In a real implementation, the player would control this\n        const optimalSailAngle = this.calculateOptimalSailAngle(relativeWindAngle);\n        this.sailAngle = Utils.lerp(this.sailAngle, optimalSailAngle, 0.1);\n        \n        // Calculate effective sail angle (relative wind angle - sail angle)\n        const effectiveSailAngle = Math.abs(relativeWindAngle - this.sailAngle);\n        \n        // Calculate sail force coefficient (simplified sail physics)\n        // Max force at ~45 degrees to the wind, minimal when sailing directly into or away from wind\n        let sailForceCoef = Math.sin(Utils.degToRad(effectiveSailAngle) * 2);\n        sailForceCoef = Math.max(0, sailForceCoef); // No negative force\n        \n        // Scale by wind strength\n        const windStrength = apparentWind.length();\n        const forceMagnitude = this.sailForceCoefficient * sailForceCoef * windStrength;\n        \n        // Apply force in boat's forward direction (simplified)\n        return boatDirection.clone().multiplyScalar(forceMagnitude);\n    }\n    \n    /**\n     * Calculate optimal sail angle for current wind\n     * @param {number} relativeWindAngle - Angle between wind and boat heading\n     * @returns {number} Optimal sail angle in degrees\n     */\n    calculateOptimalSailAngle(relativeWindAngle) {\n        // Simplified optimal sail angle calculation\n        // In a real sailing sim, this would be more complex\n        if (relativeWindAngle > 180) {\n            // Wind from port side\n            return Utils.clamp(relativeWindAngle - 180, -80, 0);\n        } else {\n            // Wind from starboard side\n            return Utils.clamp(relativeWindAngle, 0, 80);\n        }\n    }\n    \n    /**\n     * Calculate force generated by the rudder\n     * @param {THREE.Vector3} boatDirection - Boat's forward direction\n     * @returns {THREE.Vector3} Rudder torque as a force\n     */\n    calculateRudderForce(boatDirection) {\n        // Rudder effect increases with boat speed\n        const rudderEffectiveness = this.speed * 0.1;\n        \n        // Calculate angular force from rudder\n        this.angularVelocity.y = this.rudderAngle * this.rudderForceCoefficient * \n                               rudderEffectiveness * 0.001;\n                               \n        // Return zero force (rudder affects angular velocity)\n        return new THREE.Vector3(0, 0, 0);\n    }\n    \n    /**\n     * Calculate lateral resistance force that prevents sideways slipping\n     * @returns {THREE.Vector3} Lateral resistance force\n     */\n    calculateLateralResistance() {\n        // Get boat's right vector\n        const headingRad = Utils.degToRad(this.heading);\n        const rightVector = new THREE.Vector3(\n            -Math.cos(headingRad),\n            0,\n            Math.sin(headingRad)\n        );\n        \n        // Calculate lateral component of velocity\n        const lateralVelocity = rightVector.clone().multiplyScalar(\n            rightVector.dot(this.velocity)\n        );\n        \n        // Apply resistance proportional to lateral velocity\n        return lateralVelocity.clone().multiplyScalar(-this.lateralResistanceCoefficient);\n    }\n    \n    /**\n     * Apply wave effects to the boat\n     * @param {Object} waves - Wave information\n     * @param {number} deltaTime - Time step in seconds\n     */\n    applyWaveEffects(waves, deltaTime) {\n        if (!waves || !waves.isActive) return;\n        \n        // Calculate wave height at boat position\n        const waveHeight = this.calculateWaveHeight(this.position, waves, Date.now() / 1000);\n        \n        // Adjust boat position based on wave height\n        this.position.y = waveHeight;\n        \n        // Calculate wave slope at boat position for pitch and roll\n        const slopeX = this.calculateWaveSlope(this.position, waves, Date.now() / 1000, 'x');\n        const slopeZ = this.calculateWaveSlope(this.position, waves, Date.now() / 1000, 'z');\n        \n        // Apply pitch and roll based on wave slope\n        const targetRotation = new THREE.Quaternion().setFromEuler(\n            new THREE.Euler(-slopeZ * 0.5, Utils.degToRad(this.heading) * -1, slopeX * 0.5)\n        );\n        \n        // Smoothly interpolate rotation\n        this.orientation.slerp(targetRotation, 2 * deltaTime);\n    }\n    \n    /**\n     * Calculate wave height at a given position\n     * @param {THREE.Vector3} position - Position to calculate height at\n     * @param {Object} waves - Wave parameters\n     * @param {number} time - Current time\n     * @returns {number} Wave height\n     */\n    calculateWaveHeight(position, waves, time) {\n        // Simple sin wave function\n        // In a real implementation, would use a sum of multiple sine waves\n        const x = position.x;\n        const z = position.z;\n        const amplitude = waves.amplitude || 0.5;\n        const frequency = waves.frequency || 0.2;\n        const direction = waves.direction || 0;\n        const speed = waves.speed || 1;\n        \n        // Calculate directed coordinates\n        const dirRad = Utils.degToRad(direction);\n        const dx = x * Math.cos(dirRad) + z * Math.sin(dirRad);\n        \n        // Calculate height using sin wave\n        return amplitude * Math.sin(dx * frequency + time * speed);\n    }\n    \n    /**\n     * Calculate wave slope at a given position\n     * @param {THREE.Vector3} position - Position to calculate slope at\n     * @param {Object} waves - Wave parameters\n     * @param {number} time - Current time\n     * @param {string} axis - Axis to calculate slope for ('x' or 'z')\n     * @returns {number} Wave slope\n     */\n    calculateWaveSlope(position, waves, time, axis) {\n        // Sample height at two nearby points to calculate slope\n        const delta = 0.1;\n        let pos1 = position.clone();\n        let pos2 = position.clone();\n        \n        if (axis === 'x') {\n            pos1.x -= delta;\n            pos2.x += delta;\n        } else {\n            pos1.z -= delta;\n            pos2.z += delta;\n        }\n        \n        const height1 = this.calculateWaveHeight(pos1, waves, time);\n        const height2 = this.calculateWaveHeight(pos2, waves, time);\n        \n        return (height2 - height1) / (2 * delta);\n    }\n    \n    /**\n     * Update the 3D mesh based on current state\n     */\n    updateMesh() {\n        if (!this.mesh) return;\n        \n        // Update position and orientation\n        this.mesh.position.copy(this.position);\n        this.mesh.quaternion.copy(this.orientation);\n        \n        // Update sail rotation if we have a sail object\n        if (this.sail) {\n            this.sail.rotation.y = Utils.degToRad(this.sailAngle);\n        }\n    }\n    \n    /**\n     * Set boat controls\n     * @param {Object} controls - Control inputs\n     * @param {number} controls.rudderAngle - Rudder angle (-45 to 45 degrees)\n     * @param {number} controls.sailAngle - Sail angle (-90 to 90 degrees)\n     */\n    setControls(controls) {\n        if (controls.rudderAngle !== undefined) {\n            this.rudderAngle = Utils.clamp(controls.rudderAngle, -45, 45);\n        }\n        \n        if (controls.sailAngle !== undefined) {\n            this.sailAngle = Utils.clamp(controls.sailAngle, -90, 90);\n        }\n    }\n    \n    /**\n     * Handle server update for client-side interpolation\n     * @param {Object} state - Boat state from server\n     */\n    handleServerUpdate(state) {\n        // Update position and orientation for interpolation\n        this.serverPosition = new THREE.Vector3().fromArray(state.position);\n        this.serverOrientation = new THREE.Quaternion(\n            state.orientation[0],\n            state.orientation[1],\n            state.orientation[2],\n            state.orientation[3]\n        );\n        this.serverVelocity = new THREE.Vector3().fromArray(state.velocity);\n        this.heading = state.heading;\n        this.speed = state.speed;\n        \n        // Directly update controls\n        this.sailAngle = state.sailAngle;\n        this.rudderAngle = state.rudderAngle;\n    }\n    \n    /**\n     * Interpolate between current and server state\n     * @param {number} alpha - Interpolation factor (0-1)\n     */\n    interpolate(alpha) {\n        if (!this.serverPosition || !this.serverOrientation) return;\n        \n        // Interpolate position\n        this.position.lerp(this.serverPosition, alpha);\n        \n        // Interpolate orientation\n        this.orientation.slerp(this.serverOrientation, alpha);\n        \n        // Update mesh\n        this.updateMesh();\n    }\n    \n    /**\n     * Remove boat from scene and clean up resources\n     */\n    dispose() {\n        if (this.mesh && this.scene) {\n            this.scene.remove(this.mesh);\n            \n            // Dispose geometries and materials\n            if (this.mesh.traverse) {\n                this.mesh.traverse((child) => {\n                    if (child.geometry) child.geometry.dispose();\n                    if (child.material) {\n                        if (Array.isArray(child.material)) {\n                            child.material.forEach(material => material.dispose());\n                        } else {\n                            child.material.dispose();\n                        }\n                    }\n                });\n            }\n        }\n    }\n    \n    /**\n     * Add a sail to the loaded boat model\n     * For GLB models, this is optional as the model may already have a sail\n     */\n    addSail() {\n        // Check if we're using a fallback boat (which already has a sail added in createFallbackBoat)\n        if (this.sail) {\n            console.log(\"Sail already exists on the boat\");\n            return;\n        }\n\n        console.log(\"Adding sail to loaded boat model\");\n        \n        // Create a sail group\n        this.sail = new THREE.Group();\n        \n        // Check if we're using a loaded model or need to create a sail\n        if (this.mesh && this.mesh.type === \"Group\") {\n            // For loaded models, we'll first check if it already has a sail\n            let existingSail = false;\n            this.mesh.traverse(child => {\n                // Look for parts that might be a sail based on name or position\n                if (child.name && child.name.toLowerCase().includes('sail')) {\n                    console.log(\"Found existing sail in the model:\", child.name);\n                    existingSail = true;\n                }\n            });\n            \n            if (existingSail) {\n                console.log(\"Using existing sail from the 3D model\");\n                return;\n            }\n            \n            // If no sail found, create a simple one\n            const sailGeometry = new THREE.PlaneGeometry(this.length * 0.7, this.height * 1.5);\n            const sailMaterial = new THREE.MeshPhongMaterial({ \n                color: 0xffffff,\n                side: THREE.DoubleSide\n            });\n            const sailMesh = new THREE.Mesh(sailGeometry, sailMaterial);\n            sailMesh.position.set(0, this.height * 0.75, 0);\n            sailMesh.rotation.y = Math.PI / 2;\n            this.sail.add(sailMesh);\n            \n            // Add the sail to the boat mesh\n            this.mesh.add(this.sail);\n            console.log(\"Added new sail to the boat model\");\n        }\n    }\n    \n    /**\n     * Set up shadows for the boat\n     */\n    setupShadows() {\n        if (!this.mesh) return;\n        \n        // Add shadow casting/receiving to all meshes\n        this.mesh.traverse(child => {\n            if (child.isMesh) {\n                child.castShadow = true;\n                child.receiveShadow = true;\n            }\n        });\n        \n        console.log(\"Shadows set up for the boat\");\n    }\n    \n    /**\n     * Create a water splash effect\n     */\n    createWaterSplash() {\n        if (!this.scene) return;\n        \n        // Create a splash particle system\n        const splashGeometry = new THREE.BufferGeometry();\n        const splashMaterial = new THREE.PointsMaterial({\n            color: 0xFFFFFF,\n            size: 0.1,\n            transparent: true,\n            opacity: 0.8\n        });\n        \n        // Create particles\n        const particleCount = 50;\n        const positions = new Float32Array(particleCount * 3);\n        \n        // Initialize particles at the boat position\n        for (let i = 0; i < particleCount; i++) {\n            const i3 = i * 3;\n            positions[i3] = this.position.x + (Math.random() - 0.5) * this.width * 0.5;\n            positions[i3 + 1] = 0; // At water level\n            positions[i3 + 2] = this.position.z + (Math.random() - 0.5) * this.length * 0.5;\n        }\n        \n        splashGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n        \n        // Create the particle system\n        this.splashParticles = new THREE.Points(splashGeometry, splashMaterial);\n        this.scene.add(this.splashParticles);\n        \n        // Store particle velocities\n        this.splashVelocities = [];\n        for (let i = 0; i < particleCount; i++) {\n            this.splashVelocities.push({\n                x: (Math.random() - 0.5) * 0.1,\n                y: Math.random() * 0.2,\n                z: (Math.random() - 0.5) * 0.1\n            });\n        }\n        \n        // Set splash lifetime\n        this.splashLifetime = 1; // seconds\n        this.splashTimer = 0;\n    }\n    \n    /**\n     * Update the water splash effect\n     * @param {number} deltaTime - Time since last update in seconds\n     */\n    updateWaterSplash(deltaTime) {\n        if (!this.splashParticles) return;\n        \n        // Increment splash timer\n        this.splashTimer += deltaTime;\n        \n        // If the splash has lived its lifetime, remove it\n        if (this.splashTimer >= this.splashLifetime) {\n            this.scene.remove(this.splashParticles);\n            this.splashParticles.geometry.dispose();\n            this.splashParticles.material.dispose();\n            this.splashParticles = null;\n            this.splashVelocities = null;\n            return;\n        }\n        \n        // Update particle positions based on velocity\n        const positions = this.splashParticles.geometry.attributes.position.array;\n        const particleCount = positions.length / 3;\n        \n        for (let i = 0; i < particleCount; i++) {\n            const i3 = i * 3;\n            \n            // Update position based on velocity\n            positions[i3] += this.splashVelocities[i].x;\n            positions[i3 + 1] += this.splashVelocities[i].y;\n            positions[i3 + 2] += this.splashVelocities[i].z;\n            \n            // Apply gravity to y velocity\n            this.splashVelocities[i].y -= 0.01;\n        }\n        \n        // Update particle opacity based on lifetime\n        const progress = this.splashTimer / this.splashLifetime;\n        this.splashParticles.material.opacity = 0.8 * (1 - progress);\n        \n        // Mark the attribute as needing an update\n        this.splashParticles.geometry.attributes.position.needsUpdate = true;\n    }\n    \n    /**\n     * Create a wake trail behind the boat\n     */\n    createBoatWake() {\n        if (!this.scene) return;\n        \n        // Create a curved wake trail using a simple mesh\n        const wakeWidth = this.width * 1.5;\n        const wakeLength = this.length * 4;\n        \n        // Create wake geometry\n        const wakeGeometry = new THREE.PlaneGeometry(wakeWidth, wakeLength, 8, 16);\n        \n        // Create wake material with transparency\n        const wakeMaterial = new THREE.MeshBasicMaterial({\n            color: 0xFFFFFF,\n            transparent: true,\n            opacity: 0.3,\n            side: THREE.DoubleSide\n        });\n        \n        // Create wake mesh\n        this.wakeMesh = new THREE.Mesh(wakeGeometry, wakeMaterial);\n        \n        // Position wake behind the boat at water level\n        this.wakeMesh.position.y = 0.05; // Slightly above water to avoid z-fighting\n        this.wakeMesh.rotation.x = Math.PI / 2; // Lay flat on water\n        \n        // Add to scene\n        this.scene.add(this.wakeMesh);\n    }\n    \n    /**\n     * Update the boat wake\n     */\n    updateBoatWake() {\n        if (!this.wakeMesh) return;\n        \n        // Position wake behind the boat\n        const boatPosition = this.position.clone();\n        const boatDirection = new THREE.Vector3(0, 0, -1);\n        boatDirection.applyQuaternion(this.orientation);\n        \n        // Offset wake behind the boat\n        const wakeOffset = boatDirection.clone().multiplyScalar(-this.length);\n        this.wakeMesh.position.copy(boatPosition.clone().add(wakeOffset));\n        this.wakeMesh.position.y = 0.05; // Keep at water level\n        \n        // Orient wake to match boat direction\n        this.wakeMesh.quaternion.copy(this.orientation);\n        this.wakeMesh.rotation.x = Math.PI / 2; // Make sure it stays flat\n        \n        // Adjust opacity based on speed\n        const maxOpacity = 0.3;\n        const speedFactor = Math.min(this.speed / 10, 1); // Max opacity at 10 knots\n        this.wakeMesh.material.opacity = maxOpacity * speedFactor;\n    }\n}\n\n// Export the Boat class\nexport default Boat; ","/**\n * Controls class to handle user input\n */\nimport * as Utils from './utils.js'; // Import all utility functions as Utils namespace\n\nclass Controls {\n    /**\n     * Create a new Controls instance\n     * @param {Object} options - Controls configuration options\n     * @param {Function} options.onControlsChange - Callback for control changes\n     */\n    constructor(options = {}) {\n        // Control state\n        this.state = {\n            rudderAngle: 0, // -45 to 45 degrees\n            sailAngle: 0, // -90 to 90 degrees\n            throttle: 0, // 0 to 1 (for motor, if implemented)\n            cameraView: 'orbit', // Only orbit mode is now used\n            trim: 0, // Auto-trim control (0-1)\n        };\n        \n        // Control sensitivity\n        this.rudderSensitivity = 5; // Degrees per keypress/update\n        this.sailSensitivity = 10; // Degrees per keypress/update\n        \n        // Keys currently pressed\n        this.keys = {};\n        \n        // Callback when controls change\n        this.onControlsChange = options.onControlsChange || (() => {});\n        \n        // Bind methods\n        this.handleKeyDown = this.handleKeyDown.bind(this);\n        this.handleKeyUp = this.handleKeyUp.bind(this);\n        this.update = this.update.bind(this);\n        \n        // Set up event listeners\n        this.setupEventListeners();\n    }\n    \n    /**\n     * Set up event listeners for keyboard and touch\n     */\n    setupEventListeners() {\n        // Keyboard events\n        window.addEventListener('keydown', this.handleKeyDown);\n        window.addEventListener('keyup', this.handleKeyUp);\n        \n        // We could add touch/gamepad controls later\n    }\n    \n    /**\n     * Handle key down events\n     * @param {KeyboardEvent} event - Keyboard event\n     */\n    handleKeyDown(event) {\n        this.keys[event.key] = true;\n        \n        // Prevent default for game control keys\n        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd'].includes(event.key)) {\n            event.preventDefault();\n        }\n        \n        // Camera view changes - removed since we only use orbit mode now\n    }\n    \n    /**\n     * Handle key up events\n     * @param {KeyboardEvent} event - Keyboard event\n     */\n    handleKeyUp(event) {\n        this.keys[event.key] = false;\n    }\n    \n    /**\n     * Update controls based on current key state\n     * @param {number} deltaTime - Time since last update in seconds\n     */\n    update(deltaTime) {\n        let controlsChanged = false;\n        \n        // Calculate rudder input from keyboard\n        let rudderInput = 0;\n        if (this.keys['ArrowLeft'] || this.keys['a']) rudderInput -= 1;\n        if (this.keys['ArrowRight'] || this.keys['d']) rudderInput += 1;\n        \n        // Apply rudder input\n        if (rudderInput !== 0) {\n            const newRudderAngle = Utils.clamp(\n                this.state.rudderAngle + rudderInput * this.rudderSensitivity,\n                -45,\n                45\n            );\n            \n            if (newRudderAngle !== this.state.rudderAngle) {\n                this.state.rudderAngle = newRudderAngle;\n                controlsChanged = true;\n            }\n        } else {\n            // Return rudder to center when not actively turning\n            if (this.state.rudderAngle !== 0) {\n                const returnRate = 15 * deltaTime; // Degrees per second\n                \n                if (Math.abs(this.state.rudderAngle) < returnRate) {\n                    this.state.rudderAngle = 0;\n                } else if (this.state.rudderAngle > 0) {\n                    this.state.rudderAngle -= returnRate;\n                } else {\n                    this.state.rudderAngle += returnRate;\n                }\n                \n                controlsChanged = true;\n            }\n        }\n        \n        // Calculate sail input from keyboard\n        let sailInput = 0;\n        if (this.keys['ArrowUp'] || this.keys['w']) sailInput -= 1; // Tighten sail\n        if (this.keys['ArrowDown'] || this.keys['s']) sailInput += 1; // Loosen sail\n        \n        // Apply sail input\n        if (sailInput !== 0) {\n            const newSailAngle = Utils.clamp(\n                this.state.sailAngle + sailInput * this.sailSensitivity,\n                -90,\n                90\n            );\n            \n            if (newSailAngle !== this.state.sailAngle) {\n                this.state.sailAngle = newSailAngle;\n                controlsChanged = true;\n            }\n        }\n        \n        // Notify if controls changed\n        if (controlsChanged) {\n            this.notifyControlChange();\n        }\n    }\n    \n    /**\n     * Notify callback about control changes\n     */\n    notifyControlChange() {\n        this.onControlsChange({\n            rudderAngle: this.state.rudderAngle,\n            sailAngle: this.state.sailAngle,\n            throttle: this.state.throttle,\n            cameraView: this.state.cameraView,\n            trim: this.state.trim,\n        });\n    }\n    \n    /**\n     * Reset controls to default state\n     */\n    reset() {\n        this.state = {\n            rudderAngle: 0,\n            sailAngle: 0,\n            throttle: 0,\n            cameraView: 'orbit',\n            trim: 0,\n        };\n        \n        this.notifyControlChange();\n    }\n    \n    /**\n     * Clean up by removing event listeners\n     */\n    dispose() {\n        window.removeEventListener('keydown', this.handleKeyDown);\n        window.removeEventListener('keyup', this.handleKeyUp);\n    }\n}\n\n// Export the Controls class\nexport default Controls; ","/**\n * Game class to manage the overall game state and coordinate components\n */\nimport Environment from './environment.js';\nimport Renderer from './renderer.js';\nimport Controls from './controls.js';\nimport Boat from './boat.js';\nimport * as Utils from './utils.js'; // Import all utility functions as Utils namespace\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\n\nclass Game {\n    /**\n     * Create a new Game\n     * @param {Object} options - Game configuration options\n     * @param {HTMLCanvasElement} options.canvas - Canvas element for rendering\n     * @param {boolean} options.debug - Enable debug features\n     */\n    constructor(options = {}) {\n        this.canvas = options.canvas;\n        this.debug = options.debug || false;\n        \n        // Game objects\n        this.renderer = null;\n        this.environment = null;\n        this.boats = new Map(); // Map of boat id to boat object\n        this.localBoat = null; // Reference to the player's boat\n        this.controls = null;\n        this.course = null; // Will store race course data\n        \n        // Game state\n        this.state = {\n            isRunning: false,\n            isPaused: false,\n            raceStarted: false,\n            raceFinished: false,\n            raceTime: 0,\n            timeOfDay: 12, // Noon by default\n        };\n        \n        // Game configuration\n        this.config = {\n            boatCount: 1, // Number of boats (default single player)\n            initialPosition: new THREE.Vector3(0, 0, 0),\n            timeScale: 1, // For speeding up or slowing down physics\n        };\n        \n        // Multiplayer settings\n        this.multiplayer = {\n            enabled: false,\n            socket: null,\n            playerId: null,\n            serverUpdateRate: 20, // Hz\n            interpolation: true,\n            playerName: 'Player',\n        };\n        \n        // Initialize components\n        this.init();\n    }\n    \n    /**\n     * Initialize game components\n     */\n    init() {\n        console.log('Initializing game...');\n        \n        // Create renderer\n        this.renderer = new Renderer({\n            canvas: this.canvas,\n            debug: this.debug,\n        });\n        \n        // Create environment\n        this.environment = new Environment({\n            scene: this.renderer.scene,\n        });\n        \n        // Set environment in renderer for time of day effects\n        this.renderer.setEnvironment(this.environment);\n        \n        // Create controls\n        this.controls = new Controls({\n            onControlsChange: (controls) => this.handleControlsChange(controls),\n        });\n        \n        // Set up loading screen\n        this.showLoadingScreen();\n        \n        // Set up menu event listeners\n        this.setupMenuListeners();\n    }\n    \n    /**\n     * Show the loading screen\n     */\n    showLoadingScreen() {\n        const loadingScreen = document.getElementById('loading-screen');\n        const loadingBar = document.getElementById('loading-bar');\n        \n        if (loadingScreen) {\n            loadingScreen.style.display = 'flex';\n        }\n        \n        // Simulate loading progress\n        let progress = 0;\n        const loadingInterval = setInterval(() => {\n            progress += 5;\n            if (loadingBar) {\n                loadingBar.style.width = `${progress}%`;\n            }\n            \n            if (progress >= 100) {\n                clearInterval(loadingInterval);\n                // Show menu after loading\n                this.hideLoadingScreen();\n                this.showMenu();\n            }\n        }, 100);\n    }\n    \n    /**\n     * Hide the loading screen\n     */\n    hideLoadingScreen() {\n        const loadingScreen = document.getElementById('loading-screen');\n        if (loadingScreen) {\n            loadingScreen.style.display = 'none';\n        }\n    }\n    \n    /**\n     * Show the game menu\n     */\n    showMenu() {\n        const menu = document.getElementById('game-menu');\n        if (menu) {\n            menu.style.display = 'flex';\n        }\n    }\n    \n    /**\n     * Hide the game menu\n     */\n    hideMenu() {\n        const menu = document.getElementById('game-menu');\n        if (menu) {\n            menu.style.display = 'none';\n        }\n    }\n    \n    /**\n     * Set up menu button listeners\n     */\n    setupMenuListeners() {\n        const startButton = document.getElementById('start-game');\n        if (startButton) {\n            startButton.addEventListener('click', () => {\n                this.multiplayer.enabled = false;\n                this.hideMenu();\n                this.startSinglePlayer();\n            });\n        }\n        \n        const joinButton = document.getElementById('join-game');\n        if (joinButton) {\n            joinButton.addEventListener('click', () => {\n                this.multiplayer.enabled = true;\n                this.hideMenu();\n                this.startMultiplayer();\n            });\n        }\n        \n        // Update player name when input changes\n        const playerNameInput = document.getElementById('player-name');\n        if (playerNameInput) {\n            playerNameInput.addEventListener('input', (e) => {\n                this.multiplayer.playerName = e.target.value || 'Player';\n            });\n        }\n    }\n    \n    /**\n     * Start a single player game\n     */\n    startSinglePlayer() {\n        console.log('Starting single player game...');\n        \n        // Create a boat for the player\n        this.createLocalBoat();\n        \n        // Set up camera in orbit mode\n        this.setCameraView('orbit');\n        \n        // Set up a simple race course\n        this.setupRaceCourse();\n        \n        // Start the game loop\n        this.start();\n    }\n    \n    /**\n     * Start a multiplayer game\n     */\n    startMultiplayer() {\n        console.log('Starting multiplayer game...');\n        \n        // Connect to the server\n        this.connectToServer();\n        \n        // The rest will be handled by the server connection\n    }\n    \n    /**\n     * Create the local player's boat\n     */\n    createLocalBoat() {\n        const boat = new Boat({\n            id: 'local_player',\n            playerName: this.multiplayer.playerName,\n            position: this.config.initialPosition.clone(),\n            orientation: new THREE.Quaternion(),\n            scene: this.renderer.scene,\n        });\n        \n        this.boats.set(boat.id, boat);\n        this.localBoat = boat;\n        \n        // Update UI with player name\n        this.updatePlayerInfo();\n    }\n    \n    /**\n     * Set up a basic race course\n     */\n    setupRaceCourse() {\n        // Define a simple triangular course with start/finish line and buoys\n        this.course = {\n            startPosition: new THREE.Vector3(0, 0, 0),\n            buoys: [\n                { \n                    position: new THREE.Vector3(100, 0, 0),\n                    passed: false,\n                    mesh: null\n                },\n                { \n                    position: new THREE.Vector3(50, 0, 100),\n                    passed: false,\n                    mesh: null\n                },\n                { \n                    position: new THREE.Vector3(-50, 0, 50),\n                    passed: false,\n                    mesh: null\n                }\n            ],\n            finishPosition: new THREE.Vector3(0, 0, 0),\n            currentBuoy: 0,\n            laps: 1,\n            currentLap: 0,\n        };\n        \n        // Create visual markers for the course\n        this.createCourseMarkers();\n    }\n    \n    /**\n     * Create visual markers for the race course\n     */\n    createCourseMarkers() {\n        // Create buoys\n        const buoyGeometry = new THREE.SphereGeometry(2, 16, 16);\n        const buoyMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });\n        \n        this.course.buoys.forEach((buoy, index) => {\n            const buoyMesh = new THREE.Mesh(buoyGeometry, buoyMaterial);\n            buoyMesh.position.copy(buoy.position);\n            buoyMesh.position.y = 2; // Raise above water\n            this.renderer.scene.add(buoyMesh);\n            \n            // Store reference to the mesh\n            buoy.mesh = buoyMesh;\n            \n            // Add a pole\n            const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 8);\n            const poleMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });\n            const pole = new THREE.Mesh(poleGeometry, poleMaterial);\n            pole.position.set(0, -1.5, 0);\n            buoyMesh.add(pole);\n            \n            // Add buoy number\n            // In a real implementation, we would add a sprite with text\n        });\n        \n        // Create start/finish line\n        const lineGeometry = new THREE.BoxGeometry(20, 0.5, 2);\n        const lineMaterial = new THREE.MeshPhongMaterial({ \n            color: 0xffffff,\n            transparent: true,\n            opacity: 0.7,\n        });\n        const startLine = new THREE.Mesh(lineGeometry, lineMaterial);\n        startLine.position.copy(this.course.startPosition);\n        startLine.position.y = 0.3; // Slightly above water\n        this.renderer.scene.add(startLine);\n    }\n    \n    /**\n     * Connect to multiplayer server\n     */\n    connectToServer() {\n        // Create a socket.io connection using our socketConnect helper\n        this.multiplayer.socket = window.socketConnect();\n        \n        // Set up socket event handlers\n        this.setupSocketHandlers();\n    }\n    \n    /**\n     * Set up socket.io event handlers\n     */\n    setupSocketHandlers() {\n        const socket = this.multiplayer.socket;\n        \n        // Handle connection\n        socket.on('connect', () => {\n            console.log('Connected to server');\n            \n            // Send player info to server\n            socket.emit('player_join', {\n                name: this.multiplayer.playerName\n            });\n        });\n        \n        // Handle player ID assignment\n        socket.on('player_id', (data) => {\n            console.log('Received player ID:', data.id);\n            this.multiplayer.playerId = data.id;\n            \n            // Create local boat with assigned ID\n            this.createLocalBoat();\n            \n            // Set up camera to follow the player's boat\n            this.renderer.setupBoatCamera(this.localBoat);\n        });\n        \n        // Handle game state update from server\n        socket.on('game_state', (data) => {\n            // Update game state\n            this.state.raceStarted = data.raceStarted;\n            this.state.raceFinished = data.raceFinished;\n            this.state.raceTime = data.raceTime;\n            \n            // Update environment\n            if (data.environment) {\n                this.environment.handleServerUpdate(data.environment);\n            }\n            \n            // Update boats\n            if (data.boats) {\n                this.updateBoatsFromServer(data.boats);\n            }\n            \n            // Check if the game is now running\n            if (!this.state.isRunning && data.raceStarted) {\n                this.start();\n            }\n        });\n        \n        // Handle disconnection\n        socket.on('disconnect', () => {\n            console.log('Disconnected from server');\n            \n            // Handle disconnection (e.g., show a message, return to menu)\n            this.stop();\n            this.showMenu();\n        });\n    }\n    \n    /**\n     * Update boats from server data\n     * @param {Array} boatData - Array of boat states from server\n     */\n    updateBoatsFromServer(boatData) {\n        // Process each boat in the server data\n        boatData.forEach(serverBoat => {\n            const boatId = serverBoat.id;\n            \n            if (boatId === this.multiplayer.playerId) {\n                // This is our boat - only update if significant drift\n                // Client prediction would normally handle our movement\n                if (this.localBoat) {\n                    // For now, just apply server state - replace with proper reconciliation later\n                    this.localBoat.handleServerUpdate(serverBoat);\n                }\n            } else {\n                // This is another player's boat\n                if (this.boats.has(boatId)) {\n                    // Update existing boat\n                    this.boats.get(boatId).handleServerUpdate(serverBoat);\n                } else {\n                    // Create new boat\n                    const newBoat = new Boat({\n                        id: boatId,\n                        playerName: serverBoat.playerName || 'Other Player',\n                        scene: this.renderer.scene,\n                    });\n                    \n                    // Apply server state\n                    newBoat.handleServerUpdate(serverBoat);\n                    \n                    // Add to boats collection\n                    this.boats.set(boatId, newBoat);\n                }\n            }\n        });\n        \n        // Check for boats that no longer exist on server (player left)\n        this.boats.forEach((boat, id) => {\n            const stillExists = boatData.some(serverBoat => serverBoat.id === id);\n            \n            if (!stillExists && id !== this.multiplayer.playerId) {\n                // Remove boat that's no longer on the server\n                boat.dispose();\n                this.boats.delete(id);\n            }\n        });\n    }\n    \n    /**\n     * Start the game\n     */\n    start() {\n        if (this.state.isRunning) return;\n        \n        console.log('Starting game...');\n        \n        // Set game state\n        this.state.isRunning = true;\n        this.state.isPaused = false;\n        \n        // Start the renderer\n        this.renderer.start((deltaTime) => this.update(deltaTime));\n        \n        // Hide UI elements\n        this.hideMenu();\n        \n        // Update UI\n        this.updateUI();\n    }\n    \n    /**\n     * Update game state\n     * @param {number} deltaTime - Time since last update in seconds\n     */\n    update(deltaTime) {\n        if (!this.state.isRunning || this.state.isPaused) return;\n        \n        // Scale delta time to limit physics issues on slow framerates\n        const scaledDeltaTime = Math.min(deltaTime, 0.033);\n        \n        // Update controls\n        this.controls.update(scaledDeltaTime);\n        \n        // Update environment\n        const environmentState = this.environment.update(scaledDeltaTime);\n        \n        // Update all boats\n        this.boats.forEach(boat => {\n            boat.update(environmentState, scaledDeltaTime);\n        });\n        \n        // Check boat position against course markers\n        if (this.localBoat && this.course) {\n            this.checkCourseProgress();\n        }\n        \n        // Update camera if following a boat\n        this.renderer.updateBoatCamera();\n        \n        // Update UI\n        this.updateUI();\n        \n        // Send updates to server if in multiplayer mode\n        if (this.multiplayer.enabled && this.multiplayer.socket && this.localBoat) {\n            this.sendUpdatesToServer();\n        }\n        \n        // Update race time if race started\n        if (this.state.raceStarted && !this.state.raceFinished) {\n            this.state.raceTime += scaledDeltaTime;\n        }\n    }\n    \n    /**\n     * Check the player's progress on the race course\n     */\n    checkCourseProgress() {\n        if (!this.localBoat || !this.course) return;\n        \n        // Get the next buoy to pass\n        const nextBuoy = this.course.buoys[this.course.currentBuoy];\n        \n        // Check distance to next buoy\n        const distance = this.localBoat.position.distanceTo(nextBuoy.position);\n        \n        // If close enough to the buoy, mark it as passed\n        if (distance < 10 && !nextBuoy.passed) {\n            console.log(`Passed buoy ${this.course.currentBuoy + 1}`);\n            nextBuoy.passed = true;\n            \n            // Change buoy color to green to indicate it's been passed\n            if (nextBuoy.mesh) {\n                nextBuoy.mesh.material.color.set(0x00ff00);\n            }\n            \n            // Move to next buoy\n            this.course.currentBuoy = (this.course.currentBuoy + 1) % this.course.buoys.length;\n            \n            // If we've completed a lap\n            if (this.course.currentBuoy === 0) {\n                this.course.currentLap++;\n                console.log(`Completed lap ${this.course.currentLap} of ${this.course.laps}`);\n                \n                // Reset buoys for next lap\n                if (this.course.currentLap < this.course.laps) {\n                    this.course.buoys.forEach(buoy => {\n                        buoy.passed = false;\n                        if (buoy.mesh) {\n                            buoy.mesh.material.color.set(0xff0000);\n                        }\n                    });\n                } else {\n                    // Race finished\n                    this.finishRace();\n                }\n            }\n            \n            // Update UI\n            this.updateCourseInfo();\n        }\n    }\n    \n    /**\n     * Handle race finish\n     */\n    finishRace() {\n        console.log('Race finished!');\n        this.state.raceFinished = true;\n        \n        // Show race results\n        this.showRaceResults();\n    }\n    \n    /**\n     * Show race results\n     */\n    showRaceResults() {\n        // In a real implementation, this would display a UI with race results\n        alert(`Race Finished! Time: ${Utils.formatTime(this.state.raceTime)}`);\n    }\n    \n    /**\n     * Send local boat updates to the server\n     */\n    sendUpdatesToServer() {\n        if (!this.multiplayer.socket || !this.localBoat) return;\n        \n        // Get boat state\n        const boatState = this.localBoat.update(\n            this.environment.update(0), // Get current environment without updating\n            0 // Don't update physics again\n        );\n        \n        // Send boat state to server\n        this.multiplayer.socket.emit('boat_update', boatState);\n    }\n    \n    /**\n     * Handle controls changes from the Controls class\n     * @param {Object} controls - Current control state\n     */\n    handleControlsChange(controls) {\n        // Apply controls to local boat\n        if (this.localBoat) {\n            this.localBoat.rudderAngle = controls.rudderAngle;\n            this.localBoat.sailAngle = controls.sailAngle;\n            this.localBoat.throttle = controls.throttle;\n        }\n        \n        // We no longer need to handle camera view changes since we only use orbit mode\n    }\n    \n    /**\n     * Set camera view\n     * @param {string} view - Camera view type\n     */\n    setCameraView(view) {\n        if (!this.renderer || !this.localBoat) return;\n        \n        // We only support orbit mode now\n        this.currentCameraView = 'orbit';\n        \n        // Set up OrbitControls centered on the boat\n        if (this.renderer.controls) {\n            this.renderer.controls.dispose();\n        }\n        \n        // Use OrbitControls directly (not through THREE namespace)\n        this.renderer.controls = new OrbitControls(\n            this.renderer.camera,\n            this.renderer.canvas\n        );\n        \n        // Prevent the context menu on right-click\n        this.renderer.canvas.addEventListener('contextmenu', (e) => {\n            e.preventDefault();\n        }, false);\n        \n        // Configure the orbit controls for a boat-centric view\n        this.renderer.controls.enableDamping = true;\n        this.renderer.controls.dampingFactor = 0.1;\n        this.renderer.controls.rotateSpeed = 0.7;\n        this.renderer.controls.minDistance = 5;\n        this.renderer.controls.maxDistance = 50;\n        this.renderer.followBoatMode = true;\n        \n        // Set initial camera position relative to the boat\n        const boatPosition = this.localBoat.position.clone();\n        this.renderer.camera.position.set(\n            boatPosition.x - 10,\n            boatPosition.y + 8,\n            boatPosition.z - 10\n        );\n        \n        // Set target to the boat\n        this.renderer.controls.target.copy(boatPosition);\n        \n        // Make sure controls are updated immediately\n        this.renderer.controls.update();\n    }\n    \n    /**\n     * Update the UI with current game state\n     */\n    updateUI() {\n        this.updateWindIndicator();\n        this.updateBoatInfo();\n        this.updateRaceInfo();\n    }\n    \n    /**\n     * Update the wind indicator in the UI\n     */\n    updateWindIndicator() {\n        const windArrow = document.getElementById('wind-arrow');\n        const windSpeed = document.getElementById('wind-speed');\n        \n        if (windArrow && this.environment) {\n            // Rotate arrow to point in wind direction\n            windArrow.style.transform = `rotate(${this.environment.wind.direction}deg)`;\n        }\n        \n        if (windSpeed && this.environment) {\n            // Display wind speed in knots (1 m/s ≈ 1.94 knots)\n            const knotsSpeed = (this.environment.wind.speed * 1.94).toFixed(1);\n            windSpeed.textContent = `${knotsSpeed} knots`;\n        }\n    }\n    \n    /**\n     * Update boat information in the UI\n     */\n    updateBoatInfo() {\n        const headingElement = document.getElementById('heading');\n        const speedElement = document.getElementById('speed');\n        \n        if (headingElement && this.localBoat) {\n            headingElement.textContent = `Heading: ${Math.round(this.localBoat.heading)}°`;\n        }\n        \n        if (speedElement && this.localBoat) {\n            speedElement.textContent = `Speed: ${this.localBoat.speed.toFixed(1)} knots`;\n        }\n    }\n    \n    /**\n     * Update race information in the UI\n     */\n    updateRaceInfo() {\n        const positionElement = document.getElementById('position');\n        const timerElement = document.getElementById('timer');\n        \n        if (positionElement) {\n            // In multiplayer, this would show race position\n            positionElement.textContent = 'Position: 1/1';\n        }\n        \n        if (timerElement) {\n            timerElement.textContent = Utils.formatTime(this.state.raceTime);\n        }\n    }\n    \n    /**\n     * Update course information in the UI\n     */\n    updateCourseInfo() {\n        const positionElement = document.getElementById('position');\n        \n        if (positionElement && this.course) {\n            positionElement.textContent = `Buoy: ${this.course.currentBuoy + 1}/${this.course.buoys.length} - Lap: ${this.course.currentLap + 1}/${this.course.laps}`;\n        }\n    }\n    \n    /**\n     * Update player information in the UI\n     */\n    updatePlayerInfo() {\n        // In a real implementation, this would update player-specific UI elements\n    }\n    \n    /**\n     * Stop the game\n     */\n    stop() {\n        if (!this.state.isRunning) return;\n        \n        console.log('Stopping game...');\n        \n        // Stop the renderer\n        this.renderer.stop();\n        \n        // Set game state\n        this.state.isRunning = false;\n        \n        // Disconnect multiplayer if active\n        if (this.multiplayer.enabled && this.multiplayer.socket) {\n            this.multiplayer.socket.disconnect();\n        }\n    }\n    \n    /**\n     * Pause the game\n     */\n    pause() {\n        if (!this.state.isRunning || this.state.isPaused) return;\n        \n        console.log('Pausing game...');\n        this.state.isPaused = true;\n    }\n    \n    /**\n     * Resume the game\n     */\n    resume() {\n        if (!this.state.isRunning || !this.state.isPaused) return;\n        \n        console.log('Resuming game...');\n        this.state.isPaused = false;\n    }\n    \n    /**\n     * Clean up resources\n     */\n    dispose() {\n        this.stop();\n        \n        // Clean up all boats\n        this.boats.forEach(boat => boat.dispose());\n        this.boats.clear();\n        \n        // Clean up environment\n        if (this.environment) {\n            this.environment.dispose();\n        }\n        \n        // Clean up renderer\n        if (this.renderer) {\n            this.renderer.dispose();\n        }\n        \n        // Clean up controls\n        if (this.controls) {\n            this.controls.dispose();\n        }\n    }\n}\n\n// Export the Game class for use in other modules\nexport default Game; ","/**\n * Renderer class to handle THREE.js setup and rendering\n */\nimport * as Utils from './utils.js'; // Import all utility functions as Utils namespace\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\n\n/**\n * Renderer class to handle all rendering and camera logic\n */\nclass Renderer {\n    /**\n     * Create a new Renderer\n     * @param {Object} options - Renderer configuration options\n     * @param {HTMLCanvasElement} options.canvas - Canvas element to render to\n     */\n    constructor(options = {}) {\n        this.canvas = options.canvas || document.createElement('canvas');\n        this.width = this.canvas.clientWidth;\n        this.height = this.canvas.clientHeight;\n        \n        // Create the Three.js scene\n        this.scene = new THREE.Scene();\n        \n        // Create the camera\n        this.camera = new THREE.PerspectiveCamera(\n            75, // Field of view\n            this.width / this.height, // Aspect ratio\n            0.1, // Near plane\n            5000 // Far plane\n        );\n        \n        // Set initial camera position\n        this.camera.position.set(0, 10, 20);\n        this.camera.lookAt(0, 0, 0);\n        \n        // Create the WebGL renderer\n        this.renderer = new THREE.WebGLRenderer({\n            canvas: this.canvas,\n            antialias: true,\n            alpha: true\n        });\n        this.renderer.setSize(this.width, this.height);\n        this.renderer.setPixelRatio(window.devicePixelRatio);\n        \n        // Add basic lighting\n        this.setupLighting();\n        \n        // Add controls for camera movement\n        this.setupControls();\n        \n        // Add a grid helper for development\n        if (options.debug) {\n            const gridHelper = new THREE.GridHelper(1000, 100);\n            this.scene.add(gridHelper);\n            \n            const axesHelper = new THREE.AxesHelper(5);\n            this.scene.add(axesHelper);\n        }\n        \n        // Set up event listeners\n        this.setupEventListeners();\n        \n        // Animation frame request ID\n        this.animationFrameId = null;\n        \n        // Track performance with stats if in debug mode\n        if (options.debug && window.Stats) {\n            this.stats = new Stats();\n            document.body.appendChild(this.stats.dom);\n        }\n    }\n    \n    /**\n     * Set up scene lighting\n     */\n    setupLighting() {\n        // Add ambient light - increased intensity for better visibility\n        const ambientLight = new THREE.AmbientLight(0x404040, 0.7);\n        this.scene.add(ambientLight);\n        \n        // Add directional light (sun)\n        this.sunLight = new THREE.DirectionalLight(0xffffff, 1);\n        this.sunLight.position.set(50, 100, -50);\n        this.sunLight.castShadow = true;\n        \n        // Configure shadow properties\n        this.sunLight.shadow.mapSize.width = 2048;\n        this.sunLight.shadow.mapSize.height = 2048;\n        this.sunLight.shadow.camera.near = 0.5;\n        this.sunLight.shadow.camera.far = 500;\n        this.sunLight.shadow.camera.left = -100;\n        this.sunLight.shadow.camera.right = 100;\n        this.sunLight.shadow.camera.top = 100;\n        this.sunLight.shadow.camera.bottom = -100;\n        \n        this.scene.add(this.sunLight);\n        \n        // Add a second directional light from the opposite side for fill\n        const fillLight = new THREE.DirectionalLight(0xffffcc, 0.5);\n        fillLight.position.set(-50, 75, 50);\n        this.scene.add(fillLight);\n        \n        // Set up shadow rendering\n        this.renderer.shadowMap.enabled = true;\n        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n    }\n    \n    /**\n     * Set up camera controls\n     */\n    setupControls() {\n        // We'll use OrbitControls for development/testing\n        if (THREE.OrbitControls) {\n            this.controls = new THREE.OrbitControls(this.camera, this.canvas);\n            this.controls.enableDamping = true;\n            this.controls.dampingFactor = 0.05;\n            this.controls.screenSpacePanning = false;\n            this.controls.minDistance = 5;\n            this.controls.maxDistance = 100;\n            this.controls.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent going below ground\n        }\n    }\n    \n    /**\n     * Set up event listeners for window resize\n     */\n    setupEventListeners() {\n        window.addEventListener('resize', () => this.handleResize());\n        \n        // Prevent context menu on right-click for the entire canvas\n        this.canvas.addEventListener('contextmenu', (e) => {\n            e.preventDefault();\n        }, false);\n    }\n    \n    /**\n     * Handle window resize\n     */\n    handleResize() {\n        this.width = this.canvas.clientWidth;\n        this.height = this.canvas.clientHeight;\n        \n        this.camera.aspect = this.width / this.height;\n        this.camera.updateProjectionMatrix();\n        \n        this.renderer.setSize(this.width, this.height);\n    }\n    \n    /**\n     * Start the rendering loop\n     * @param {Function} updateCallback - Function to call each frame before rendering\n     */\n    start(updateCallback) {\n        if (this.animationFrameId !== null) return;\n        \n        let lastTime = 0;\n        \n        const animate = (time) => {\n            this.animationFrameId = requestAnimationFrame(animate);\n            \n            // Calculate delta time in seconds\n            const now = time * 0.001; // Convert to seconds\n            const deltaTime = Math.min(now - lastTime, 0.1); // Cap at 100ms\n            lastTime = now;\n            \n            // Update stats if available\n            if (this.stats) this.stats.begin();\n            \n            // Run the update callback\n            if (updateCallback) updateCallback(deltaTime);\n            \n            // Update controls if available\n            if (this.controls) this.controls.update();\n            \n            // Render the scene\n            this.renderer.render(this.scene, this.camera);\n            \n            // End stats measurement\n            if (this.stats) this.stats.end();\n        };\n        \n        this.animationFrameId = requestAnimationFrame(animate);\n    }\n    \n    /**\n     * Stop the rendering loop\n     */\n    stop() {\n        if (this.animationFrameId !== null) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = null;\n        }\n    }\n    \n    /**\n     * Add an object to the scene\n     * @param {THREE.Object3D} object - Object to add to the scene\n     */\n    addObject(object) {\n        this.scene.add(object);\n    }\n    \n    /**\n     * Remove an object from the scene\n     * @param {THREE.Object3D} object - Object to remove from the scene\n     */\n    removeObject(object) {\n        this.scene.remove(object);\n    }\n    \n    /**\n     * Set up a camera to follow a boat\n     * @param {Boat} boat - Boat to follow\n     */\n    setupBoatCamera(boat) {\n        this.followBoat = boat;\n        \n        // Remove orbit controls if they exist\n        if (this.controls) {\n            this.controls.dispose();\n            this.controls = null;\n        }\n        \n        // By default, set followBoatMode to true\n        this.followBoatMode = true;\n    }\n    \n    /**\n     * Update the camera to follow a boat if set\n     */\n    updateBoatCamera() {\n        if (!this.followBoat || !this.followBoat.mesh) return;\n        \n        // If we have orbit controls, update the target to follow the boat\n        if (this.controls && this.controls instanceof OrbitControls) {\n            // Update the target position to the boat's current position\n            this.controls.target.copy(this.followBoat.position);\n            // We don't need to do anything else for orbit controls since they're updated in the animation loop\n            return;\n        }\n        \n        // Skip the default camera update for first-person mode\n        // This is now handled in the setCameraView method\n        if (!this.followBoatMode) return;\n        \n        // Regular boat camera follow logic for 'follow' camera mode\n        // Get boat position and orientation\n        const boatPosition = this.followBoat.position.clone();\n        const boatQuaternion = this.followBoat.orientation.clone();\n        const boatEuler = new THREE.Euler().setFromQuaternion(boatQuaternion);\n        \n        // Calculate camera position: behind and above the boat\n        // Adjusted for Tugboat model - higher and further back\n        const cameraOffset = new THREE.Vector3(0, 8, -15); // Above and behind\n        cameraOffset.applyEuler(boatEuler);\n        \n        const cameraPosition = boatPosition.clone().add(cameraOffset);\n        \n        // Smoothly move camera to new position\n        this.camera.position.lerp(cameraPosition, 0.1);\n        \n        // Look at the boat, slightly above its position\n        const targetPosition = boatPosition.clone().add(new THREE.Vector3(0, 1.5, 0));\n        this.camera.lookAt(targetPosition);\n    }\n    \n    /**\n     * Set the time of day affecting lighting\n     * @param {number} timeOfDay - Time in hours (0-24)\n     */\n    setTimeOfDay(timeOfDay) {\n        // Normalize time to 0-1 range\n        const normalizedTime = (timeOfDay % 24) / 24;\n        \n        // Calculate sun position based on time\n        const sunAngle = normalizedTime * Math.PI * 2 - Math.PI / 2;\n        const sunHeight = Math.sin(sunAngle);\n        const sunDistance = 100;\n        \n        this.sunLight.position.set(\n            Math.cos(sunAngle) * sunDistance,\n            Math.max(0.1, sunHeight) * sunDistance,\n            0\n        );\n        \n        // Adjust light intensity based on time\n        const dayIntensity = Math.max(0, Math.sin(sunAngle));\n        this.sunLight.intensity = 0.5 + dayIntensity * 0.5;\n        \n        // Adjust ambient light intensity\n        const ambientIntensity = 0.2 + dayIntensity * 0.3;\n        this.scene.children.forEach(child => {\n            if (child instanceof THREE.AmbientLight) {\n                child.intensity = ambientIntensity;\n            }\n        });\n        \n        // Adjust sky color based on time\n        if (this.environment && this.environment.skyMesh) {\n            // Blend between night blue and day blue\n            const nightColor = new THREE.Color(0x0a1a2a);\n            const dayColor = new THREE.Color(0x87ceeb);\n            const skyColor = new THREE.Color().lerpColors(\n                nightColor,\n                dayColor,\n                dayIntensity\n            );\n            \n            this.environment.skyMesh.material.color = skyColor;\n        }\n    }\n    \n    /**\n     * Set the environment object for time of day effects\n     * @param {Environment} environment - Environment object\n     */\n    setEnvironment(environment) {\n        this.environment = environment;\n    }\n    \n    /**\n     * Clean up resources when no longer needed\n     */\n    dispose() {\n        this.stop();\n        \n        window.removeEventListener('resize', this.handleResize);\n        \n        if (this.controls) {\n            this.controls.dispose();\n        }\n        \n        if (this.stats) {\n            document.body.removeChild(this.stats.dom);\n        }\n        \n        // Dispose of the renderer\n        this.renderer.dispose();\n    }\n}\n\n// Export the Renderer class\nexport default Renderer; ","__webpack_require__.h = () => (\"0c9da9e92bda942a1dcc\")"],"names":[],"sourceRoot":""}