{"version":3,"file":"main.ab279cba04277b1f9172.hot-update.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACoC,CAAC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,eAAe;AAC9B,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,yCAAyC;AACzC,2BAA2B;AAC3B;AACA;AACA,8BAA8B;AAC9B,2BAA2B;AAC3B;AACA;AACA,0BAA0B;AAC1B,wBAAwB;AACxB;AACA;AACA,0BAA0B;AAC1B;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,gBAAgB;AACvF;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB;AACtB,8CAA8C,YAAY;AAC1D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,oEAAoE,UAAU;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iBAAiB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,iBAAiB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iBAAiB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAoB,CAAC,+CAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,cAAc;AACd;AACA,gEAAgE;AAChE,cAAc;AACd;AACA,sCAAsC;AACtC,cAAc;AACd;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,+CAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAc;AACjD;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,+BAA+B,4CAAW;AAC1C;AACA;AACA;AACA,4BAA4B,4CAAW;AACvC;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;;AAEA;AACA,iEAAe,IAAI,EAAC;;;;;;;;UCvgCpB","sources":["webpack://opensail/./src/js/boat.js","webpack://opensail/webpack/runtime/getFullHash"],"sourcesContent":["/**\n * Boat class to handle boat physics and visualization\n */\nimport * as Utils from './utils.js'; // Import all utility functions as Utils namespace\n\n/**\n * Boat class representing a sailboat in the game\n */\nclass Boat {\n    /**\n     * Create a new Boat\n     * @param {Object} options - Boat configuration options\n     * @param {string} options.id - Unique identifier for the boat\n     * @param {string} options.playerName - Name of the player controlling the boat\n     * @param {THREE.Vector3} options.position - Initial position\n     * @param {THREE.Quaternion} options.orientation - Initial orientation\n     * @param {number} options.length - Boat length in meters\n     * @param {number} options.width - Boat width in meters\n     * @param {THREE.Scene} options.scene - Three.js scene to add the boat to\n     */\n    constructor(options) {\n        this.id = options.id || 'boat_' + Math.random().toString(36).substr(2, 9);\n        this.playerName = options.playerName || 'Player';\n        \n        // Physics properties\n        this.position = options.position || new THREE.Vector3(0, 0, 0);\n        this.orientation = options.orientation || new THREE.Quaternion();\n        this.velocity = new THREE.Vector3(0, 0, 0);\n        this.angularVelocity = new THREE.Vector3(0, 0, 0);\n        \n        // Boat dimensions\n        this.length = options.length || 6; // meters\n        this.width = options.width || 2; // meters\n        this.height = 2.5; // meters\n        \n        // Control properties\n        this.rudderAngle = 0; // degrees, -45 to 45\n        this.throttle = 0; // 0 to 1 for engine power\n        \n        // Boat state\n        this.heading = 0; // degrees, 0-359\n        this.speed = 0; // knots\n        \n        // Physics constants (will be tuned)\n        this.mass = 1000; // kg\n        this.dragCoefficient = 0.05;\n        this.enginePowerCoefficient = 2000; // Force in newtons at full throttle\n        this.rudderForceCoefficient = 15;\n        this.lateralResistanceCoefficient = 50;\n        \n        // 3D model properties\n        this.mesh = null;\n        this.scene = options.scene;\n        \n        // Initialize the 3D model\n        this.initMesh();\n        \n        // Engine effects\n        this.engineSound = null;\n        this.engineParticles = null;\n    }\n    \n    /**\n     * Initialize the 3D mesh for the boat\n     */\n    initMesh() {\n        try {\n            // Use GLTFLoader for loading .glb models\n            const loader = new GLTFLoader();\n            \n            // Try with multiple path formats\n            const modelPaths = [\n                window.ASSET_PATH.models + 'boat.glb',     // Using configured path\n                '/assets/models/boat.glb',                 // Absolute path from root\n                'assets/models/boat.glb',                  // No leading slash\n                './assets/models/boat.glb'                 // Relative path with dot\n            ];\n            \n            console.log(\"Attempting to load boat model with paths:\", modelPaths);\n            \n            // First check if the file exists using fetch\n            fetch(modelPaths[0])\n                .then(response => {\n                    if (!response.ok) {\n                        throw new Error(`File not accessible (status ${response.status})`);\n                    }\n                    console.log(\"boat.glb is accessible via fetch at:\", modelPaths[0]);\n                    // File exists, proceed with GLTFLoader\n                    return this.loadModelWithLoader(modelPaths[0]);\n                })\n                .catch(error => {\n                    console.error(\"Fetch failed:\", error);\n                    console.log(\"Trying alternate loading methods...\");\n                    this.tryNextPath(modelPaths, 1);\n                });\n                \n            // Create boat wake\n            this.createBoatWake();\n        } catch (e) {\n            console.error(\"Exception in initMesh:\", e);\n            this.createFallbackBoat();\n        }\n    }\n    \n    /**\n     * Load model with GLTFLoader\n     */\n    loadModelWithLoader(modelPath) {\n        const loader = new GLTFLoader();\n        console.log(\"Loading boat model using GLTFLoader with path:\", modelPath);\n        \n        return new Promise((resolve, reject) => {\n            loader.load(\n                modelPath,\n                (gltf) => {\n                    console.log(\"Boat model loaded successfully with path:\", modelPath);\n                    this.mesh = gltf.scene;\n                    \n                    // Log the loaded model structure to help with debugging\n                    console.log(\"GLTF model structure:\", gltf);\n                    \n                    // Set initial position and orientation\n                    this.mesh.position.copy(this.position);\n                    this.mesh.quaternion.copy(this.orientation);\n                    \n                    // Rotate the boat model 180 degrees around the Y axis\n                    this.mesh.rotation.y = Math.PI; // 180 degrees in radians\n                    \n                    // Set a proper scale for the boat\n                    const scale = 0.5; // Start with a moderate scale, adjust based on model size\n                    this.mesh.scale.set(scale, scale, scale);\n                    \n                    // Lower the boat position to reduce hovering\n                    this.mesh.position.y -= 0.5; // Adjust this value as needed\n                    \n                    // Add boat to scene\n                    if (this.scene) {\n                        this.scene.add(this.mesh);\n                        console.log(\"Boat added to scene successfully\");\n                    } else {\n                        console.error(\"Scene not available, cannot add boat mesh\");\n                    }\n                    \n                    // Create player name label\n                    this.createPlayerLabel();\n                    \n                    // Add the sail\n                    this.addSail();\n                    \n                    // Set up shadows\n                    this.setupShadows();\n                    \n                    // Log success\n                    console.log(`Boat for ${this.playerName} loaded`);\n                    resolve(this.mesh);\n                },\n                // onProgress callback\n                (xhr) => {\n                    if (xhr.total && xhr.total > 0) {\n                        console.log((xhr.loaded / xhr.total * 100) + '% of boat model loaded');\n                    } else {\n                        console.log(`Loaded ${xhr.loaded} bytes`);\n                    }\n                },\n                // onError callback\n                (error) => {\n                    console.error(\"GLTFLoader failed with path:\", modelPath, error);\n                    reject(error);\n                }\n            );\n        });\n    }\n    \n    /**\n     * Try loading the model with the next available path\n     */\n    tryNextPath(paths, index) {\n        if (index >= paths.length) {\n            console.error(\"All paths failed, creating fallback boat\");\n            this.createFallbackBoat();\n            return;\n        }\n        \n        const modelPath = paths[index];\n        console.log(\"Trying alternate path:\", modelPath);\n        \n        const loader = new GLTFLoader();\n        loader.load(\n            modelPath,\n            (gltf) => {\n                console.log(\"Boat model loaded successfully with alternate path:\", modelPath);\n                this.mesh = gltf.scene;\n                \n                // Set initial position and orientation\n                this.mesh.position.copy(this.position);\n                this.mesh.quaternion.copy(this.orientation);\n                \n                // Rotate the boat model 180 degrees around the Y axis\n                this.mesh.rotation.y = Math.PI; // 180 degrees in radians\n                \n                // Set a proper scale for the boat\n                const scale = 0.5; // Adjusted scale for better visibility\n                this.mesh.scale.set(scale, scale, scale);\n                \n                // Lower the boat position to reduce hovering\n                this.mesh.position.y -= 0.5; // Adjust this value as needed\n                \n                // Add to scene\n                if (this.scene) {\n                    this.scene.add(this.mesh);\n                    console.log(\"Boat added to scene with alternate path\");\n                } else {\n                    console.error(\"Scene not available for alternate path loading\");\n                }\n                \n                // Create player name label\n                this.createPlayerLabel();\n                \n                // Add the sail\n                this.addSail();\n                \n                // Set up shadows\n                this.setupShadows();\n                \n                // Log success\n                console.log(`Boat for ${this.playerName} loaded with alternate path`);\n            },\n            // onProgress callback\n            (xhr) => {\n                if (xhr.total && xhr.total > 0) {\n                    console.log((xhr.loaded / xhr.total * 100) + '% of boat model loaded (alternate path)');\n                }\n            },\n            // onError callback\n            (error) => {\n                console.error(`Error loading boat model with path ${modelPath}:`, error);\n                // Try the next path\n                this.tryNextPath(paths, index + 1);\n            }\n        );\n    }\n    \n    /**\n     * Load the boat texture (now handled by GLTFLoader for glb files)\n     */\n    loadTexture() {\n        // GLB files already include textures, so this method is not needed\n        // We'll keep it as a placeholder in case custom textures are needed later\n        console.log(\"Using textures embedded in the GLB file\");\n    }\n    \n    /**\n     * Create a simple fallback mesh if the model fails to load\n     */\n    createFallbackBoat() {\n        // Create a simple boat shape using primitive geometries\n        const boatGroup = new THREE.Group();\n        \n        // Hull\n        const hullGeometry = new THREE.BoxGeometry(this.length, this.height / 2, this.width);\n        const hullMaterial = new THREE.MeshPhongMaterial({ color: 0x3366ff });\n        const hull = new THREE.Mesh(hullGeometry, hullMaterial);\n        hull.position.y = -this.height / 4;\n        boatGroup.add(hull);\n        \n        // Cabin\n        const cabinGeometry = new THREE.BoxGeometry(this.length / 3, this.height / 2, this.width * 0.8);\n        const cabinMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });\n        const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);\n        cabin.position.set(0, this.height / 4, 0);\n        boatGroup.add(cabin);\n        \n        // Mast\n        const mastGeometry = new THREE.CylinderGeometry(0.05, 0.05, this.height * 2, 8);\n        const mastMaterial = new THREE.MeshPhongMaterial({ color: 0x999999 });\n        const mast = new THREE.Mesh(mastGeometry, mastMaterial);\n        mast.position.set(0, this.height, 0);\n        boatGroup.add(mast);\n        \n        // Sail\n        this.sail = new THREE.Group();\n        const sailGeometry = new THREE.PlaneGeometry(this.length * 0.7, this.height * 1.5);\n        const sailMaterial = new THREE.MeshPhongMaterial({ \n            color: 0xffffff,\n            side: THREE.DoubleSide\n        });\n        const sailMesh = new THREE.Mesh(sailGeometry, sailMaterial);\n        sailMesh.position.set(this.length * 0.2, 0, 0);\n        sailMesh.rotation.y = Math.PI / 2;\n        this.sail.add(sailMesh);\n        this.sail.position.set(0, this.height * 0.75, 0);\n        boatGroup.add(this.sail);\n        \n        // Center the boat\n        boatGroup.position.copy(this.position);\n        boatGroup.quaternion.copy(this.orientation);\n        \n        // Set as the boat mesh\n        this.mesh = boatGroup;\n        \n        // Add to scene\n        if (this.scene) {\n            this.scene.add(this.mesh);\n        }\n        \n        // Create player name label\n        this.createPlayerLabel();\n        \n        console.log(`Fallback boat for ${this.playerName} created`);\n    }\n    \n    /**\n     * Create a text label showing the player name\n     */\n    createPlayerLabel() {\n        // This would typically use a sprite with a dynamically generated texture\n        // For simplicity, we'll omit the actual implementation for now\n    }\n    \n    /**\n     * Update the boat physics\n     * @param {Object} environment - Environment information including wind and waves\n     * @param {number} deltaTime - Time step in seconds\n     */\n    update(environment, deltaTime) {\n        // Skip physics if deltaTime is too large (e.g., after pausing)\n        if (deltaTime > 0.1) deltaTime = 0.1;\n        \n        // Get environment info\n        const { wind, waves } = environment;\n        \n        // Calculate forces\n        const forces = this.calculateForces(wind, waves);\n        \n        // Apply acceleration based on forces\n        const acceleration = forces.clone().divideScalar(this.mass);\n        \n        // Update velocity (v = v0 + a * t)\n        this.velocity.add(acceleration.clone().multiplyScalar(deltaTime));\n        \n        // Apply drag (simplified)\n        this.velocity.multiplyScalar(1 - this.dragCoefficient * deltaTime);\n        \n        // Update position (p = p0 + v * t)\n        this.position.add(this.velocity.clone().multiplyScalar(deltaTime));\n        \n        // Apply angular velocity with realistic damping\n        // Real boats have significant rotational inertia\n        const rotationAxis = new THREE.Vector3(0, 1, 0);\n        const rotationAngle = this.angularVelocity.y * deltaTime;\n        const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(rotationAxis, rotationAngle);\n        this.orientation.premultiply(rotationQuaternion);\n        this.orientation.normalize();\n        \n        // Apply water resistance to angular velocity\n        // Water creates substantial resistance to rotation\n        this.angularVelocity.multiplyScalar(0.97);\n        \n        // Update heading (in degrees)\n        const euler = new THREE.Euler().setFromQuaternion(this.orientation);\n        this.heading = Utils.normalizeAngle(Utils.radToDeg(euler.y) * -1);\n        \n        // Calculate speed in knots (1 m/s ≈ 1.94 knots)\n        this.speed = this.velocity.length() * 1.94;\n        \n        // Create water splash effects when the boat is moving fast enough\n        if (this.speed > 2 && Math.random() < 0.05) {\n            // Create a new splash effect at random intervals\n            if (!this.splashParticles) {\n                this.createWaterSplash();\n            }\n        }\n        \n        // Update existing water splash\n        if (this.splashParticles) {\n            this.updateWaterSplash(deltaTime);\n        }\n        \n        // Update engine effects if throttle is active\n        if (this.throttle > 0) {\n            this.createEngineEffects();\n        } else if (this.engineParticles) {\n            // Fade out engine particles when throttle is zero\n            this.updateEngineEffects();\n            if (this.engineParticles.system.material.opacity <= 0.05) {\n                // Remove particles when fully faded\n                this.scene.remove(this.engineParticles.system);\n                this.engineParticles.system.geometry.dispose();\n                this.engineParticles.system.material.dispose();\n                this.engineParticles = null;\n            }\n        }\n        \n        // Update boat wake\n        this.updateBoatWake();\n        \n        // Apply wave effects on boat position and rotation\n        this.applyWaveEffects(waves, deltaTime);\n        \n        // Update 3D model if it exists\n        this.updateMesh();\n        \n        // Return state for networking\n        return {\n            id: this.id,\n            position: this.position.clone(),\n            orientation: this.orientation.clone(),\n            velocity: this.velocity.clone(),\n            angularVelocity: this.angularVelocity.clone(),\n            rudderAngle: this.rudderAngle,\n            throttle: this.throttle,\n            heading: this.heading,\n            speed: this.speed\n        };\n    }\n    \n    /**\n     * Calculate forces acting on the boat\n     * @param {Object} wind - Wind information\n     * @param {Object} waves - Wave information\n     * @returns {THREE.Vector3} - Net force in newtons\n     */\n    calculateForces(wind, waves) {\n        // Direction the boat is facing\n        const boatDirection = new THREE.Vector3(0, 0, 1);\n        boatDirection.applyQuaternion(this.orientation);\n        \n        // Engine force\n        let engineForce = new THREE.Vector3();\n        if (this.throttle !== 0) {\n            // Allow for reverse by negating the force\n            const forceDirection = this.throttle < 0 ? -1 : 1;\n            const throttleValue = Math.abs(this.throttle);\n            \n            const forceMagnitude = this.enginePowerCoefficient * throttleValue * forceDirection;\n            engineForce = boatDirection.clone().multiplyScalar(forceMagnitude);\n            \n            // Create engine effects\n            this.createEngineEffects();\n        }\n        \n        // Rudder force (turning)\n        const rudderForce = new THREE.Vector3();\n        if (this.rudderAngle !== 0) {\n            // Calculate rudder direction (perpendicular to boat direction)\n            const rudderDirection = new THREE.Vector3(boatDirection.z, 0, -boatDirection.x);\n            \n            // Calculate boat speed for turning physics\n            const speedKnots = this.speed;\n            \n            // Modified turning physics for better responsiveness\n            // Maintain good turning capability at all speeds\n            \n            // Improved turn efficiency curve for better responsiveness\n            let turnEfficiency = 0;\n            \n            if (speedKnots < 1) {\n                // Better turning at very low speeds\n                turnEfficiency = 0.8 + speedKnots * 0.2; // Significantly improved minimum turning (was 0.5)\n            } else if (speedKnots < 5) {\n                // Increasing effectiveness as speed builds\n                turnEfficiency = 1.0 + (speedKnots - 1) * 0.05; // 1.0 to 1.2 range (was 0.8 to 1.0)\n            } else if (speedKnots < 10) {\n                // Peak turning efficiency at medium speeds (5-10 knots)\n                turnEfficiency = 1.2; // Enhanced peak efficiency (was 1.0)\n            } else {\n                // Less fall-off at higher speeds for better control\n                turnEfficiency = 1.2 - Math.min(0.3, (speedKnots - 10) * 0.02); // Slower falloff (was 0.03)\n            }\n            \n            // FIX: Invert rudder angle to fix the inverted controls\n            // Negative rudder angle should turn left, positive should turn right\n            const correctedRudderAngle = -this.rudderAngle;\n            \n            // Apply enhanced force scaling based on improved turn efficiency\n            const forceMagnitude = this.rudderForceCoefficient * correctedRudderAngle * turnEfficiency;\n            \n            rudderForce.copy(rudderDirection).multiplyScalar(forceMagnitude);\n            \n            // Apply angular velocity based on more responsive physics\n            // Using reduced moment of inertia for more agile turning\n            \n            // Further reduced moment of inertia for even better responsiveness\n            // Dividing by 3 to simulate a highly maneuverable boat (was divided by 2)\n            const momentOfInertia = (1/12) * this.mass * (this.length * this.length + this.width * this.width) / 3;\n            \n            // Direction is reversed when going backward\n            const directionModifier = this.velocity.dot(boatDirection) < 0 ? -1 : 1;\n            \n            // Calculate torque with increased response\n            const torque = correctedRudderAngle * turnEfficiency * directionModifier;\n            \n            // Angular acceleration with increased factor for more responsive turning\n            const angularAcceleration = torque / momentOfInertia * 0.05; // Increased from 0.02\n            \n            // Apply angular acceleration over time - more responsive than before\n            this.angularVelocity.y += angularAcceleration;\n            \n            // Increased maximum angular velocity for faster turning\n            const maxAngularVelocity = 1.0; // Increased from 0.5 - allows for faster turning\n            this.angularVelocity.y = THREE.MathUtils.clamp(\n                this.angularVelocity.y, \n                -maxAngularVelocity, \n                maxAngularVelocity\n            );\n        } else {\n            // Reduced deceleration for angular velocity - stays turning longer\n            this.angularVelocity.y *= 0.98; // Changed from 0.97 - slower decay when not turning\n        }\n        \n        // Drag forces (opposite to velocity)\n        const dragForce = new THREE.Vector3();\n        if (this.velocity.lengthSq() > 0) {\n            const velocityMagnitude = this.velocity.length();\n            \n            // Realistic drag increases with the square of velocity\n            const dragCoefficient = this.dragCoefficient * (1 + velocityMagnitude * 0.05);\n            \n            const dragMagnitude = dragCoefficient * velocityMagnitude * velocityMagnitude;\n            dragForce.copy(this.velocity).normalize().multiplyScalar(-dragMagnitude);\n        }\n        \n        // Sum all forces\n        return engineForce.add(rudderForce).add(dragForce);\n    }\n    \n    /**\n     * Create engine effects (particles and sound)\n     */\n    createEngineEffects() {\n        if (!this.scene) return;\n        \n        // Create engine particles if they don't exist yet\n        if (!this.engineParticles) {\n            // Create particle system for engine exhaust\n            const particleGeometry = new THREE.BufferGeometry();\n            const particleMaterial = new THREE.PointsMaterial({\n                color: 0x888888,\n                size: 0.1,\n                transparent: true,\n                opacity: 0.6\n            });\n            \n            // Create initial particles at the rear of the boat\n            const particleCount = 30;\n            const positions = new Float32Array(particleCount * 3);\n            \n            for (let i = 0; i < particleCount; i++) {\n                const i3 = i * 3;\n                positions[i3] = 0; // Will be set in updateEngineEffects\n                positions[i3 + 1] = 0; \n                positions[i3 + 2] = 0;\n            }\n            \n            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n            \n            // Create the particle system\n            this.engineParticles = {\n                system: new THREE.Points(particleGeometry, particleMaterial),\n                velocities: [],\n                lifetime: 2, // seconds\n                timer: 0\n            };\n            \n            // Initialize particle velocities\n            for (let i = 0; i < particleCount; i++) {\n                this.engineParticles.velocities.push({\n                    x: (Math.random() - 0.5) * 0.05,\n                    y: Math.random() * 0.1 + 0.05,\n                    z: -Math.random() * 0.2 - 0.1  // Mostly backward\n                });\n            }\n            \n            this.scene.add(this.engineParticles.system);\n        }\n        \n        // Update engine effects\n        this.updateEngineEffects();\n    }\n    \n    /**\n     * Update engine particle effects\n     */\n    updateEngineEffects() {\n        if (!this.engineParticles) return;\n        \n        // The boat direction\n        const boatDirection = new THREE.Vector3(0, 0, 1);\n        boatDirection.applyQuaternion(this.orientation);\n        \n        // Position at the back of the boat\n        const enginePosition = this.position.clone().sub(\n            boatDirection.clone().multiplyScalar(this.length * 0.45)\n        );\n        enginePosition.y += 0.5; // Slightly above water level\n        \n        // Get particle positions\n        const positions = this.engineParticles.system.geometry.attributes.position.array;\n        const particleCount = positions.length / 3;\n        \n        // Create new particles at the engine position based on throttle\n        const emissionRate = Math.ceil(Math.abs(this.throttle) * 2); // More particles at higher throttle\n        \n        for (let i = 0; i < emissionRate; i++) {\n            // Find an \"expired\" particle to reuse, or use a random one\n            let particleIndex = Math.floor(Math.random() * particleCount);\n            \n            const i3 = particleIndex * 3;\n            \n            // Reset position to engine\n            positions[i3] = enginePosition.x + (Math.random() - 0.5) * 0.1;\n            positions[i3 + 1] = enginePosition.y + (Math.random() - 0.5) * 0.1;\n            positions[i3 + 2] = enginePosition.z + (Math.random() - 0.5) * 0.1;\n            \n            // Determine emission direction based on throttle\n            // When in reverse, emit particles from the front of the boat\n            const isReverse = this.throttle < 0;\n            let particleDirection;\n            \n            if (isReverse) {\n                // When in reverse, emit from front of boat\n                particleDirection = boatDirection.clone();\n                // Position adjustment for reverse\n                const frontPosition = this.position.clone().add(\n                    boatDirection.clone().multiplyScalar(this.length * 0.45)\n                );\n                positions[i3] = frontPosition.x + (Math.random() - 0.5) * 0.1;\n                positions[i3 + 2] = frontPosition.z + (Math.random() - 0.5) * 0.1;\n            } else {\n                // Normal forward emission from rear\n                particleDirection = boatDirection.clone().negate();\n            }\n            \n            // Reset velocity - direction depends on boat orientation and throttle\n            const velocity = new THREE.Vector3(\n                (Math.random() - 0.5) * 0.05 + particleDirection.x * 0.1,\n                Math.random() * 0.1 + 0.05,\n                (Math.random() - 0.5) * 0.05 + particleDirection.z * 0.1\n            );\n            \n            this.engineParticles.velocities[particleIndex] = {\n                x: velocity.x,\n                y: velocity.y,\n                z: velocity.z\n            };\n        }\n        \n        // Update all particles\n        for (let i = 0; i < particleCount; i++) {\n            const i3 = i * 3;\n            \n            // Update position based on velocity\n            positions[i3] += this.engineParticles.velocities[i].x;\n            positions[i3 + 1] += this.engineParticles.velocities[i].y;\n            positions[i3 + 2] += this.engineParticles.velocities[i].z;\n            \n            // Apply gravity and fade to particles\n            this.engineParticles.velocities[i].y -= 0.001;\n        }\n        \n        // Adjust opacity based on throttle\n        this.engineParticles.system.material.opacity = 0.6 * Math.abs(this.throttle);\n        \n        // Mark positions for update\n        this.engineParticles.system.geometry.attributes.position.needsUpdate = true;\n    }\n    \n    /**\n     * Apply wave effects to the boat\n     * @param {Object} waves - Wave information\n     * @param {number} deltaTime - Time step in seconds\n     */\n    applyWaveEffects(waves, deltaTime) {\n        if (!waves || !waves.isActive) return;\n        \n        // Calculate wave height at boat position\n        const waveHeight = this.calculateWaveHeight(this.position, waves, Date.now() / 1000);\n        \n        // Adjust boat position based on wave height\n        this.position.y = waveHeight;\n        \n        // Calculate wave slope at boat position for pitch and roll\n        const slopeX = this.calculateWaveSlope(this.position, waves, Date.now() / 1000, 'x');\n        const slopeZ = this.calculateWaveSlope(this.position, waves, Date.now() / 1000, 'z');\n        \n        // Apply pitch and roll based on wave slope\n        const targetRotation = new THREE.Quaternion().setFromEuler(\n            new THREE.Euler(-slopeZ * 0.5, Utils.degToRad(this.heading) * -1, slopeX * 0.5)\n        );\n        \n        // Smoothly interpolate rotation\n        this.orientation.slerp(targetRotation, 2 * deltaTime);\n    }\n    \n    /**\n     * Calculate wave height at a given position\n     * @param {THREE.Vector3} position - Position to calculate height at\n     * @param {Object} waves - Wave parameters\n     * @param {number} time - Current time\n     * @returns {number} Wave height\n     */\n    calculateWaveHeight(position, waves, time) {\n        // Simple sin wave function\n        // In a real implementation, would use a sum of multiple sine waves\n        const x = position.x;\n        const z = position.z;\n        const amplitude = waves.amplitude || 0.5;\n        const frequency = waves.frequency || 0.2;\n        const direction = waves.direction || 0;\n        const speed = waves.speed || 1;\n        \n        // Calculate directed coordinates\n        const dirRad = Utils.degToRad(direction);\n        const dx = x * Math.cos(dirRad) + z * Math.sin(dirRad);\n        \n        // Calculate height using sin wave\n        return amplitude * Math.sin(dx * frequency + time * speed);\n    }\n    \n    /**\n     * Calculate wave slope at a given position\n     * @param {THREE.Vector3} position - Position to calculate slope at\n     * @param {Object} waves - Wave parameters\n     * @param {number} time - Current time\n     * @param {string} axis - Axis to calculate slope for ('x' or 'z')\n     * @returns {number} Wave slope\n     */\n    calculateWaveSlope(position, waves, time, axis) {\n        // Sample height at two nearby points to calculate slope\n        const delta = 0.1;\n        let pos1 = position.clone();\n        let pos2 = position.clone();\n        \n        if (axis === 'x') {\n            pos1.x -= delta;\n            pos2.x += delta;\n        } else {\n            pos1.z -= delta;\n            pos2.z += delta;\n        }\n        \n        const height1 = this.calculateWaveHeight(pos1, waves, time);\n        const height2 = this.calculateWaveHeight(pos2, waves, time);\n        \n        return (height2 - height1) / (2 * delta);\n    }\n    \n    /**\n     * Update the 3D mesh based on current state\n     */\n    updateMesh() {\n        if (!this.mesh) return;\n        \n        // Update position and orientation\n        this.mesh.position.copy(this.position);\n        \n        // First apply the orientation from physics\n        this.mesh.quaternion.copy(this.orientation);\n        \n        // Then apply a fixed 180-degree rotation to show the back of the boat\n        // Create a rotation quaternion for 180 degrees around Y axis\n        const rotationY = new THREE.Quaternion().setFromAxisAngle(\n            new THREE.Vector3(0, 1, 0),\n            Math.PI  // 180 degrees in radians\n        );\n        \n        // Apply the rotation after the orientation\n        this.mesh.quaternion.multiply(rotationY);\n        \n        // Update sail rotation if we have a sail object\n        if (this.sail) {\n            this.sail.rotation.y = Utils.degToRad(this.rudderAngle);\n        }\n    }\n    \n    /**\n     * Set boat controls\n     * @param {Object} controls - Control inputs\n     * @param {number} controls.rudderAngle - Rudder angle (-45 to 45 degrees)\n     * @param {number} controls.throttle - Throttle (0 to 1)\n     */\n    setControls(controls) {\n        if (controls.rudderAngle !== undefined) {\n            this.rudderAngle = Utils.clamp(controls.rudderAngle, -45, 45);\n        }\n        \n        if (controls.throttle !== undefined) {\n            this.throttle = Utils.clamp(controls.throttle, 0, 1);\n        }\n    }\n    \n    /**\n     * Handle server update for client-side interpolation\n     * @param {Object} state - Boat state from server\n     */\n    handleServerUpdate(state) {\n        // Update position and orientation for interpolation\n        this.serverPosition = new THREE.Vector3().fromArray(state.position);\n        this.serverOrientation = new THREE.Quaternion(\n            state.orientation[0],\n            state.orientation[1],\n            state.orientation[2],\n            state.orientation[3]\n        );\n        this.serverVelocity = new THREE.Vector3().fromArray(state.velocity);\n        this.heading = state.heading;\n        this.speed = state.speed;\n        \n        // Directly update controls\n        this.rudderAngle = state.rudderAngle;\n        this.throttle = state.throttle;\n    }\n    \n    /**\n     * Interpolate between current and server state\n     * @param {number} alpha - Interpolation factor (0-1)\n     */\n    interpolate(alpha) {\n        if (!this.serverPosition || !this.serverOrientation) return;\n        \n        // Interpolate position\n        this.position.lerp(this.serverPosition, alpha);\n        \n        // Interpolate orientation\n        this.orientation.slerp(this.serverOrientation, alpha);\n        \n        // Update mesh\n        this.updateMesh();\n    }\n    \n    /**\n     * Remove boat from scene and clean up resources\n     */\n    dispose() {\n        if (this.mesh && this.scene) {\n            this.scene.remove(this.mesh);\n            \n            // Dispose geometries and materials\n            if (this.mesh.traverse) {\n                this.mesh.traverse((child) => {\n                    if (child.geometry) child.geometry.dispose();\n                    if (child.material) {\n                        if (Array.isArray(child.material)) {\n                            child.material.forEach(material => material.dispose());\n                        } else {\n                            child.material.dispose();\n                        }\n                    }\n                });\n            }\n        }\n    }\n    \n    /**\n     * Add a sail to the loaded boat model\n     * For GLB models, this is optional as the model may already have a sail\n     */\n    addSail() {\n        // We don't add sails anymore because this is an engine boat\n        console.log(\"This is an engine boat - no sail needed\");\n    }\n    \n    /**\n     * Set up shadows for the boat\n     */\n    setupShadows() {\n        if (!this.mesh) return;\n        \n        // Add shadow casting/receiving to all meshes\n        this.mesh.traverse(child => {\n            if (child.isMesh) {\n                child.castShadow = true;\n                child.receiveShadow = true;\n            }\n        });\n        \n        console.log(\"Shadows set up for the boat\");\n    }\n    \n    /**\n     * Create a water splash effect\n     */\n    createWaterSplash() {\n        if (!this.scene) return;\n        \n        // Create a splash particle system\n        const splashGeometry = new THREE.BufferGeometry();\n        const splashMaterial = new THREE.PointsMaterial({\n            color: 0xFFFFFF,\n            size: 0.1,\n            transparent: true,\n            opacity: 0.8\n        });\n        \n        // Create particles\n        const particleCount = 50;\n        const positions = new Float32Array(particleCount * 3);\n        \n        // Initialize particles at the boat position\n        for (let i = 0; i < particleCount; i++) {\n            const i3 = i * 3;\n            positions[i3] = this.position.x + (Math.random() - 0.5) * this.width * 0.5;\n            positions[i3 + 1] = 0; // At water level\n            positions[i3 + 2] = this.position.z + (Math.random() - 0.5) * this.length * 0.5;\n        }\n        \n        splashGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n        \n        // Create the particle system\n        this.splashParticles = new THREE.Points(splashGeometry, splashMaterial);\n        this.scene.add(this.splashParticles);\n        \n        // Store particle velocities\n        this.splashVelocities = [];\n        for (let i = 0; i < particleCount; i++) {\n            this.splashVelocities.push({\n                x: (Math.random() - 0.5) * 0.1,\n                y: Math.random() * 0.2,\n                z: (Math.random() - 0.5) * 0.1\n            });\n        }\n        \n        // Set splash lifetime\n        this.splashLifetime = 1; // seconds\n        this.splashTimer = 0;\n    }\n    \n    /**\n     * Update the water splash effect\n     * @param {number} deltaTime - Time since last update in seconds\n     */\n    updateWaterSplash(deltaTime) {\n        if (!this.splashParticles) return;\n        \n        // Increment splash timer\n        this.splashTimer += deltaTime;\n        \n        // If the splash has lived its lifetime, remove it\n        if (this.splashTimer >= this.splashLifetime) {\n            this.scene.remove(this.splashParticles);\n            this.splashParticles.geometry.dispose();\n            this.splashParticles.material.dispose();\n            this.splashParticles = null;\n            this.splashVelocities = null;\n            return;\n        }\n        \n        // Update particle positions based on velocity\n        const positions = this.splashParticles.geometry.attributes.position.array;\n        const particleCount = positions.length / 3;\n        \n        for (let i = 0; i < particleCount; i++) {\n            const i3 = i * 3;\n            \n            // Update position based on velocity\n            positions[i3] += this.splashVelocities[i].x;\n            positions[i3 + 1] += this.splashVelocities[i].y;\n            positions[i3 + 2] += this.splashVelocities[i].z;\n            \n            // Apply gravity to y velocity\n            this.splashVelocities[i].y -= 0.01;\n        }\n        \n        // Update particle opacity based on lifetime\n        const progress = this.splashTimer / this.splashLifetime;\n        this.splashParticles.material.opacity = 0.8 * (1 - progress);\n        \n        // Mark the attribute as needing an update\n        this.splashParticles.geometry.attributes.position.needsUpdate = true;\n    }\n    \n    /**\n     * Create a wake trail behind the boat\n     */\n    createBoatWake() {\n        if (!this.scene) return;\n        \n        // Create a curved wake trail using a simple mesh\n        const wakeWidth = this.width * 1.5;\n        const wakeLength = this.length * 4;\n        \n        // Create wake geometry\n        const wakeGeometry = new THREE.PlaneGeometry(wakeWidth, wakeLength, 8, 16);\n        \n        // Create wake material with transparency\n        const wakeMaterial = new THREE.MeshBasicMaterial({\n            color: 0xFFFFFF,\n            transparent: true,\n            opacity: 0.3,\n            side: THREE.DoubleSide\n        });\n        \n        // Create wake mesh\n        this.wakeMesh = new THREE.Mesh(wakeGeometry, wakeMaterial);\n        \n        // Position wake behind the boat at water level\n        this.wakeMesh.position.y = 0.05; // Slightly above water to avoid z-fighting\n        this.wakeMesh.rotation.x = Math.PI / 2; // Lay flat on water\n        \n        // Add to scene\n        this.scene.add(this.wakeMesh);\n    }\n    \n    /**\n     * Update the boat wake\n     */\n    updateBoatWake() {\n        if (!this.wakeMesh) return;\n        \n        // Position wake behind the boat\n        const boatPosition = this.position.clone();\n        const boatDirection = new THREE.Vector3(0, 0, -1);\n        boatDirection.applyQuaternion(this.orientation);\n        \n        // Offset wake behind the boat\n        const wakeOffset = boatDirection.clone().multiplyScalar(-this.length);\n        this.wakeMesh.position.copy(boatPosition.clone().add(wakeOffset));\n        this.wakeMesh.position.y = 0.05; // Keep at water level\n        \n        // Orient wake to match boat direction\n        this.wakeMesh.quaternion.copy(this.orientation);\n        this.wakeMesh.rotation.x = Math.PI / 2; // Make sure it stays flat\n        \n        // Adjust opacity based on speed\n        const maxOpacity = 0.3;\n        const speedFactor = Math.min(this.speed / 10, 1); // Max opacity at 10 knots\n        this.wakeMesh.material.opacity = maxOpacity * speedFactor;\n    }\n}\n\n// Export the Boat class\nexport default Boat; ","__webpack_require__.h = () => (\"68560b53f7947241d443\")"],"names":[],"sourceRoot":""}